{
    "meta": {
        "exported_on": 1523786006000000,
        "version": "000"
    },
    "data": {
        "posts": [
            {
                "id": 61,
                "title": "Visual Studio Code – Node.js 개발",
                "slug": "visual-studio-code-node-js",
                "markdown": "Node.js와 어울리는 많은 에디터들이 있지만 … 무료, 멀티플랫폼(Mac, Linux, Windows), 마이크로소프트가 만든 <a href=\"https://code.visualstudio.com/\">Visual Studio Code</a>를 사용하지 않을 이유는 없다. 물론 Visual Studio 수준의 IDE를 생각하면 안된다. 에티터와 IDE 사이에서 좀 더 에디터에 가까운 툴이니까!\n\nNode.js 개발에 도움을 받을 수 있는 Visual Studio Code (이하 VSC)의 3가지 기능을 집고 가보자.\n<h2>1. 내장 터미널 (Integrated Terminal)</h2>\n<img class=\"alignnone size-large wp-image-71\" src=\"http://ilseokoh.com/content/images/2016/09/node_vsc_01-1024x700.png\" alt=\"node_vsc_01\" width=\"1024\" height=\"700\" />\n\n단축키는 ctrl + ` (키보드 왼쪽위에 있는 어퍼스트로피)를 누르면 내장 터미널이 나타난다. 별도 터미널을 써도 되지만 npm 설치나 node app.js 등의 명령을 VSC를 벗어나지 않고 내릴 수 있다.\n<h2>2. Debug + Break Point</h2>\nVSC에서 Break Point를 걸어서 디버깅을 할 수 있다. 특히 10년도 넘게 Visual Studio를 사용해온 사람이라면 Break Point를 찍고 싶을 것이다. 그러려면 먼저 프로젝트 폴더에 launch.json이 필요하다. 위 그림에서 왼쪽 세로 탭에 벌레금지 아이콘을 누르고 위쪽 설정 아이콘에 빨간 점이 보일 것이다. 클릭을 하고 Select Environment에서 Node.js를 선택하면 launch.json가 .vscode 폴더 밑에 생긴다. 디버그 할 때 실행 환경의 정의하는 파일이다.\n\n이제 F5로 실행하고 F9로 BreakPoint를 찍고 디버깅을 할 수 있다.\n\n<img class=\"alignnone size-large wp-image-91\" src=\"http://ilseokoh.com/content/images/2016/09/node_vsc_03-1024x700.png\" alt=\"node_vsc_03\" width=\"1024\" height=\"700\" />\n<h2>3. 인텔리센스(Intellisense)</h2>\n아래 3단계가 필요하다.\n\n1) js파일을 열면 오른쪽 제일 아래 전구 아이콘이 보일 것이다. (첫번째 이미지 참조, 스마일 아이콘 옆) 이걸 누르면 jsconfig.json 파일을 만들 수 있는데 여기서 인텔리센스에 필요없는 폴더를 제외 시켜준다.\n\n2) npm으로 typings라는 모듈을 설치한다. -g 옵션으로 글로벌로 설치한다. VSC에서 javascript의 Intellisense는 type script의 도움을 받는다. 그 타입 스크립트를 만들어주는 툴이다.\n<pre class=\"prettyprint\">$ sudo npm install -g typings</pre>\n3) 내가 사용하는 모듈에 대해서 아래 명령을 터미널에서 실행한다. 알고있는 모듈이름에 dt~를 붙여서 글로벌로 설치한다. typings 폴더가 생기고 확장자가 ts인 타입스크립트 파일이 생긴다. 이제 Intellisense를 사용할 수 있다. 코딩하다가 단축키 Ctrl + space를 누르면 도움을 받을 수 있다.\n<pre class=\"prettyprint\">$ typings install dt~node –global –save\n$ typings install dt~express –global –save</pre>\n<p class=\"p1\"><img class=\"alignnone size-large wp-image-101\" src=\"http://ilseokoh.com/content/images/2016/09/node_vsc_04-1024x700.png\" alt=\"node_vsc_04\" width=\"1024\" height=\"700\" /></p>",
                "html": "Node.js와 어울리는 많은 에디터들이 있지만 … 무료, 멀티플랫폼(Mac, Linux, Windows), 마이크로소프트가 만든 <a href=\"https://code.visualstudio.com/\">Visual Studio Code</a>를 사용하지 않을 이유는 없다. 물론 Visual Studio 수준의 IDE를 생각하면 안된다. 에티터와 IDE 사이에서 좀 더 에디터에 가까운 툴이니까!<p>Node.js 개발에 도움을 받을 수 있는 Visual Studio Code (이하 VSC)의 3가지 기능을 집고 가보자.\n<h2>1. 내장 터미널 (Integrated Terminal)</h2>\n<img class=\"alignnone size-large wp-image-71\" src=\"http://ilseokoh.com/content/images/2016/09/node_vsc_01-1024x700.png\" alt=\"node_vsc_01\" width=\"1024\" height=\"700\" /><p>단축키는 ctrl + ` (키보드 왼쪽위에 있는 어퍼스트로피)를 누르면 내장 터미널이 나타난다. 별도 터미널을 써도 되지만 npm 설치나 node app.js 등의 명령을 VSC를 벗어나지 않고 내릴 수 있다.\n<h2>2. Debug + Break Point</h2>\nVSC에서 Break Point를 걸어서 디버깅을 할 수 있다. 특히 10년도 넘게 Visual Studio를 사용해온 사람이라면 Break Point를 찍고 싶을 것이다. 그러려면 먼저 프로젝트 폴더에 launch.json이 필요하다. 위 그림에서 왼쪽 세로 탭에 벌레금지 아이콘을 누르고 위쪽 설정 아이콘에 빨간 점이 보일 것이다. 클릭을 하고 Select Environment에서 Node.js를 선택하면 launch.json가 .vscode 폴더 밑에 생긴다. 디버그 할 때 실행 환경의 정의하는 파일이다.<p>이제 F5로 실행하고 F9로 BreakPoint를 찍고 디버깅을 할 수 있다.<p><img class=\"alignnone size-large wp-image-91\" src=\"http://ilseokoh.com/content/images/2016/09/node_vsc_03-1024x700.png\" alt=\"node_vsc_03\" width=\"1024\" height=\"700\" />\n<h2>3. 인텔리센스(Intellisense)</h2>\n아래 3단계가 필요하다.<p>1) js파일을 열면 오른쪽 제일 아래 전구 아이콘이 보일 것이다. (첫번째 이미지 참조, 스마일 아이콘 옆) 이걸 누르면 jsconfig.json 파일을 만들 수 있는데 여기서 인텔리센스에 필요없는 폴더를 제외 시켜준다.<p>2) npm으로 typings라는 모듈을 설치한다. -g 옵션으로 글로벌로 설치한다. VSC에서 javascript의 Intellisense는 type script의 도움을 받는다. 그 타입 스크립트를 만들어주는 툴이다.\n<pre class=\"prettyprint\">$ sudo npm install -g typings</pre>\n3) 내가 사용하는 모듈에 대해서 아래 명령을 터미널에서 실행한다. 알고있는 모듈이름에 dt~를 붙여서 글로벌로 설치한다. typings 폴더가 생기고 확장자가 ts인 타입스크립트 파일이 생긴다. 이제 Intellisense를 사용할 수 있다. 코딩하다가 단축키 Ctrl + space를 누르면 도움을 받을 수 있다.\n<pre class=\"prettyprint\">$ typings install dt~node –global –save\n$ typings install dt~express –global –save</pre>\n<p class=\"p1\"><img class=\"alignnone size-large wp-image-101\" src=\"http://ilseokoh.com/content/images/2016/09/node_vsc_04-1024x700.png\" alt=\"node_vsc_04\" width=\"1024\" height=\"700\" /></p>",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1475033555000,
                "created_by": 1,
                "updated_at": 1475033555000,
                "updated_by": 1,
                "published_at": 1475033555000,
                "published_by": 1
            },
            {
                "id": 2091,
                "title": "Azure App Services에서 로컬 파일 접근",
                "slug": "local-file-access-from-azure-app-services",
                "markdown": "Azure App Service는 웹/모바일/API 애플리케이션을 Azure에 구현하기에 최적인 PaaS 형태의 서비스이다. 윈도우가 설치된 가상컴퓨터와 비교하면 환경이 같으면서도 다른면이 있다. 그 중 한가지가 Web Root 말고 로컬 파일 즉, D:\\home\\abc.txt 같은 경로는 있는지 파일은 어떻게 올리는지가 금방 생각나지 않을 수 있다. 왜냐면 원격접속이나 SSH 접속이 없기 때문이다.\n\n하지만 분명히 D:\\home 디렉토리가 존재하고 파일을 넣고 뺄 수 있으며 그 파일을 웹 애플리케이션에서 읽어서 사용할 수 있다. 예를들어 Push Notification 구현에 사용할 인증서 파일 등을 로컬 경로에 저장하고 사용 가능하다.\n<h3>Advanced Tool(Kudu)로 파일 관리</h3>\nAzure Portal &gt; App Service(Web App) &gt; Advanced Tools &gt; Go 를 누르면 웹기반의 관리 도구에 접속된다.\n\n<img class=\"alignnone size-large wp-image-2171\" src=\"http://ilseokoh.com/content/images/2016/10/azure-app-service-kudu-1024x708.png\" alt=\"azure-app-service-kudu\" width=\"1008\" height=\"697\" />\n\nConsole 접근이나 파일 다운로드 폴더 생성, 새 파일 생성 등을 할 수 있다. 파일 업로드 기능은 보이지 않는다. 파일 업로드는 FTP 로 접속하면 된다.\n\n<img class=\"alignnone size-large wp-image-2111\" src=\"http://ilseokoh.com/content/images/2016/10/azure-app-service-kudu-2-1024x708.png\" alt=\"azure-app-service-kudu-2\" width=\"1008\" height=\"697\" />\n<h3>FTP 접속으로 파일 업로드</h3>\nAzure App Services에 FTP 접속이 가능하다. 아이디와 주소는 아래 그림처럼 Overview에 나와있다. 아이디의 형태에 주의. 접속 비밀번호는 Deployment Credentials 에서 설정 및 변경이 가능하다.\n\n<img class=\"alignnone size-large wp-image-2181\" src=\"http://ilseokoh.com/content/images/2016/10/azure-app-ftp-1024x708.png\" alt=\"azure-app-ftp\" width=\"1008\" height=\"697\" />\n\nFileZilla 등의 FTP 클라이언트로 접속해서 파일을 올릴 수 있다.\n\n로컬 파일에 접근해서 내용을 읽어오는 코드를 C#, ASP .NET MVC로 두줄만 작성해서 테스트 해보았다. D:\\home 경로에서 파일을 읽어 웹페이지에 표시할 수 있었다. 웹 애플리케이션에서 로컬 파일 접근이 가능하다.\n\n<img class=\"alignnone size-large wp-image-2131\" src=\"http://ilseokoh.com/content/images/2016/10/azure-app-ftp-filezilla-1024x752.png\" alt=\"azure-app-ftp-filezilla\" width=\"1008\" height=\"740\" />\n<pre class=\"prettyprint\">public ActionResult About()\n{\n    string text = System.IO.File.ReadAllText(@\"D:\\home\\FileOnWebApp.txt\");\n    return Content(text);\n}</pre>",
                "html": "Azure App Service는 웹/모바일/API 애플리케이션을 Azure에 구현하기에 최적인 PaaS 형태의 서비스이다. 윈도우가 설치된 가상컴퓨터와 비교하면 환경이 같으면서도 다른면이 있다. 그 중 한가지가 Web Root 말고 로컬 파일 즉, D:\\home\\abc.txt 같은 경로는 있는지 파일은 어떻게 올리는지가 금방 생각나지 않을 수 있다. 왜냐면 원격접속이나 SSH 접속이 없기 때문이다.<p>하지만 분명히 D:\\home 디렉토리가 존재하고 파일을 넣고 뺄 수 있으며 그 파일을 웹 애플리케이션에서 읽어서 사용할 수 있다. 예를들어 Push Notification 구현에 사용할 인증서 파일 등을 로컬 경로에 저장하고 사용 가능하다.\n<h3>Advanced Tool(Kudu)로 파일 관리</h3>\nAzure Portal &gt; App Service(Web App) &gt; Advanced Tools &gt; Go 를 누르면 웹기반의 관리 도구에 접속된다.<p><img class=\"alignnone size-large wp-image-2171\" src=\"http://ilseokoh.com/content/images/2016/10/azure-app-service-kudu-1024x708.png\" alt=\"azure-app-service-kudu\" width=\"1008\" height=\"697\" /><p>Console 접근이나 파일 다운로드 폴더 생성, 새 파일 생성 등을 할 수 있다. 파일 업로드 기능은 보이지 않는다. 파일 업로드는 FTP 로 접속하면 된다.<p><img class=\"alignnone size-large wp-image-2111\" src=\"http://ilseokoh.com/content/images/2016/10/azure-app-service-kudu-2-1024x708.png\" alt=\"azure-app-service-kudu-2\" width=\"1008\" height=\"697\" />\n<h3>FTP 접속으로 파일 업로드</h3>\nAzure App Services에 FTP 접속이 가능하다. 아이디와 주소는 아래 그림처럼 Overview에 나와있다. 아이디의 형태에 주의. 접속 비밀번호는 Deployment Credentials 에서 설정 및 변경이 가능하다.<p><img class=\"alignnone size-large wp-image-2181\" src=\"http://ilseokoh.com/content/images/2016/10/azure-app-ftp-1024x708.png\" alt=\"azure-app-ftp\" width=\"1008\" height=\"697\" /><p>FileZilla 등의 FTP 클라이언트로 접속해서 파일을 올릴 수 있다.<p>로컬 파일에 접근해서 내용을 읽어오는 코드를 C#, ASP .NET MVC로 두줄만 작성해서 테스트 해보았다. D:\\home 경로에서 파일을 읽어 웹페이지에 표시할 수 있었다. 웹 애플리케이션에서 로컬 파일 접근이 가능하다.<p><img class=\"alignnone size-large wp-image-2131\" src=\"http://ilseokoh.com/content/images/2016/10/azure-app-ftp-filezilla-1024x752.png\" alt=\"azure-app-ftp-filezilla\" width=\"1008\" height=\"740\" />\n<pre class=\"prettyprint\">public ActionResult About()\n{\n    string text = System.IO.File.ReadAllText(@\"D:\\home\\FileOnWebApp.txt\");\n    return Content(text);\n}</pre>",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1475279515000,
                "created_by": 1,
                "updated_at": 1475279515000,
                "updated_by": 1,
                "published_at": 1475279515000,
                "published_by": 1
            },
            {
                "id": 2251,
                "title": "Azure Storage Account 로그 보기",
                "slug": "azure-storage-account-%eb%a1%9c%ea%b7%b8-%eb%b3%b4%ea%b8%b0",
                "markdown": "Azure Storage Account의 Blob은 파일을 저장하는 용도 외에도 HTTP 또는 HTTPS로 컨텐츠를 전달해주는 역할을 한다. 이 경우 Static File에 대한 웹서버의 역할이 되는데 접속 로그를 보고 싶은 경우가 생긴다. Blob에서 HTTP를 통해서 밖으로 나가는 트래픽은 비용을 발생시키기 때문에 평소 보다 많은 트래픽이 스토리지를 통해 발생 했다면 내용을 봐야 한다.\n\nAzure Storage Account를 만들면 아래 그림과 같이 기본 설정으로 몇몇 매트릭이 선택되어 있다.\n\n<img class=\"aligncenter size-full wp-image-12065\" src=\"https://msdnshared.blob.core.windows.net/media/2016/10/storage-diagnostics-config.jpg\" alt=\"storage diagnostics config\" width=\"607\" height=\"730\" />\n\n이 설정으로 인해 Storage Account에는 몇개의 Table이 생긴다. <a href=\"http://storageexplorer.com/\">Microsoft Azure Storage Explorer</a>를 사용하여 열어보면 $MetricsHourPrimaryTransactionsBlob 등의 테이블이 보인다. 이 테이블을 열어보면 내용을 시간을 기준으로 조회할 수 있다. 그리고 시스템요청인지 사용자 요청인지? 과금이 되는 요청인지? 등의 정보를 볼 수 있다.\n\n<img class=\"aligncenter size-large wp-image-12075\" src=\"https://msdnshared.blob.core.windows.net/media/2016/10/storage-account-log-1024x552.jpg\" alt=\"storage account log\" width=\"1024\" height=\"552\" />\n\n이 내용이 불충분하고 더 자세한 Request/Response 내용을 보고 싶다면 Diagnostics 설정에서 Blob logs 를 켜놔야 한다. 그럼 Blob에 $log 라는 컨테이너가 생기고 그 안에 Request 별로 로그가 파일로 생성된다. 이 로그를 모아서 분석하면 어떤 일이 벌어졌는지 알 수 있다.\n\nRequest 하나의 로그 샘플은 아래와 같다. 세미콜론을 Delimiter 로 엑셀에 Import 보면 내용을 잘 볼 수 있다.\n<pre class=\"prettyprint\">1.0;2016-10-01T03:43:22.8197212Z;GetBlob;AnonymousSuccess;200;1707;141;anonymous;;zstorage;blob;\"https://zstorage.blob.core.windows.net:443/contents/EC1ADD6DFF19AC26EEA4C3641038471C486A4637.mp3\";\"/zstorage/contents/EC1ADD6DFF19AC26EEA4C3641038471C486A4637.mp3\";44fc2485-0001-003d-3e95-1b2132000000;0;167.220.232.21:16581;2009-09-19;355;0;316;4721873;0;;;\"0x8D3E5A752CFE3B2\";Monday, 26-Sep-16 00:52:00 GMT;;\"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)\";;</pre>\n&nbsp;",
                "html": "Azure Storage Account의 Blob은 파일을 저장하는 용도 외에도 HTTP 또는 HTTPS로 컨텐츠를 전달해주는 역할을 한다. 이 경우 Static File에 대한 웹서버의 역할이 되는데 접속 로그를 보고 싶은 경우가 생긴다. Blob에서 HTTP를 통해서 밖으로 나가는 트래픽은 비용을 발생시키기 때문에 평소 보다 많은 트래픽이 스토리지를 통해 발생 했다면 내용을 봐야 한다.<p>Azure Storage Account를 만들면 아래 그림과 같이 기본 설정으로 몇몇 매트릭이 선택되어 있다.<p><img class=\"aligncenter size-full wp-image-12065\" src=\"https://msdnshared.blob.core.windows.net/media/2016/10/storage-diagnostics-config.jpg\" alt=\"storage diagnostics config\" width=\"607\" height=\"730\" /><p>이 설정으로 인해 Storage Account에는 몇개의 Table이 생긴다. <a href=\"http://storageexplorer.com/\">Microsoft Azure Storage Explorer</a>를 사용하여 열어보면 $MetricsHourPrimaryTransactionsBlob 등의 테이블이 보인다. 이 테이블을 열어보면 내용을 시간을 기준으로 조회할 수 있다. 그리고 시스템요청인지 사용자 요청인지? 과금이 되는 요청인지? 등의 정보를 볼 수 있다.<p><img class=\"aligncenter size-large wp-image-12075\" src=\"https://msdnshared.blob.core.windows.net/media/2016/10/storage-account-log-1024x552.jpg\" alt=\"storage account log\" width=\"1024\" height=\"552\" /><p>이 내용이 불충분하고 더 자세한 Request/Response 내용을 보고 싶다면 Diagnostics 설정에서 Blob logs 를 켜놔야 한다. 그럼 Blob에 $log 라는 컨테이너가 생기고 그 안에 Request 별로 로그가 파일로 생성된다. 이 로그를 모아서 분석하면 어떤 일이 벌어졌는지 알 수 있다.<p>Request 하나의 로그 샘플은 아래와 같다. 세미콜론을 Delimiter 로 엑셀에 Import 보면 내용을 잘 볼 수 있다.\n<pre class=\"prettyprint\">1.0;2016-10-01T03:43:22.8197212Z;GetBlob;AnonymousSuccess;200;1707;141;anonymous;;zstorage;blob;\"https://zstorage.blob.core.windows.net:443/contents/EC1ADD6DFF19AC26EEA4C3641038471C486A4637.mp3\";\"/zstorage/contents/EC1ADD6DFF19AC26EEA4C3641038471C486A4637.mp3\";44fc2485-0001-003d-3e95-1b2132000000;0;167.220.232.21:16581;2009-09-19;355;0;316;4721873;0;;;\"0x8D3E5A752CFE3B2\";Monday, 26-Sep-16 00:52:00 GMT;;\"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)\";;</pre>\n&nbsp;",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1475294794000,
                "created_by": 1,
                "updated_at": 1475294794000,
                "updated_by": 1,
                "published_at": 1475294794000,
                "published_by": 1
            },
            {
                "id": 2291,
                "title": "Xamarin.Android 에뮬레이터 실행오류",
                "slug": "xamarin-android-%ec%97%90%eb%ae%ac%eb%a0%88%ec%9d%b4%ed%84%b0-%ec%8b%a4%ed%96%89%ec%98%a4%eb%a5%98",
                "markdown": "Xamarin으로 Android 개발을 할 때 Visual Studio와 더불어 Microsoft Android Emulator를 사용하는데 Visual Studio 에서 F5를 눌러서 실행을 하면 에뮬레이터에 배포까지는 되는데 실행을 하자마자 죽는 경우가 있다. Break Point를 잡아서 원인을 찾으려 해보지만 Break Point도 잡히지 않는다. 시작하자마자 좌절을 경험하는데 이런 오류 메시지를 Output 창에서 볼 수 있다.\n<pre class=\"prettyprint\">10-19 17:28:53.785 D/Mono    ( 2682): Image addref mscorlib[0xaa722660] -&gt; mscorlib.dll[0xac0aba00]: 1\n10-19 17:28:53.785 D/Mono    ( 2682): <span style=\"color: #800000;\">AOT module 'mscorlib.dll.so' not found: dlopen failed</span>: library \"/data/app/DevTest.Droid-1/lib/x86/libaot-mscorlib.dll.so\" not found</pre>\n이런 경우 아래 처럼 에뮬레이터 설정을 변경하면 해결 될 수 있다.\n<ol>\n \t<li>먼저 에뮬레이터가 실행되어 있으면 닫는다.</li>\n \t<li>Hyper-V Manger 라는 애플리케이션을 찾아서 실행한다.</li>\n \t<li>오류가 발생한 Emulator를 찾아서 Settings를 누른다.[caption id=\"attachment_2301\" align=\"alignnone\" width=\"1008\"]<img class=\"size-large wp-image-2301\" src=\"http://ilseokoh.com/content/images/2016/10/HyperVManager-1024x582.png\" alt=\"Hyper V manager\" width=\"1008\" height=\"573\" /></li>\n \t<li>Processor &gt; Compatibility 를 선택하고 \"Migrate to a physical computer with a different Processor Version\" 을 체크해준다. <img class=\"alignnone size-large wp-image-2311\" src=\"http://ilseokoh.com/content/images/2016/10/HyperVProcessorCompat-1024x975.png\" alt=\"Processor Compat\" width=\"1008\" height=\"960\" /></li>\n \t<li>Visual Studio에서 다시 실행한다.</li>\n</ol>\nHappy coding with VS!",
                "html": "Xamarin으로 Android 개발을 할 때 Visual Studio와 더불어 Microsoft Android Emulator를 사용하는데 Visual Studio 에서 F5를 눌러서 실행을 하면 에뮬레이터에 배포까지는 되는데 실행을 하자마자 죽는 경우가 있다. Break Point를 잡아서 원인을 찾으려 해보지만 Break Point도 잡히지 않는다. 시작하자마자 좌절을 경험하는데 이런 오류 메시지를 Output 창에서 볼 수 있다.\n<pre class=\"prettyprint\">10-19 17:28:53.785 D/Mono    ( 2682): Image addref mscorlib[0xaa722660] -&gt; mscorlib.dll[0xac0aba00]: 1\n10-19 17:28:53.785 D/Mono    ( 2682): <span style=\"color: #800000;\">AOT module 'mscorlib.dll.so' not found: dlopen failed</span>: library \"/data/app/DevTest.Droid-1/lib/x86/libaot-mscorlib.dll.so\" not found</pre>\n이런 경우 아래 처럼 에뮬레이터 설정을 변경하면 해결 될 수 있다.\n<ol>\n \t<li>먼저 에뮬레이터가 실행되어 있으면 닫는다.</li>\n \t<li>Hyper-V Manger 라는 애플리케이션을 찾아서 실행한다.</li>\n \t<li>오류가 발생한 Emulator를 찾아서 Settings를 누른다.[caption id=\"attachment_2301\" align=\"alignnone\" width=\"1008\"]<img class=\"size-large wp-image-2301\" src=\"http://ilseokoh.com/content/images/2016/10/HyperVManager-1024x582.png\" alt=\"Hyper V manager\" width=\"1008\" height=\"573\" /></li>\n \t<li>Processor &gt; Compatibility 를 선택하고 \"Migrate to a physical computer with a different Processor Version\" 을 체크해준다. <img class=\"alignnone size-large wp-image-2311\" src=\"http://ilseokoh.com/content/images/2016/10/HyperVProcessorCompat-1024x975.png\" alt=\"Processor Compat\" width=\"1008\" height=\"960\" /></li>\n \t<li>Visual Studio에서 다시 실행한다.</li>\n</ol>\nHappy coding with VS!",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1476866006000,
                "created_by": 1,
                "updated_at": 1476866006000,
                "updated_by": 1,
                "published_at": 1476866006000,
                "published_by": 1
            },
            {
                "id": 2421,
                "title": "Azure CDN 완전정복 1 - 만들기",
                "slug": "azure-cdn-%ec%99%84%ec%a0%84%ec%a0%95%eb%b3%b5-1-%eb%a7%8c%eb%93%a4%ea%b8%b0",
                "markdown": "<h2>CDN 개요</h2>\n웹 애플리케이션 개발의 마지막에는 사이트의 성능을 올리기 위한 최적화를 하곤 한다. 물론 운영할 때도 지속적으로 신경써야 하는 부분이다. 여러가지 최적화/튜닝 방법중 <a href=\"https://ko.wikipedia.org/wiki/%EC%BD%98%ED%85%90%EC%B8%A0_%EC%A0%84%EC%86%A1_%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC\">CDN(Content Delivery Network)</a>을 이용하면 정적인 컨텐츠의 다운로드 속도를 크게 개선할 수 있다. 사이트 홈에 사용된 큰 이미지, 동영상, 문서나 프로그램 다운로드, 상품 이미지 등 크기가 큰 컨텐츠 일부를 CDN을 적용하거나 음악, 동영상 같이 컨텐츠를 빠르게 전송하는게 핵심인 서비스에 적용하면 그야말로 드라마틱한 속도 향상을 경험 할 수 있다. 게임의 경우 Patch 파일 다운로드에 CDN을 많이 사용한다.\n\nCDN의 원리는 어쩌면 단순한데 전세계의 네트워크 곳곳에 엣지(Edge) 서버를 두고 원본 컨텐츠를 Edge 서버에 캐싱을 해주는 것이다. 그러면 사용자는 멀리 있는 원본 서버가 아닌 가장 가까운 Edge 서버에서 컨텐츠를 가져오기 때문에 빠른 것이다. <a href=\"https://docs.microsoft.com/en-us/azure/cdn/cdn-pop-locations\">Azure의 엣지 서버 위치는 여기에서 확인</a> 가능하다.\n\n속도 뿐만 아니라 별도의 엣지서버에 캐싱을 하기 때문에 부하를 분산할 수 있고 DDoS 공격으로 부터 보호를 해줄 수 있다. 또한 특정 지역에서는 컨텐츠를 받을 수 없도록 하는 '지역 필터링' 기능도 제공한다.\n<h2>Azure CDN 만들기</h2>\nAzure CDN은 그리 어렵지 않게 설정해서 사용할 수 있다. Azure의 CDN은 글로벌 서비스인 Akamai와 Verizon CDN을 선택할 수 있다. <a href=\"https://docs.microsoft.com/ko-kr/azure/cdn/cdn-create-new-endpoint#a-namecreate-a-new-cdn-profilea새-cdn-프로필-만들기\">새로운 CDN 프로필을 만들고</a> <a href=\"https://docs.microsoft.com/ko-kr/azure/cdn/cdn-create-new-endpoint#a-namecreate-a-new-cdn-endpointa새-cdn-끝점-만들기\">끝점을 설정</a>하면 우선 기본 설정은 끝이다.\n<h2>Verizon vs Akamai</h2>\nAzure CDN을 만들때 가격옵션에서 3가지를 선택할 수 있다. 두배나 비싼 P1을 제외하면 Verizon과 Akamai 둘 중 하나를 선택할 수 있다. 기능상의 차이가 있다면 바로 \"Core analytics\"이다. 즉 모니터링 툴을 얘기하는데 Akamai는 제공하지 않는다. 사실 CDN 서비스는 상당히 안정적인 서비스이기 때문에 모니터링이 필요 없을 수도 있다. 예를들어 어떤 웹 애플리케이션의 일부 리소스를 CDN을 통해서 전송하는 경우에는 필요 없을 수도 있다. 하지만 <span style=\"text-decoration: underline;\">음악 서비스 같이 CDN 이 중요한 서비스인 경우 모니터링이 꼭 필요한데 이경우는 Verizon을 선택</span>하는 것이 좋다. CDN 모니터링에 대한 상세한 내용은 <a href=\"http://ilseokoh.com/2016/11/24/azure-cdn-%EC%99%84%EC%A0%84%EC%A0%95%EB%B3%B4-3-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81/\">이 시리즈의 3편인 모니터링 포스트</a>에서 확인 가능하다.\n\n<img class=\"alignnone size-full wp-image-2611\" src=\"/content/images/2016/11/cde_price.png\" alt=\"cde_price\" width=\"958\" height=\"692\" />\n<h2>끝점(End Point) 설정</h2>\n원본은 Azure의 서비스인 Storage, Cloud Service, Web App를 바로 연결 할 수 있고 Azure 이외의 서비스도 연결 가능하다.\n\n보통 많이 사용하는 방법은 Storage Account의 Blob에 컨텐츠를 넣어놓고 Storage를 CDN에 연결하는 방법이다. Azure Storage Account는 만들면 HTTP/HTTPS 도메인 주소를 하나 주기 때문에 그 주소를 원본 주소로 하면 된다.\n\n<img class=\"alignnone size-full wp-image-2481\" src=\"/content/images/2016/11/azure_cdn_endpoint.png\" alt=\"azure_cdn_endpoint\" width=\"975\" height=\"758\" />\n\n만약 Azure 가상머신(VM)에 웹서버가 돌고 있고 컨텐츠가 웹으로 서비스 되고 있다면 Custom Origin을 선택하고 VM의 도메인 주소를 넣어주면 된다. (Azure VM의 도메인 주소는 IP 주소라는 리소스에서 설정 가능하며 abc.eastasia.cloudapp.azure.com 같은 주소를 얻을 수 있다.)\n\nAzure의 서비스가 아니라도 외부에 있는 HTTP/HTTPS 주소가 있고 그 주소로 컨텐츠가 서비스 되고 있다면 역시 Custom Origin을 선택하고 그 주소를 넣어 준다.\n\nOrigin Path 를 넣어주면 http://abc.eastasia.cloudapp.azure.com/path 주소가 http://vmcdn.azureedge.net 으로 매핑이 된다.\n<h2>CDN 테스트</h2>\n끝점까지 만들면 기본 설정은 모두 끝났다. 테스트는 웹브라우저로 CDN 주소로 컨텐츠를 접속해보면 된다. <span style=\"text-decoration: underline;\">주의할 것은 CDN 주소가 즉시 활성화 되지 않는 다는 것</span>. Akamai를 선택했다면 1-2분 이내에 활성화 되고 Verizon을 선택했다면 최대 90분이 걸릴 수 있다. 전세계 엣지 서버로 캐싱되는 시간이니 느긋하게 기다려야 한다.\n\n만약 Azure Storage Blob을 원본으로 설정 했다면 브라우저나 기타 다운로드 툴을 이용해서 테스트를 해본다. <span style=\"text-decoration: underline;\">브라우저로 테스트 한다면 브라우저 캐시를 지우면서 테스트</span>를 해야 한다. 또한 음악이나 동영상 파일의 경우  mime-type이 올바로 설정되어 있다면 브라우저 개발자 도구로 속도를 측정하기는 어렵다. 요즘 브라우저가 너무 똑똑해졌는지 음악을 플레이 하면서 다운로드를 하고 음악의 재생 시간에 따라서 조금씩 다운로드를 하기 때문에 전체 다운로드 시간을 정확히 측정하기 어렵다.\n\n신뢰성이 검증된 툴은 아니지만 DownloadTester라는 툴을 다운받아서 측정해봤다. 캡쳐 이미지에서 윗줄은 원본으로 지역은 East Asia(Hong Kong)에 있는 Blob Storage에 있는 음악 파일이고 아래 줄은 CDN 주소이다. 원본은 약 4.87Mbps, CDN 주소는 10.70Mbps 로 약 2배정도 CDN 속도가 빠르다.\n\n<img class=\"alignnone size-large wp-image-2751\" src=\"http://ilseokoh.com/content/images/2016/11/cdn_test-1024x213.png\" alt=\"cdn_test\" width=\"1008\" height=\"210\" />",
                "html": "<h2>CDN 개요</h2>\n웹 애플리케이션 개발의 마지막에는 사이트의 성능을 올리기 위한 최적화를 하곤 한다. 물론 운영할 때도 지속적으로 신경써야 하는 부분이다. 여러가지 최적화/튜닝 방법중 <a href=\"https://ko.wikipedia.org/wiki/%EC%BD%98%ED%85%90%EC%B8%A0_%EC%A0%84%EC%86%A1_%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC\">CDN(Content Delivery Network)</a>을 이용하면 정적인 컨텐츠의 다운로드 속도를 크게 개선할 수 있다. 사이트 홈에 사용된 큰 이미지, 동영상, 문서나 프로그램 다운로드, 상품 이미지 등 크기가 큰 컨텐츠 일부를 CDN을 적용하거나 음악, 동영상 같이 컨텐츠를 빠르게 전송하는게 핵심인 서비스에 적용하면 그야말로 드라마틱한 속도 향상을 경험 할 수 있다. 게임의 경우 Patch 파일 다운로드에 CDN을 많이 사용한다.<p>CDN의 원리는 어쩌면 단순한데 전세계의 네트워크 곳곳에 엣지(Edge) 서버를 두고 원본 컨텐츠를 Edge 서버에 캐싱을 해주는 것이다. 그러면 사용자는 멀리 있는 원본 서버가 아닌 가장 가까운 Edge 서버에서 컨텐츠를 가져오기 때문에 빠른 것이다. <a href=\"https://docs.microsoft.com/en-us/azure/cdn/cdn-pop-locations\">Azure의 엣지 서버 위치는 여기에서 확인</a> 가능하다.<p>속도 뿐만 아니라 별도의 엣지서버에 캐싱을 하기 때문에 부하를 분산할 수 있고 DDoS 공격으로 부터 보호를 해줄 수 있다. 또한 특정 지역에서는 컨텐츠를 받을 수 없도록 하는 '지역 필터링' 기능도 제공한다.\n<h2>Azure CDN 만들기</h2>\nAzure CDN은 그리 어렵지 않게 설정해서 사용할 수 있다. Azure의 CDN은 글로벌 서비스인 Akamai와 Verizon CDN을 선택할 수 있다. <a href=\"https://docs.microsoft.com/ko-kr/azure/cdn/cdn-create-new-endpoint#a-namecreate-a-new-cdn-profilea새-cdn-프로필-만들기\">새로운 CDN 프로필을 만들고</a> <a href=\"https://docs.microsoft.com/ko-kr/azure/cdn/cdn-create-new-endpoint#a-namecreate-a-new-cdn-endpointa새-cdn-끝점-만들기\">끝점을 설정</a>하면 우선 기본 설정은 끝이다.\n<h2>Verizon vs Akamai</h2>\nAzure CDN을 만들때 가격옵션에서 3가지를 선택할 수 있다. 두배나 비싼 P1을 제외하면 Verizon과 Akamai 둘 중 하나를 선택할 수 있다. 기능상의 차이가 있다면 바로 \"Core analytics\"이다. 즉 모니터링 툴을 얘기하는데 Akamai는 제공하지 않는다. 사실 CDN 서비스는 상당히 안정적인 서비스이기 때문에 모니터링이 필요 없을 수도 있다. 예를들어 어떤 웹 애플리케이션의 일부 리소스를 CDN을 통해서 전송하는 경우에는 필요 없을 수도 있다. 하지만 <span style=\"text-decoration: underline;\">음악 서비스 같이 CDN 이 중요한 서비스인 경우 모니터링이 꼭 필요한데 이경우는 Verizon을 선택</span>하는 것이 좋다. CDN 모니터링에 대한 상세한 내용은 <a href=\"http://ilseokoh.com/2016/11/24/azure-cdn-%EC%99%84%EC%A0%84%EC%A0%95%EB%B3%B4-3-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81/\">이 시리즈의 3편인 모니터링 포스트</a>에서 확인 가능하다.<p><img class=\"alignnone size-full wp-image-2611\" src=\"/content/images/2016/11/cde_price.png\" alt=\"cde_price\" width=\"958\" height=\"692\" />\n<h2>끝점(End Point) 설정</h2>\n원본은 Azure의 서비스인 Storage, Cloud Service, Web App를 바로 연결 할 수 있고 Azure 이외의 서비스도 연결 가능하다.<p>보통 많이 사용하는 방법은 Storage Account의 Blob에 컨텐츠를 넣어놓고 Storage를 CDN에 연결하는 방법이다. Azure Storage Account는 만들면 HTTP/HTTPS 도메인 주소를 하나 주기 때문에 그 주소를 원본 주소로 하면 된다.<p><img class=\"alignnone size-full wp-image-2481\" src=\"/content/images/2016/11/azure_cdn_endpoint.png\" alt=\"azure_cdn_endpoint\" width=\"975\" height=\"758\" /><p>만약 Azure 가상머신(VM)에 웹서버가 돌고 있고 컨텐츠가 웹으로 서비스 되고 있다면 Custom Origin을 선택하고 VM의 도메인 주소를 넣어주면 된다. (Azure VM의 도메인 주소는 IP 주소라는 리소스에서 설정 가능하며 abc.eastasia.cloudapp.azure.com 같은 주소를 얻을 수 있다.)<p>Azure의 서비스가 아니라도 외부에 있는 HTTP/HTTPS 주소가 있고 그 주소로 컨텐츠가 서비스 되고 있다면 역시 Custom Origin을 선택하고 그 주소를 넣어 준다.<p>Origin Path 를 넣어주면 http://abc.eastasia.cloudapp.azure.com/path 주소가 http://vmcdn.azureedge.net 으로 매핑이 된다.\n<h2>CDN 테스트</h2>\n끝점까지 만들면 기본 설정은 모두 끝났다. 테스트는 웹브라우저로 CDN 주소로 컨텐츠를 접속해보면 된다. <span style=\"text-decoration: underline;\">주의할 것은 CDN 주소가 즉시 활성화 되지 않는 다는 것</span>. Akamai를 선택했다면 1-2분 이내에 활성화 되고 Verizon을 선택했다면 최대 90분이 걸릴 수 있다. 전세계 엣지 서버로 캐싱되는 시간이니 느긋하게 기다려야 한다.<p>만약 Azure Storage Blob을 원본으로 설정 했다면 브라우저나 기타 다운로드 툴을 이용해서 테스트를 해본다. <span style=\"text-decoration: underline;\">브라우저로 테스트 한다면 브라우저 캐시를 지우면서 테스트</span>를 해야 한다. 또한 음악이나 동영상 파일의 경우  mime-type이 올바로 설정되어 있다면 브라우저 개발자 도구로 속도를 측정하기는 어렵다. 요즘 브라우저가 너무 똑똑해졌는지 음악을 플레이 하면서 다운로드를 하고 음악의 재생 시간에 따라서 조금씩 다운로드를 하기 때문에 전체 다운로드 시간을 정확히 측정하기 어렵다.<p>신뢰성이 검증된 툴은 아니지만 DownloadTester라는 툴을 다운받아서 측정해봤다. 캡쳐 이미지에서 윗줄은 원본으로 지역은 East Asia(Hong Kong)에 있는 Blob Storage에 있는 음악 파일이고 아래 줄은 CDN 주소이다. 원본은 약 4.87Mbps, CDN 주소는 10.70Mbps 로 약 2배정도 CDN 속도가 빠르다.<p><img class=\"alignnone size-large wp-image-2751\" src=\"http://ilseokoh.com/content/images/2016/11/cdn_test-1024x213.png\" alt=\"cdn_test\" width=\"1008\" height=\"210\" />",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1479891543000,
                "created_by": 1,
                "updated_at": 1479891543000,
                "updated_by": 1,
                "published_at": 1479891543000,
                "published_by": 1
            },
            {
                "id": 2561,
                "title": "Azure CDN 완전정복 2 - Purge",
                "slug": "azure-cdn-%ec%99%84%ec%a0%84%ec%a0%95%eb%b3%b5-2-purge",
                "markdown": "Purge를 그냥 번역하면 '삭제' 정도가 되겠지만 정확히는 CDN 캐시에 있는 컨텐츠를 삭제 또는 무효화 하는 것이기 때문에 '무효화'정도가 올바른 번역이라고 생각한다. 이 글에서는 Purge라는 영어 단어 그대로 사용한다.\n\n캐시의 특징은 원본이 변경되면 자동으로 즉시 캐시도 변경되지 않는 다는 것이다. 그래서 원본 컨텐츠를 수정해서 업데이트를 해도 한 동안(캐시가 expired 되기 전까지)은 CDN 주소로 접속하면 업데이트 된 컨텐츠를 받을 수 없다. 따라서 원본의 업데이트를 즉시 반영시키려면 CDN 캐시를 무효화 시켜서 원본에서 다시 가져오도록 조치해야 한다. 이 과정을 Purge라고 한다.\n\n여기서는 3가지 Purge 방법을 제시한다. 이중에서 두번째 방법인 Query string을 이용하는 방법이 쉽고 자주 쓰이는 방법이다.\n<h2>1. Azure Portal을 이용한 Purge</h2>\nAzure Portal에서 전체 CDN 캐시를 Purge 할 수도 있고 수동으로 지정된 컨텐츠를 Purge 할 수 있다. 자세한 내용은 \"<a href=\"https://docs.microsoft.com/ko-kr/azure/cdn/cdn-purge-endpoint\">Azure CDN 끝점 제거</a>\" 문서를 참고 바란다. 이 방법은 Verizon CDN의 경우 2-3분, Akamai CDN의 경우 7분정도 소요된다.\n\n어떤 경우에는 전체 CDN 캐시를 무효화 시킬 경우도 있다. 또는 CDN으로 서비스 되는 컨텐츠의 양이 적다면 전체 Purge가 크게 문제가 되지 않는다. 전체 Purge 하는 방법은 Azure Portal에 접속해서 CDN 프로파일을 연다. 그리고 아래 그림처럼 Purge(한글 번역은 \"삭제\")버튼을 누르면 된다.\n\nCDN으로 서비스 되는 컨텐츠가 많고 CDN이 중요한 위치를 차지하고 있다면 전체 CDN 캐시를 Purge하는건 좋은 선택이 아니다. 서비스 전체가 영향을 받기 때문이다.\n\n<img class=\"alignnone size-large wp-image-2961\" src=\"http://ilseokoh.com/content/images/2016/11/azure_portal_purge-1024x589.png\" alt=\"azure_portal_purge\" width=\"1008\" height=\"580\" />\n<h2>2. Query String으로 Purge 하기</h2>\nCDN 주소는 https://vmcdn.azureedge.net/mp3/abc.mp3 처럼 결국 HTTP URL이다. URL에는 Query String을 붙일 수 있다. https://vmcdn.azureedge.net/mp3/abc.mp3<span style=\"text-decoration: underline;\">?v=123</span> 처럼 의미 없는 ?v=123 을 붙이면 CDN이 두개의 URL을 전혀 다른 컨텐츠로 인식하도록 만들 수 있다.\n\n즉, 컨텐츠가 업데이트가 될 때 클라이언트가 요청하는 주소에 Query String을 붙여주는 것이다. 만약 URL이 Database에 저장되어 있다면 업데이트된 컨텐츠의 URL을 같이 업데이트 시켜준다. URL이 HTML에 들어가 있다면 HTML에서 사용한 컨텐츠의 URL에 Query string을 붙여 변경하고 다시 배포를 하면된다.\n\n이전버전의 캐시는 시간이 지나면 Expired 되어 자연스럽게 캐시에서 사라지고 CDN은 Query string이 있어도 원본컨텐츠는 같은 곳에서 다시 가져오므로 캐시도 업데이트가 되는 것이다. 컨텐츠를 새로 받아오는 것이므로 즉시 업데이트 된 컨텐츠로 반영된다.\n\n이 방법을 사용 하려면 Azure Portal에서 CDN 끝점 설정으로 들어가 Cache 메뉴를 열고 \"Query string caching behavior\" 값을 \"Cache every unique URL\"로 설정해야 한다.\n\n<img class=\"alignnone size-large wp-image-2981\" src=\"http://ilseokoh.com/content/images/2016/11/cache_config-1024x853.png\" alt=\"cache_config\" width=\"1008\" height=\"840\" />\n<h2>3. Azure REST API 로 Purge</h2>\nAzure는 REST API를 제공하여 Azure Portal에서 하는 작업을 모두 프로그래밍 방식으로 설정 및 제어 할 수 있다. Azure CDN의 Purge도 API를 이용하여 할 수 있다. <a href=\"https://docs.microsoft.com/ko-kr/rest/api/cdn/endpoints?redirectedfrom=MSDN#Endpoints_PurgeContent\">Azure REST API 문서의 Purge</a> 를 참고하여 프로그래밍을 통해 개별 컨텐츠를 Purge 할 수 있다. 그러려면 <a href=\"https://docs.microsoft.com/ko-kr/rest/api/index\">Azure REST API의 기본 사용법</a>을 스터디 해야한다. 이 글에서는 API가 있다는 정도의 설명만 하고 마친다.\n\n&nbsp;",
                "html": "Purge를 그냥 번역하면 '삭제' 정도가 되겠지만 정확히는 CDN 캐시에 있는 컨텐츠를 삭제 또는 무효화 하는 것이기 때문에 '무효화'정도가 올바른 번역이라고 생각한다. 이 글에서는 Purge라는 영어 단어 그대로 사용한다.<p>캐시의 특징은 원본이 변경되면 자동으로 즉시 캐시도 변경되지 않는 다는 것이다. 그래서 원본 컨텐츠를 수정해서 업데이트를 해도 한 동안(캐시가 expired 되기 전까지)은 CDN 주소로 접속하면 업데이트 된 컨텐츠를 받을 수 없다. 따라서 원본의 업데이트를 즉시 반영시키려면 CDN 캐시를 무효화 시켜서 원본에서 다시 가져오도록 조치해야 한다. 이 과정을 Purge라고 한다.<p>여기서는 3가지 Purge 방법을 제시한다. 이중에서 두번째 방법인 Query string을 이용하는 방법이 쉽고 자주 쓰이는 방법이다.\n<h2>1. Azure Portal을 이용한 Purge</h2>\nAzure Portal에서 전체 CDN 캐시를 Purge 할 수도 있고 수동으로 지정된 컨텐츠를 Purge 할 수 있다. 자세한 내용은 \"<a href=\"https://docs.microsoft.com/ko-kr/azure/cdn/cdn-purge-endpoint\">Azure CDN 끝점 제거</a>\" 문서를 참고 바란다. 이 방법은 Verizon CDN의 경우 2-3분, Akamai CDN의 경우 7분정도 소요된다.<p>어떤 경우에는 전체 CDN 캐시를 무효화 시킬 경우도 있다. 또는 CDN으로 서비스 되는 컨텐츠의 양이 적다면 전체 Purge가 크게 문제가 되지 않는다. 전체 Purge 하는 방법은 Azure Portal에 접속해서 CDN 프로파일을 연다. 그리고 아래 그림처럼 Purge(한글 번역은 \"삭제\")버튼을 누르면 된다.<p>CDN으로 서비스 되는 컨텐츠가 많고 CDN이 중요한 위치를 차지하고 있다면 전체 CDN 캐시를 Purge하는건 좋은 선택이 아니다. 서비스 전체가 영향을 받기 때문이다.<p><img class=\"alignnone size-large wp-image-2961\" src=\"http://ilseokoh.com/content/images/2016/11/azure_portal_purge-1024x589.png\" alt=\"azure_portal_purge\" width=\"1008\" height=\"580\" />\n<h2>2. Query String으로 Purge 하기</h2>\nCDN 주소는 https://vmcdn.azureedge.net/mp3/abc.mp3 처럼 결국 HTTP URL이다. URL에는 Query String을 붙일 수 있다. https://vmcdn.azureedge.net/mp3/abc.mp3<span style=\"text-decoration: underline;\">?v=123</span> 처럼 의미 없는 ?v=123 을 붙이면 CDN이 두개의 URL을 전혀 다른 컨텐츠로 인식하도록 만들 수 있다.<p>즉, 컨텐츠가 업데이트가 될 때 클라이언트가 요청하는 주소에 Query String을 붙여주는 것이다. 만약 URL이 Database에 저장되어 있다면 업데이트된 컨텐츠의 URL을 같이 업데이트 시켜준다. URL이 HTML에 들어가 있다면 HTML에서 사용한 컨텐츠의 URL에 Query string을 붙여 변경하고 다시 배포를 하면된다.<p>이전버전의 캐시는 시간이 지나면 Expired 되어 자연스럽게 캐시에서 사라지고 CDN은 Query string이 있어도 원본컨텐츠는 같은 곳에서 다시 가져오므로 캐시도 업데이트가 되는 것이다. 컨텐츠를 새로 받아오는 것이므로 즉시 업데이트 된 컨텐츠로 반영된다.<p>이 방법을 사용 하려면 Azure Portal에서 CDN 끝점 설정으로 들어가 Cache 메뉴를 열고 \"Query string caching behavior\" 값을 \"Cache every unique URL\"로 설정해야 한다.<p><img class=\"alignnone size-large wp-image-2981\" src=\"http://ilseokoh.com/content/images/2016/11/cache_config-1024x853.png\" alt=\"cache_config\" width=\"1008\" height=\"840\" />\n<h2>3. Azure REST API 로 Purge</h2>\nAzure는 REST API를 제공하여 Azure Portal에서 하는 작업을 모두 프로그래밍 방식으로 설정 및 제어 할 수 있다. Azure CDN의 Purge도 API를 이용하여 할 수 있다. <a href=\"https://docs.microsoft.com/ko-kr/rest/api/cdn/endpoints?redirectedfrom=MSDN#Endpoints_PurgeContent\">Azure REST API 문서의 Purge</a> 를 참고하여 프로그래밍을 통해 개별 컨텐츠를 Purge 할 수 있다. 그러려면 <a href=\"https://docs.microsoft.com/ko-kr/rest/api/index\">Azure REST API의 기본 사용법</a>을 스터디 해야한다. 이 글에서는 API가 있다는 정도의 설명만 하고 마친다.<p>&nbsp;",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1479985676000,
                "created_by": 1,
                "updated_at": 1479985676000,
                "updated_by": 1,
                "published_at": 1479985676000,
                "published_by": 1
            },
            {
                "id": 2591,
                "title": "Azure CDN 완전정복 3 - 모니터링",
                "slug": "azure-cdn-%ec%99%84%ec%a0%84%ec%a0%95%eb%b3%b5-3-%eb%aa%a8%eb%8b%88%ed%84%b0%eb%a7%81",
                "markdown": "아래 내용은 Azure CDN을 만들 때 Pricing을 S1 Verizon으로 선택했을 때 볼 수 있는 모니터링이 도구다. S2 Akamai를 선택했을 때는 사용할 수 없다.\n\n아래 설명된 예제 리포트는 <a href=\"http://www.wantreez.com/\">원트리즈 뮤직</a>에서 제공해 주셨다.\n\nS1 Verizon과 S2 Akamai의 차이점은 <a href=\"http://ilseokoh.com/2016/11/23/azure-cdn-%ec%99%84%ec%a0%84%ec%a0%95%eb%b3%b5-1-%eb%a7%8c%eb%93%a4%ea%b8%b0/\">이 시리즈의 첫번째 글 만들기</a> 편에 설명되어 있다.\n<h2>모니터링 도구 접속</h2>\n모니터링 도구에 접속 하려면 먼저 <a href=\"http://portal.azure.com\">Azure 포털</a>에 접속해서 모니터링할 CDN 프로파일을 찾아서 아래 그림처럼 Manage 버튼을 누르면 새로운 페이지가 떠서 모니터링 내용을 볼 수 있다.\n\n<img class=\"alignnone size-full wp-image-2791\" src=\"/content/images/2016/11/cdn_manage_button.png\" alt=\"cdn_manage_button\" width=\"908\" height=\"341\" />\n\n제공하는 리포트는 Bandwidth, Data Transferred, Status Codes, Cache Status, Cache Hit Rate, IPv4/IPv6 Data Transferred 총 7가지이다.\n<h2>Bandwidth</h2>\n대역폭 사용에 대한 정보를 볼 수 있다.\n\n그림에서 보면 지난 24시간 동안의 시간별 대역폭 사용량을 그래프와 데이터를 볼 수 있다. 서비스의 특성에 의해 밤과 새벽에는 대역폭 사용량이 없고 아침이 되면 서서히 올라가는 모습을 볼 수 있다. 여기서 시간은 GMT 시간이다.\n\n<img class=\"alignnone size-large wp-image-2801\" src=\"http://ilseokoh.com/content/images/2016/11/cdn_monitor_bandwidth-1024x635.png\" alt=\"cdn_monitor_bandwidth\" width=\"1008\" height=\"625\" />\n<h3>Data Transferred</h3>\n전송된 데이터량을 볼 수 있다.\n\n역시 새벽 시간에는 전송량이 없다가 아침부터 증가하는 모습을 볼 수 있다. 중간중간에 피크를 치는 시간대가 있는데 이런 구간은 상세한 분석을 통해서 왜 저런 현상이 일어나는지 파악해야 겠다.\n\n<img class=\"alignnone size-large wp-image-2841\" src=\"http://ilseokoh.com/content/images/2016/11/cdn_monitor_transferred-1024x600.png\" alt=\"cdn_monitor_transferred\" width=\"1008\" height=\"591\" />\n<h3>Status Codes</h3>\n전송결과에 대한 <a href=\"https://ko.wikipedia.org/wiki/HTTP_%EC%83%81%ED%83%9C_%EC%BD%94%EB%93%9C\">HTTP 응답 상태 코드</a>를 볼 수 있는 리포트로 내용을 자세히 살펴볼 필요가 있다.\n\nHTTP 200 상태코드는 성공을 나타내며 아래 그래프에서 대부분의 200 응답을 줬다. 200의 더 구체적인 의미는 CDN에서 컨텐츠를 실제 전송 했다는 뜻이다. 즉 네트워크를 통해서 컨텐츠가 전달되었고 전송된 만큼 과금이 이뤄진 경우다.\n\nHTTP 304는 \"수정되지 않음\"을 의미한다. 브라우저의 경우를 예로들면 브라우저가 해당 컨텐츠를 로컬 캐시에 이미 가지고 있으면 컨텐츠를 달라고 요청하지 않고 컨텐츠가 변경되었는지를 물어본다. 이 때 컨텐츠가 변경되지 않았으면 서버(CDN)는 304 를 응답하고 실제 컨텐츠를 전송하지 않는다. 즉 전송을 하지 않았으니 그만큼 과금이 안되는 것이다.\n\nHTTP 206는 \"일부 컨텐츠\"를 의미하는데 컨텐츠가 클라이언트의 요청에 의해 전체 중 일부만 전송한 것이다.\n\nHTTP 204 \"컨텐츠 없음\"은 성공은 했으나 컨텐츠를 전송하지 않은 상태다.\n\n아래 그림에 있는 4가지 상태는 모두 정상적인 상황이다. 하지만 4xx 오류나 5xx오류는 문제가 있는 상태이므로 찾아서 해결을 해야 한다. Azure CDN Standard 가격의 리포트에서는 오류의 상세 내용을 알려주지는 않는다. Premium 가격을 선택하면 오류 리포트를 제공한다.\n\n오류의 인식과 처리도 중요하지만 304 도 중요하다. 클라이언트를 만들 때 HTTP의 캐싱에 대한 내용을 잘 만들어 주면 CDN 비용을 많이 줄일 수 있다. <a href=\"http://www.letmecompile.com/http-cache-튜토리얼/\">HTTP 캐싱에 대한 좋은 글</a>이 있어 링크한다.\n\n<img class=\"alignnone size-large wp-image-2831\" src=\"http://ilseokoh.com/content/images/2016/11/cdn_monitor_hit-1024x680.png\" alt=\"cdn_monitor_hit\" width=\"1008\" height=\"669\" />\n<h3>Cache Status</h3>\n캐시 Hit에 대한 비율을 알려주는 리포트다. TCP_HIT는 CDN에 캐싱되어 있는 컨텐츠를 클라이언트에 보내준 경우다. 즉, 클라이언트는 빠르게 컨텐츠를 받을 수 있다. TCP_MISS는 CDN에 캐싱이 없어서 컨텐츠 원본으로 부터 컨텐츠를 가져와서 제공한 경우다. 원본을 가져오는 시간이 필요하므로 클라이언트는 컨텐츠를 늦게 받아간다. 하지만 그 다음번 요청은 컨텐츠가 캐싱되어 있으므로 빠르게 가져갈 수 있다.\n\n새로운 컨텐츠나 업데이트 된 컨텐츠가 많으면 TCP_MISS 비율이 올라간다.\n\n<img class=\"alignnone size-large wp-image-2811\" src=\"http://ilseokoh.com/content/images/2016/11/cdn_monitor_cache-status-1024x680.png\" alt=\"cdn_monitor_cache-status\" width=\"1008\" height=\"669\" />\n<h3>Cache Hit Rate</h3>\n일별 캐시 Hit 비율을 보여준다. 신규 컨텐츠가 유입되면 그래프가 변경되는 것을 볼 수 있다.\n\n<img class=\"alignnone size-large wp-image-2821\" src=\"http://ilseokoh.com/content/images/2016/11/cdn_monitor_cachehitratio-1024x641.png\" alt=\"cdn_monitor_cachehitratio\" width=\"1008\" height=\"631\" />\n<h3>IPv4/IPv6 Data Transferred</h3>\n이 리포트는 IPv6를 사용하지 않기 때문에 의미가 없어서 스크린 캡쳐를 넣지 않았다.\n\nAzure CDN의 모니터링을 통해서 서비스에 문제가 없는지? CDN을 얼마나 사용하는지? 시간대별 컨텐츠 전송 패턴 등을 알 수 있다.특히 304 응답을 늘려서 비용을 줄이는 노력이 필요하다.",
                "html": "아래 내용은 Azure CDN을 만들 때 Pricing을 S1 Verizon으로 선택했을 때 볼 수 있는 모니터링이 도구다. S2 Akamai를 선택했을 때는 사용할 수 없다.<p>아래 설명된 예제 리포트는 <a href=\"http://www.wantreez.com/\">원트리즈 뮤직</a>에서 제공해 주셨다.<p>S1 Verizon과 S2 Akamai의 차이점은 <a href=\"http://ilseokoh.com/2016/11/23/azure-cdn-%ec%99%84%ec%a0%84%ec%a0%95%eb%b3%b5-1-%eb%a7%8c%eb%93%a4%ea%b8%b0/\">이 시리즈의 첫번째 글 만들기</a> 편에 설명되어 있다.\n<h2>모니터링 도구 접속</h2>\n모니터링 도구에 접속 하려면 먼저 <a href=\"http://portal.azure.com\">Azure 포털</a>에 접속해서 모니터링할 CDN 프로파일을 찾아서 아래 그림처럼 Manage 버튼을 누르면 새로운 페이지가 떠서 모니터링 내용을 볼 수 있다.<p><img class=\"alignnone size-full wp-image-2791\" src=\"/content/images/2016/11/cdn_manage_button.png\" alt=\"cdn_manage_button\" width=\"908\" height=\"341\" /><p>제공하는 리포트는 Bandwidth, Data Transferred, Status Codes, Cache Status, Cache Hit Rate, IPv4/IPv6 Data Transferred 총 7가지이다.\n<h2>Bandwidth</h2>\n대역폭 사용에 대한 정보를 볼 수 있다.<p>그림에서 보면 지난 24시간 동안의 시간별 대역폭 사용량을 그래프와 데이터를 볼 수 있다. 서비스의 특성에 의해 밤과 새벽에는 대역폭 사용량이 없고 아침이 되면 서서히 올라가는 모습을 볼 수 있다. 여기서 시간은 GMT 시간이다.<p><img class=\"alignnone size-large wp-image-2801\" src=\"http://ilseokoh.com/content/images/2016/11/cdn_monitor_bandwidth-1024x635.png\" alt=\"cdn_monitor_bandwidth\" width=\"1008\" height=\"625\" />\n<h3>Data Transferred</h3>\n전송된 데이터량을 볼 수 있다.<p>역시 새벽 시간에는 전송량이 없다가 아침부터 증가하는 모습을 볼 수 있다. 중간중간에 피크를 치는 시간대가 있는데 이런 구간은 상세한 분석을 통해서 왜 저런 현상이 일어나는지 파악해야 겠다.<p><img class=\"alignnone size-large wp-image-2841\" src=\"http://ilseokoh.com/content/images/2016/11/cdn_monitor_transferred-1024x600.png\" alt=\"cdn_monitor_transferred\" width=\"1008\" height=\"591\" />\n<h3>Status Codes</h3>\n전송결과에 대한 <a href=\"https://ko.wikipedia.org/wiki/HTTP_%EC%83%81%ED%83%9C_%EC%BD%94%EB%93%9C\">HTTP 응답 상태 코드</a>를 볼 수 있는 리포트로 내용을 자세히 살펴볼 필요가 있다.<p>HTTP 200 상태코드는 성공을 나타내며 아래 그래프에서 대부분의 200 응답을 줬다. 200의 더 구체적인 의미는 CDN에서 컨텐츠를 실제 전송 했다는 뜻이다. 즉 네트워크를 통해서 컨텐츠가 전달되었고 전송된 만큼 과금이 이뤄진 경우다.<p>HTTP 304는 \"수정되지 않음\"을 의미한다. 브라우저의 경우를 예로들면 브라우저가 해당 컨텐츠를 로컬 캐시에 이미 가지고 있으면 컨텐츠를 달라고 요청하지 않고 컨텐츠가 변경되었는지를 물어본다. 이 때 컨텐츠가 변경되지 않았으면 서버(CDN)는 304 를 응답하고 실제 컨텐츠를 전송하지 않는다. 즉 전송을 하지 않았으니 그만큼 과금이 안되는 것이다.<p>HTTP 206는 \"일부 컨텐츠\"를 의미하는데 컨텐츠가 클라이언트의 요청에 의해 전체 중 일부만 전송한 것이다.<p>HTTP 204 \"컨텐츠 없음\"은 성공은 했으나 컨텐츠를 전송하지 않은 상태다.<p>아래 그림에 있는 4가지 상태는 모두 정상적인 상황이다. 하지만 4xx 오류나 5xx오류는 문제가 있는 상태이므로 찾아서 해결을 해야 한다. Azure CDN Standard 가격의 리포트에서는 오류의 상세 내용을 알려주지는 않는다. Premium 가격을 선택하면 오류 리포트를 제공한다.<p>오류의 인식과 처리도 중요하지만 304 도 중요하다. 클라이언트를 만들 때 HTTP의 캐싱에 대한 내용을 잘 만들어 주면 CDN 비용을 많이 줄일 수 있다. <a href=\"http://www.letmecompile.com/http-cache-튜토리얼/\">HTTP 캐싱에 대한 좋은 글</a>이 있어 링크한다.<p><img class=\"alignnone size-large wp-image-2831\" src=\"http://ilseokoh.com/content/images/2016/11/cdn_monitor_hit-1024x680.png\" alt=\"cdn_monitor_hit\" width=\"1008\" height=\"669\" />\n<h3>Cache Status</h3>\n캐시 Hit에 대한 비율을 알려주는 리포트다. TCP_HIT는 CDN에 캐싱되어 있는 컨텐츠를 클라이언트에 보내준 경우다. 즉, 클라이언트는 빠르게 컨텐츠를 받을 수 있다. TCP_MISS는 CDN에 캐싱이 없어서 컨텐츠 원본으로 부터 컨텐츠를 가져와서 제공한 경우다. 원본을 가져오는 시간이 필요하므로 클라이언트는 컨텐츠를 늦게 받아간다. 하지만 그 다음번 요청은 컨텐츠가 캐싱되어 있으므로 빠르게 가져갈 수 있다.<p>새로운 컨텐츠나 업데이트 된 컨텐츠가 많으면 TCP_MISS 비율이 올라간다.<p><img class=\"alignnone size-large wp-image-2811\" src=\"http://ilseokoh.com/content/images/2016/11/cdn_monitor_cache-status-1024x680.png\" alt=\"cdn_monitor_cache-status\" width=\"1008\" height=\"669\" />\n<h3>Cache Hit Rate</h3>\n일별 캐시 Hit 비율을 보여준다. 신규 컨텐츠가 유입되면 그래프가 변경되는 것을 볼 수 있다.<p><img class=\"alignnone size-large wp-image-2821\" src=\"http://ilseokoh.com/content/images/2016/11/cdn_monitor_cachehitratio-1024x641.png\" alt=\"cdn_monitor_cachehitratio\" width=\"1008\" height=\"631\" />\n<h3>IPv4/IPv6 Data Transferred</h3>\n이 리포트는 IPv6를 사용하지 않기 때문에 의미가 없어서 스크린 캡쳐를 넣지 않았다.<p>Azure CDN의 모니터링을 통해서 서비스에 문제가 없는지? CDN을 얼마나 사용하는지? 시간대별 컨텐츠 전송 패턴 등을 알 수 있다.특히 304 응답을 늘려서 비용을 줄이는 노력이 필요하다.",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1479989331000,
                "created_by": 1,
                "updated_at": 1479989331000,
                "updated_by": 1,
                "published_at": 1479989331000,
                "published_by": 1
            },
            {
                "id": 3011,
                "title": "Azure CDN 완전정복 4 - 기타설정",
                "slug": "azure-cdn-%ec%99%84%ec%a0%84%ec%a0%95%eb%b3%b5-4-%ea%b8%b0%ed%83%80%ec%84%a4%ec%a0%95",
                "markdown": "&nbsp;\n<h2>1. 미리로드</h2>\n<div>Azure CDN 은 캐시기 때문에 최초 요청이 오면 원본 컨텐츠를 가져와서 캐싱 후에 전달 해준다. 즉, 최초 요청에는 캐싱을 사용하지 못하므로 (Cache Miss)전송 속도가 느리다. Verizon CDN의 경우에는 이를 방지 하기 위해서 미리로드 기능이 제공 된다. (Akamai는 제공하지 않음) 이 기능을 이용하려면 <a href=\"https://docs.microsoft.com/ko-kr/azure/cdn/cdn-preload-endpoint\">Azure CDN 끝점에 자산 미리 로드 </a>문서를 참고 바란다. 첫번째 요청 마져 빨라야 하는 것이라면 이 기능을 사용하면 되지만 자연스럽게 첫 요청에서 CDN 캐싱이 되도록 놔두는 것도 나쁘지 않다.</div>\n<div></div>\n<h2>2. 압축</h2>\n<div>Azure CDN은 HTTP 압축을 지원한다. HTTP 압축에 대해서는 좋은 글이 많으니 검색해서 참조하면 되고 Azure CDN에서 설정하는 방법은 <a href=\"https://docs.microsoft.com/ko-kr/azure/cdn/cdn-improve-performance\">파일을 압축하여 성능 향상 </a>글을 참조 바란다. 이 글에서 포인트 몇 개를 가져오면</div>\n<ul>\n \t<li>이미 압축되어 있는 포멧 (ZIP, MP3, MP4, JPG 등)에는 적용하지 않는 것이 좋음.</li>\n \t<li>압축을 할지 말지에 대한 규칙이 있음.\n<ul>\n \t<li>Verizon의 경우 128B - 1MB 사이의 컨텐츠만 압축, Akamai는 모든 파일 가능</li>\n \t<li>Verizon은 gzip, deflate, bzip2 인코딩 지원, Akamai는 gzip만 지원</li>\n</ul>\n</li>\n</ul>\n테스트 html 파일을 Azure CDN에 올려서 웹브라우저로 요청하고 Fiddler로 내용을 보면 압축한 것을 확인 할 수 있다. Response Header에 Content-Encoding: gzip 을 확인할 수 있고 본문이 압축되어 있다.\n\n<img class=\"aligncenter size-large wp-image-12556\" src=\"https://msdnshared.blob.core.windows.net/media/2016/11/cdn_comp-1024x683.png\" alt=\"cdn_comp\" width=\"1024\" height=\"683\" />\n<h2>3. Custom Domain</h2>\n<div>Azure CDN은 끝점을 만들면 xxx.azureedge.net 이라는 도메인을 제공한다. 때때로 t서비스의 서브 도메인으로 변경하고 싶을 때가 있는데 Azure 에서 Custom Domain을 제공한다. 설정 방법은 <a href=\"https://docs.microsoft.com/ko-kr/azure/cdn/cdn-map-content-to-custom-domain\">사용자 지정 도메인을 CDN(콘텐츠 배달 네트워크) 끝점에 매핑하는 방법을 참조</a>하면 된다. 각자의 DNS 관리에 들어가서 Azure에서 제공하는 주소를 CNAME으로 등록하고 Azure Portal에 그 주소를 입력해주면된다. cdn.contoso.com dl.contoso.com 등의 주소를 사용 가능하다.</div>\n<div></div>\n<div>CNAME으로 설정했을 경우 전파 속도가 빠르지만 오래걸릴 경우도 있으니 활성화 될 때까지 기다려야 한다.</div>\n<div></div>\n<div>중요한 제약사항이 있다.</div>\n<div></div>\n<div><del>이렇게 만든 Custom Domain 이 HTTPS를 지원하려면 인증서를 업로드해서 활성화 해야 하는데 아직 Azure CDN에서는 지원하지 않는다. 즉 HTTPS를 사용하는 웹 사이트에 CDN 주소를 적용할 때에는 Custom Domain 말고 Azure 에서 만든 xxx.azureedge.net 을 사용해야 한다. 이 기능이 빨리 구현되기를 바란다면 <a href=\"https://feedback.azure.com/forums/169397-cdn/suggestions/1332683-allow-https-for-custom-cdn-domain-names\">Feed Back 에 가서 Vote</a> 버튼을 눌러주길 바란다.</del></div>\n<div>2017년 2월 6일 부터 Custom Domain에 Https를 지원 합니다.</div>\n<h2>4. 국가별 액세스 제한(Geo-filtering)</h2>\n<div>CDN의 사용 시나리오에 따라서 국가별로 컨텐츠가 안보이도록 제한하고 싶은 경우가 있다. 예를들어 한국말로 녹화된 동영상 컨텐츠가 한국에서만 볼 수 있도록 설정을 해서 컨텐츠가 유출 되는 것을 막을 수 있다. 이 기능을 사용하려면 <a href=\"https://docs.microsoft.com/ko-kr/azure/cdn/cdn-restrict-access-by-country\">국가별 액세스 제한 문서</a>를 참고 하면 된다. <a href=\"https://azure.microsoft.com/en-us/updates/akamai-geo-filtering/\">최근(2016-10-21 부터)에 Akamai 도 지원하게 되었다</a>.</div>\n<div></div>\n<div>역시 새로운 설정이 적용 되려면 역시 최대 90분 을 기다려야 한다.</div>\n<div></div>\n<div><img class=\"aligncenter size-full wp-image-12585\" src=\"https://msdnshared.blob.core.windows.net/media/2016/11/azure_cdn_geofiltering.png\" alt=\"azure_cdn_geofiltering\" width=\"865\" height=\"540\" /></div>\n<div></div>",
                "html": "&nbsp;\n<h2>1. 미리로드</h2>\n<div>Azure CDN 은 캐시기 때문에 최초 요청이 오면 원본 컨텐츠를 가져와서 캐싱 후에 전달 해준다. 즉, 최초 요청에는 캐싱을 사용하지 못하므로 (Cache Miss)전송 속도가 느리다. Verizon CDN의 경우에는 이를 방지 하기 위해서 미리로드 기능이 제공 된다. (Akamai는 제공하지 않음) 이 기능을 이용하려면 <a href=\"https://docs.microsoft.com/ko-kr/azure/cdn/cdn-preload-endpoint\">Azure CDN 끝점에 자산 미리 로드 </a>문서를 참고 바란다. 첫번째 요청 마져 빨라야 하는 것이라면 이 기능을 사용하면 되지만 자연스럽게 첫 요청에서 CDN 캐싱이 되도록 놔두는 것도 나쁘지 않다.</div>\n<div></div>\n<h2>2. 압축</h2>\n<div>Azure CDN은 HTTP 압축을 지원한다. HTTP 압축에 대해서는 좋은 글이 많으니 검색해서 참조하면 되고 Azure CDN에서 설정하는 방법은 <a href=\"https://docs.microsoft.com/ko-kr/azure/cdn/cdn-improve-performance\">파일을 압축하여 성능 향상 </a>글을 참조 바란다. 이 글에서 포인트 몇 개를 가져오면</div>\n<ul>\n \t<li>이미 압축되어 있는 포멧 (ZIP, MP3, MP4, JPG 등)에는 적용하지 않는 것이 좋음.</li>\n \t<li>압축을 할지 말지에 대한 규칙이 있음.\n<ul>\n \t<li>Verizon의 경우 128B - 1MB 사이의 컨텐츠만 압축, Akamai는 모든 파일 가능</li>\n \t<li>Verizon은 gzip, deflate, bzip2 인코딩 지원, Akamai는 gzip만 지원</li>\n</ul>\n</li>\n</ul>\n테스트 html 파일을 Azure CDN에 올려서 웹브라우저로 요청하고 Fiddler로 내용을 보면 압축한 것을 확인 할 수 있다. Response Header에 Content-Encoding: gzip 을 확인할 수 있고 본문이 압축되어 있다.<p><img class=\"aligncenter size-large wp-image-12556\" src=\"https://msdnshared.blob.core.windows.net/media/2016/11/cdn_comp-1024x683.png\" alt=\"cdn_comp\" width=\"1024\" height=\"683\" />\n<h2>3. Custom Domain</h2>\n<div>Azure CDN은 끝점을 만들면 xxx.azureedge.net 이라는 도메인을 제공한다. 때때로 t서비스의 서브 도메인으로 변경하고 싶을 때가 있는데 Azure 에서 Custom Domain을 제공한다. 설정 방법은 <a href=\"https://docs.microsoft.com/ko-kr/azure/cdn/cdn-map-content-to-custom-domain\">사용자 지정 도메인을 CDN(콘텐츠 배달 네트워크) 끝점에 매핑하는 방법을 참조</a>하면 된다. 각자의 DNS 관리에 들어가서 Azure에서 제공하는 주소를 CNAME으로 등록하고 Azure Portal에 그 주소를 입력해주면된다. cdn.contoso.com dl.contoso.com 등의 주소를 사용 가능하다.</div>\n<div></div>\n<div>CNAME으로 설정했을 경우 전파 속도가 빠르지만 오래걸릴 경우도 있으니 활성화 될 때까지 기다려야 한다.</div>\n<div></div>\n<div>중요한 제약사항이 있다.</div>\n<div></div>\n<div><del>이렇게 만든 Custom Domain 이 HTTPS를 지원하려면 인증서를 업로드해서 활성화 해야 하는데 아직 Azure CDN에서는 지원하지 않는다. 즉 HTTPS를 사용하는 웹 사이트에 CDN 주소를 적용할 때에는 Custom Domain 말고 Azure 에서 만든 xxx.azureedge.net 을 사용해야 한다. 이 기능이 빨리 구현되기를 바란다면 <a href=\"https://feedback.azure.com/forums/169397-cdn/suggestions/1332683-allow-https-for-custom-cdn-domain-names\">Feed Back 에 가서 Vote</a> 버튼을 눌러주길 바란다.</del></div>\n<div>2017년 2월 6일 부터 Custom Domain에 Https를 지원 합니다.</div>\n<h2>4. 국가별 액세스 제한(Geo-filtering)</h2>\n<div>CDN의 사용 시나리오에 따라서 국가별로 컨텐츠가 안보이도록 제한하고 싶은 경우가 있다. 예를들어 한국말로 녹화된 동영상 컨텐츠가 한국에서만 볼 수 있도록 설정을 해서 컨텐츠가 유출 되는 것을 막을 수 있다. 이 기능을 사용하려면 <a href=\"https://docs.microsoft.com/ko-kr/azure/cdn/cdn-restrict-access-by-country\">국가별 액세스 제한 문서</a>를 참고 하면 된다. <a href=\"https://azure.microsoft.com/en-us/updates/akamai-geo-filtering/\">최근(2016-10-21 부터)에 Akamai 도 지원하게 되었다</a>.</div>\n<div></div>\n<div>역시 새로운 설정이 적용 되려면 역시 최대 90분 을 기다려야 한다.</div>\n<div></div>\n<div><img class=\"aligncenter size-full wp-image-12585\" src=\"https://msdnshared.blob.core.windows.net/media/2016/11/azure_cdn_geofiltering.png\" alt=\"azure_cdn_geofiltering\" width=\"865\" height=\"540\" /></div>\n<div></div>",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1479997087000,
                "created_by": 1,
                "updated_at": 1479997087000,
                "updated_by": 1,
                "published_at": 1479997087000,
                "published_by": 1
            },
            {
                "id": 3171,
                "title": "핀켓 CS ChatBot 만들기 HackFest 사례",
                "slug": "%ed%95%80%ec%bc%93-cs-chatbot-%eb%a7%8c%eb%93%a4%ea%b8%b0-hackfest-%ec%82%ac%eb%a1%80",
                "markdown": "<p class=\"p1\"><span class=\"s1\"><a href=\"http://madup.com/\">매드업</a></span>은<span class=\"s2\"> 2011</span>년 설립된 폰플에서 진화한 마케팅 전문기업으로<span class=\"s2\"> <a href=\"http://finket.co.kr/\"><span class=\"s3\">핀켓</span><span class=\"s1\">(FINKET)</span></a></span>이라는<span class=\"s2\"> Mobile Finance Service</span>를 운영하고 있습니다<span class=\"s2\">. <a href=\"https://play.google.com/store/apps/details?id=com.madup.pocket&amp;hl=ko\"><span class=\"s3\">핀켓</span> <span class=\"s3\">앱</span></a></span>은 스마트폰의 잠금화면으로 신뢰성 있는 금융 기사와 포인트 통합 그리고 편리한 멤버십 적립과 개인 금융 서비스를<span class=\"s2\">, </span>광고주에게는 타겟 금융 광고 플랫폼을 제공합니다<span class=\"s2\">. </span></p>\n<p class=\"p3\"><span class=\"s4\">매드업과</span> <span class=\"s4\">마이크로소프트가</span> <span class=\"s4\">함께</span> HackFest<span class=\"s4\">를</span> <span class=\"s4\">통해서</span> <span class=\"s4\">핀켓</span> <span class=\"s4\">앱의</span> CS(Customer Satisfaction) <span class=\"s4\">기능을</span> <span class=\"s4\">강화하기</span> <span class=\"s4\">위해</span> ChatBot<span class=\"s4\">을</span> <span class=\"s4\">만들었습니다</span>.</p>\n\n<h2 class=\"p1\"><b>해결하고</b><b> </b><b>싶은</b><b> </b><b>문제점</b><b> </b></h2>\n<p class=\"p1\">핀켓의 서비스는 여러 금융 서비스가 연결되기 때문에 사용자들의 문의가 많은 편입니다<span class=\"s1\">. </span>앱의 문의하기 기능은 운영자가 답변을 해줘야 하기 때문에 시간이 지체되거나 업무시간이 아니면 답변을 빠르게 줄 수 없는 문제가 있습니다<span class=\"s1\">. </span></p>\n<p class=\"p1\">대화형으로 고객의 질문에 답변을 즉시 해줄 수 있는<span class=\"s1\"> Bot</span>을 통해서<span class=\"s1\"> 1</span>차 응답을 주고 더 자세한 고객지원이 필요하면 다시 운영 담당자에게 연결시켜주면 고객의 만족도를 높일 수 있다는 아이디어에서<span class=\"s1\"> HackFest</span>를 진행했습니다<span class=\"s1\">.</span></p>\n\n<h2 class=\"p1\"><b>Microsoft Bot Framework </b><span class=\"s1\"><b>소개</b></span><b> </b></h2>\n<p class=\"p1\"><span class=\"s2\"><a href=\"https://dev.botframework.com/\">Microsoft Bot Framework</a></span><span class=\"s1\">는</span> Bot<span class=\"s1\">을</span> <span class=\"s1\">만들기</span> <span class=\"s1\">위해</span> <span class=\"s1\">마이크로소프트가</span> <span class=\"s1\">운영하는</span> <span class=\"s1\">서비스와</span> SDK<span class=\"s1\">입니다</span>. Bot Connector<span class=\"s1\">라는</span> <span class=\"s1\">서비스를</span> <span class=\"s1\">중심으로</span> Skype, Facebook Messenger<span class=\"s1\">등의</span> <span class=\"s1\">채널을</span> <span class=\"s1\">우리가</span> <span class=\"s1\">만들</span> Bot<span class=\"s1\">에</span> <span class=\"s1\">연결시켜</span> <span class=\"s1\">줍니다</span>. Node.js <span class=\"s1\">와</span> C# <span class=\"s1\">을</span> <span class=\"s1\">지원하는</span> Bot Builder SDK<span class=\"s1\">를</span> <span class=\"s1\">사용하면</span> <span class=\"s1\">빠르게</span> Bot<span class=\"s1\">을</span> <span class=\"s1\">만들</span> <span class=\"s1\">수</span> <span class=\"s1\">있습니다</span>.</p>\n<p class=\"p3\">만든<span class=\"s3\"> Bot</span>을 개발자 포털을 통해 등록하고<span class=\"s3\"> Bot Directory</span>를 통해서 사용자들에게 배포 할 수 있습니다<span class=\"s3\">. </span></p>\n<p class=\"p1\"><span class=\"s1\">또한</span> <a href=\"https://www.microsoft.com/cognitive-services\"><span class=\"s2\">Microsoft Cognitive Service</span></a><span class=\"s1\">의</span> <span class=\"s1\">여러</span> API<span class=\"s1\">를</span> <span class=\"s1\">연결시키면</span> Bot<span class=\"s1\">을</span> <span class=\"s1\">더욱</span> <span class=\"s1\">똑똑하게</span> <span class=\"s1\">만들어</span> <span class=\"s1\">줄</span> <span class=\"s1\">수</span> <span class=\"s1\">있습니다</span>. <span class=\"s1\">특히</span> <a href=\"https://www.microsoft.com/cognitive-services/en-us/language-understanding-intelligent-service-luis\"><span class=\"s2\">LUIS(Language Understand Intelligent Service)</span></a><span class=\"s1\">는</span> <span class=\"s1\">자연어</span> <span class=\"s1\">처리를</span> <span class=\"s1\">할</span> <span class=\"s1\">수</span> <span class=\"s1\">있으므로</span> <span class=\"s1\">사용자와</span> Bot <span class=\"s1\">사이의</span> <span class=\"s1\">자연스러운</span> <span class=\"s1\">대화가</span> <span class=\"s1\">가능하게</span> <span class=\"s1\">합니다</span>. LUIS<span class=\"s1\">는</span> <span class=\"s1\">현재</span> Preview <span class=\"s1\">버전을</span> <span class=\"s1\">사용해</span> <span class=\"s1\">볼</span> <span class=\"s1\">수</span> <span class=\"s1\">있고</span> <span class=\"s1\">영어</span>, <span class=\"s1\">중국어</span> <span class=\"s1\">등</span> 7<span class=\"s1\">가지</span> <span class=\"s1\">언어를</span> <span class=\"s1\">지원하지만</span> <span class=\"s1\">한국어는</span> 2017<span class=\"s1\">년</span> <span class=\"s1\">공개</span> <span class=\"s1\">예정이고</span> <span class=\"s1\">아직</span> <span class=\"s1\">지원하고</span> <span class=\"s1\">있지</span> <span class=\"s1\">않습니다</span>.</p>\n\n<h2 class=\"p1\"><b>FINKET CS Bot</b></h2>\n[embed]https://www.youtube.com/watch?v=iUrwiaHB7p4[/embed]\n<p class=\"p3\">현재<span class=\"s1\"> LUIS </span>도 한국어를 지원하지 않고 기타<span class=\"s1\"> API</span>형태로 공개된 한국어 자연어 처리 서비스가 없으므로 두 단계의 개발 로드맵을 설정하고 첫번째 단계에서는 자연어 처리를 쓰지 않지만 자연스럽게 대화하는 느낌을 주면서 사용자에게 선택지를 주는 방식으로<span class=\"s1\"> 1</span>차 개발하기로 결정했습니다<span class=\"s1\">. </span></p>\n<p class=\"p3\">사용자에게<span class=\"s1\"> 3 </span>단계의 선택지를 주면서 최종 질문을 알아내고 그 질문에 가장 적절한 답을 줍니다<span class=\"s1\">. </span>대화하는 느낌을 주기 위해서 항상 같은 문장의 질문과 답변이 아닌<span class=\"s1\"> 3</span>가지 정도의 같은 의미의 다른 문장을 준비해서 사용자에게 전달 합니다<span class=\"s1\">.</span></p>\n\n<h2 class=\"p3\"><b>질문</b><span class=\"s1\"><b>/</b></span><b>답</b><b> </b><b>데이터</b></h2>\n<p class=\"p3\">그 동안<span class=\"s1\"> FINKET </span>서비스를 운영하면서 쌓아놓은 고객의 질문과 답변 중에서 가장 빈도가 높은 질문을 뽑아서<span class=\"s1\"> 3</span>단계 카테고리로 정의하고 최종 질문과 그 질문에 적합한 답변 데이터도 준비를 해서 이 데이터들은 데이터베이스에 담았습니다<span class=\"s1\">.</span></p>\n\n<h2 class=\"p1\"><b>기본</b><b> </b><b>아키텍처</b><b> </b><b>다이어그램</b><b> </b></h2>\n<img class=\"alignnone size-full wp-image-3201\" src=\"/content/images/2016/12/madup-bot-diagram.jpg\" alt=\"madup-bot-diagram\" width=\"824\" height=\"440\" />\n<ul class=\"ul1\">\n<ul class=\"ul1\">\n \t<li class=\"li1\">사용자는<span class=\"s1\"> Android</span>앱을 통해서 메시지를 입력하여<span class=\"s1\"> Bot</span>에 전달하거나<span class=\"s1\"> Bot</span>이 전달 해준 메시지를 받습니다<span class=\"s1\">. </span></li>\n \t<li class=\"li3\"><span class=\"s3\">사용자가</span> <span class=\"s3\">입력한</span> <span class=\"s3\">메시지는</span> Direct Line REST API<span class=\"s3\">를</span> <span class=\"s3\">통해서</span> Bot Connector<span class=\"s3\">에</span> <span class=\"s3\">전달</span> <span class=\"s3\">되고</span> Bot Connector<span class=\"s3\">는</span> <span class=\"s3\">올바른</span> Bot<span class=\"s3\">에게</span> <span class=\"s3\">메시지를</span> <span class=\"s3\">전달</span> <span class=\"s3\">합니다</span>.</li>\n \t<li class=\"li1\"><span class=\"s1\">Bot</span>은 적절한 질문과 대답을 데이터베이스에서 조회해서 사용자에게 전달합니다<span class=\"s1\">. </span></li>\n \t<li class=\"li3\">Bot<span class=\"s3\">은</span> Azure Web App <span class=\"s3\">에</span> <span class=\"s3\">배포해서</span> <span class=\"s3\">운영하고</span> <span class=\"s3\">데이터</span> <span class=\"s3\">베이스는</span> Azure SQL Database<span class=\"s3\">를</span> <span class=\"s3\">사용합니다</span>.</li>\n</ul>\n</ul>\n<h2 class=\"p1\"><b>Conversation Channel</b></h2>\n<p class=\"p1\"><span class=\"s1\">기존</span> FINKET<span class=\"s1\">앱에</span> <span class=\"s1\">통합되어</span> <span class=\"s1\">배포가</span> <span class=\"s1\">될</span> <span class=\"s1\">예정이기</span> <span class=\"s1\">때문에</span> Microsoft Bot Framework<span class=\"s1\">가</span> <span class=\"s1\">지원하는</span> Skype, Facebook Messenger <span class=\"s1\">등의</span> <span class=\"s1\">채널을</span> <span class=\"s1\">사용하지</span> <span class=\"s1\">않고</span> Android <span class=\"s1\">기반의</span> <span class=\"s1\">앱을</span> <span class=\"s1\">직접</span> <span class=\"s1\">개발하기로</span> <span class=\"s1\">결정했습니다</span>. Bot Connector<span class=\"s1\">와</span> <span class=\"s1\">연결을</span> <span class=\"s1\">위해서</span> Direct Line<span class=\"s1\">이라는</span> <span class=\"s1\">채널을</span> <span class=\"s1\">사용했습니다</span>.<span class=\"Apple-converted-space\">  </span>Direct Line<span class=\"s1\">은</span> REST <span class=\"s1\">방식의</span> API<span class=\"s1\">로</span> <span class=\"s1\">인증을</span> <span class=\"s1\">하고</span> <span class=\"s1\">대화를</span> <span class=\"s1\">주고</span> <span class=\"s1\">받는</span> API<span class=\"s1\">를</span> <span class=\"s1\">제공</span> <span class=\"s1\">합니다</span>. <span class=\"s1\">현재</span><span class=\"Apple-converted-space\">  </span>Direct Line 3.0 REST API<span class=\"s1\">가</span> <span class=\"s1\">공개되었고</span> FINKET Bot<span class=\"s1\">은</span> Direct Line 1.1 REST API<span class=\"s1\">를</span> <span class=\"s1\">사용했습니다</span>.</p>\n<p class=\"p1\">Direct Line API<span class=\"s1\">에</span> <span class=\"s1\">대한</span> <span class=\"s1\">자세한</span> <span class=\"s1\">내용은</span> <a href=\"https://docs.botframework.com/en-us/restapi/directline3/%22%20%5Cl%20%22navtitle\"><span class=\"s2\">Bot Framework </span><span class=\"s3\">문서</span><span class=\"s2\">(</span><span class=\"s3\">영문</span><span class=\"s2\">)</span></a><span class=\"s1\">나</span> Eva <span class=\"s1\">블로그</span> <span class=\"s1\">포스팅을</span> <span class=\"s1\">참조하세요</span>.</p>\n\n<h2 class=\"p1\"><b>FINKET Bot </b><span class=\"s1\"><b>소스코드</b></span><b> </b></h2>\n<p class=\"p3\"><span class=\"s4\">HackFest</span>의 결과물인 소스코드는 오픈소스로<span class=\"s4\"> <a href=\"https://github.com/MadupPinket/ket-bot\"><span class=\"s2\">Github </span><span class=\"s3\">에</span> <span class=\"s3\">공개</span></a> </span>되어 있습니다<span class=\"s4\">. </span>개발 환경은 아래 표와 같고 실제 구동 방법은<span class=\"s4\"> Github README </span>파일을 참조하세요<span class=\"s4\">. </span></p>\n\n<table class=\"t1\" cellspacing=\"0\" cellpadding=\"0\">\n<tbody>\n<tr>\n<td class=\"td1\" valign=\"top\">\n<p class=\"p2\">Bot</p>\n\n<ul class=\"ul1\">\n<ul class=\"ul1\">\n \t<li class=\"li2\">Windows 10 / Visual Studio 2015</li>\n \t<li class=\"li2\">C#</li>\n \t<li class=\"li3\"><span class=\"s1\"><a href=\"http://aka.ms/bf-bc-vstemplate\"><span class=\"s2\">Bot Framework Template </span></a></span></li>\n \t<li class=\"li3\"><span class=\"s1\"><a href=\"https://aka.ms/bf-bc-emulator\"><span class=\"s2\">Bot Framework Emulator</span></a></span></li>\n</ul>\n</ul>\n</td>\n<td class=\"td1\" valign=\"top\">\n<p class=\"p2\">App</p>\n\n<ul class=\"ul1\">\n<ul class=\"ul1\">\n \t<li class=\"li2\">Windows 10 / Eclipse</li>\n \t<li class=\"li2\">Java</li>\n \t<li class=\"li2\">Android SDK</li>\n</ul>\n</ul>\n</td>\n</tr>\n</tbody>\n</table>\n<p class=\"p2\">Bot Builder SDK<span class=\"s3\">의</span> <span class=\"s3\">가장</span> <span class=\"s3\">핵심적인</span> <span class=\"s3\">코드는</span> <span class=\"s3\">바로</span> <a href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/dialogs.html\"><span class=\"s4\">IDialog </span><span class=\"s5\">인터페이스</span></a><span class=\"s3\">를</span> <span class=\"s3\">상속받은</span> Dialog <span class=\"s3\">클래스들</span> <span class=\"s3\">입니다</span>. FINKET Bot <span class=\"s3\">에서는</span> 5<span class=\"s3\">개의</span> Dialog<span class=\"s3\">를</span> <span class=\"s3\">체인으로</span> <span class=\"s3\">연결해서</span> <span class=\"s3\">대화의</span> <span class=\"s3\">흐름을</span> <span class=\"s3\">만들어</span> <span class=\"s3\">냈습니다</span>. Microsoft Bot Framework<span class=\"s3\">의</span> <span class=\"s3\">기본</span> <span class=\"s3\">설계</span> <span class=\"s3\">철학</span> <span class=\"s3\">중</span> <span class=\"s3\">하나는</span> Stateless <span class=\"s3\">입니다</span>. <span class=\"s3\">따라서</span> <span class=\"s3\">대화</span> <span class=\"s3\">중에</span> <span class=\"s3\">저장되어야</span> <span class=\"s3\">하는</span> <span class=\"s3\">상태</span> <span class=\"s3\">값들은</span> <span class=\"s3\">모두</span> Bot State Service<span class=\"s3\">에</span> <span class=\"s3\">저장해서</span> Bot <span class=\"s3\">자체는</span> <span class=\"s3\">상태를</span> <span class=\"s3\">가지고</span> <span class=\"s3\">있지</span> <span class=\"s3\">않도록</span> <span class=\"s3\">해야만</span> <span class=\"s3\">합니다</span>. <span class=\"s3\">그러면</span> Bot<span class=\"s3\">을</span> <span class=\"s3\">여러</span> <span class=\"s3\">대로</span> <span class=\"s3\">늘리는</span> Scale Out<span class=\"s3\">을</span> <span class=\"s3\">해도</span> <span class=\"s3\">문제가</span> <span class=\"s3\">발생하지</span> <span class=\"s3\">않습니다</span>.</p>\n<p class=\"p2\"><img class=\"alignnone size-full wp-image-3191\" src=\"/content/images/2016/12/madup-bot-code-flow.jpg\" alt=\"madup-bot-code-flow\" width=\"798\" height=\"482\" /></p>\n<p class=\"p4\"><span class=\"s6\">Dialog</span>의 사용 방법은<span class=\"s6\"> Eva </span>블로그 포스트를 참조 바랍니다<span class=\"s6\">.</span></p>\n\n<h2 class=\"p2\"><b>개발하면서</b><b> </b><b>배운점</b><b> </b></h2>\n<ul class=\"ul1\">\n<ul class=\"ul1\">\n \t<li class=\"li2\">질문과 답변이 정해진<span class=\"s1\"> Bot</span>의 경우 질문과 답 데이터를 데이터베이스에 저장해서 가져오는 것이 좋은 방법이 아닐 수도 있습니다<span class=\"s1\">. </span>한글 적용에는 조금 어색한 면이 있지만<span class=\"s1\"> <a href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/forms.htm\"><span class=\"s2\">FormFlow</span></a></span>를 사용하는게 오히려 성능에는 좋을 것 같습니다<span class=\"s1\">. </span></li>\n \t<li class=\"li3\">Direct Line<span class=\"s3\">을</span> <span class=\"s3\">사용하면</span> <span class=\"s3\">채널</span>(Android <span class=\"s3\">앱</span>)<span class=\"s3\">에</span> <span class=\"s3\">여러</span> <span class=\"s3\">기능을</span> <span class=\"s3\">넣어서</span> Bot<span class=\"s3\">의</span> Workload<span class=\"s3\">를</span> <span class=\"s3\">가져갈</span> <span class=\"s3\">수</span> <span class=\"s3\">있지만</span> Skype <span class=\"s3\">등의</span> <span class=\"s3\">다른</span> <span class=\"s3\">채널로</span> <span class=\"s3\">확장을</span> <span class=\"s3\">할</span> <span class=\"s3\">수</span> <span class=\"s3\">없는</span> <span class=\"s3\">문제가</span> <span class=\"s3\">생깁니다</span>. FINKET Bot<span class=\"s3\">의</span> Android <span class=\"s3\">앱도</span> <span class=\"s3\">최대한</span> <span class=\"s3\">메시지만</span> <span class=\"s3\">주고</span> <span class=\"s3\">받도록</span>Dummy <span class=\"s3\">기능만</span> <span class=\"s3\">구현되었습니다</span>.</li>\n</ul>\n</ul>\n<h2 class=\"p2\"><b>향후</b><b> </b><b>과제</b><b> </b></h2>\n<p class=\"p2\"><span class=\"s1\">1</span>차 구현에서 제외 되었던 자연어 처리 서비스를 붙여서 우리의 말과 글로 자연스럽게<span class=\"s1\"> Bot</span>에게 고객지원 관련 질문을 던지고 답을 받을 수 있어야 합니다<span class=\"s1\">. </span>아직<span class=\"s1\"> LUIS </span>가 한국어를 지원하지 않는 상황에서<span class=\"s1\"> Microsoft Translator API </span>를 추가로 붙여서 시도를 해볼 예정입니다<span class=\"s1\">. </span></p>",
                "html": "<p class=\"p1\"><span class=\"s1\"><a href=\"http://madup.com/\">매드업</a></span>은<span class=\"s2\"> 2011</span>년 설립된 폰플에서 진화한 마케팅 전문기업으로<span class=\"s2\"> <a href=\"http://finket.co.kr/\"><span class=\"s3\">핀켓</span><span class=\"s1\">(FINKET)</span></a></span>이라는<span class=\"s2\"> Mobile Finance Service</span>를 운영하고 있습니다<span class=\"s2\">. <a href=\"https://play.google.com/store/apps/details?id=com.madup.pocket&amp;hl=ko\"><span class=\"s3\">핀켓</span> <span class=\"s3\">앱</span></a></span>은 스마트폰의 잠금화면으로 신뢰성 있는 금융 기사와 포인트 통합 그리고 편리한 멤버십 적립과 개인 금융 서비스를<span class=\"s2\">, </span>광고주에게는 타겟 금융 광고 플랫폼을 제공합니다<span class=\"s2\">. </span></p>\n<p class=\"p3\"><span class=\"s4\">매드업과</span> <span class=\"s4\">마이크로소프트가</span> <span class=\"s4\">함께</span> HackFest<span class=\"s4\">를</span> <span class=\"s4\">통해서</span> <span class=\"s4\">핀켓</span> <span class=\"s4\">앱의</span> CS(Customer Satisfaction) <span class=\"s4\">기능을</span> <span class=\"s4\">강화하기</span> <span class=\"s4\">위해</span> ChatBot<span class=\"s4\">을</span> <span class=\"s4\">만들었습니다</span>.</p><p><h2 class=\"p1\"><b>해결하고</b><b> </b><b>싶은</b><b> </b><b>문제점</b><b> </b></h2>\n<p class=\"p1\">핀켓의 서비스는 여러 금융 서비스가 연결되기 때문에 사용자들의 문의가 많은 편입니다<span class=\"s1\">. </span>앱의 문의하기 기능은 운영자가 답변을 해줘야 하기 때문에 시간이 지체되거나 업무시간이 아니면 답변을 빠르게 줄 수 없는 문제가 있습니다<span class=\"s1\">. </span></p>\n<p class=\"p1\">대화형으로 고객의 질문에 답변을 즉시 해줄 수 있는<span class=\"s1\"> Bot</span>을 통해서<span class=\"s1\"> 1</span>차 응답을 주고 더 자세한 고객지원이 필요하면 다시 운영 담당자에게 연결시켜주면 고객의 만족도를 높일 수 있다는 아이디어에서<span class=\"s1\"> HackFest</span>를 진행했습니다<span class=\"s1\">.</span></p><p><h2 class=\"p1\"><b>Microsoft Bot Framework </b><span class=\"s1\"><b>소개</b></span><b> </b></h2>\n<p class=\"p1\"><span class=\"s2\"><a href=\"https://dev.botframework.com/\">Microsoft Bot Framework</a></span><span class=\"s1\">는</span> Bot<span class=\"s1\">을</span> <span class=\"s1\">만들기</span> <span class=\"s1\">위해</span> <span class=\"s1\">마이크로소프트가</span> <span class=\"s1\">운영하는</span> <span class=\"s1\">서비스와</span> SDK<span class=\"s1\">입니다</span>. Bot Connector<span class=\"s1\">라는</span> <span class=\"s1\">서비스를</span> <span class=\"s1\">중심으로</span> Skype, Facebook Messenger<span class=\"s1\">등의</span> <span class=\"s1\">채널을</span> <span class=\"s1\">우리가</span> <span class=\"s1\">만들</span> Bot<span class=\"s1\">에</span> <span class=\"s1\">연결시켜</span> <span class=\"s1\">줍니다</span>. Node.js <span class=\"s1\">와</span> C# <span class=\"s1\">을</span> <span class=\"s1\">지원하는</span> Bot Builder SDK<span class=\"s1\">를</span> <span class=\"s1\">사용하면</span> <span class=\"s1\">빠르게</span> Bot<span class=\"s1\">을</span> <span class=\"s1\">만들</span> <span class=\"s1\">수</span> <span class=\"s1\">있습니다</span>.</p>\n<p class=\"p3\">만든<span class=\"s3\"> Bot</span>을 개발자 포털을 통해 등록하고<span class=\"s3\"> Bot Directory</span>를 통해서 사용자들에게 배포 할 수 있습니다<span class=\"s3\">. </span></p>\n<p class=\"p1\"><span class=\"s1\">또한</span> <a href=\"https://www.microsoft.com/cognitive-services\"><span class=\"s2\">Microsoft Cognitive Service</span></a><span class=\"s1\">의</span> <span class=\"s1\">여러</span> API<span class=\"s1\">를</span> <span class=\"s1\">연결시키면</span> Bot<span class=\"s1\">을</span> <span class=\"s1\">더욱</span> <span class=\"s1\">똑똑하게</span> <span class=\"s1\">만들어</span> <span class=\"s1\">줄</span> <span class=\"s1\">수</span> <span class=\"s1\">있습니다</span>. <span class=\"s1\">특히</span> <a href=\"https://www.microsoft.com/cognitive-services/en-us/language-understanding-intelligent-service-luis\"><span class=\"s2\">LUIS(Language Understand Intelligent Service)</span></a><span class=\"s1\">는</span> <span class=\"s1\">자연어</span> <span class=\"s1\">처리를</span> <span class=\"s1\">할</span> <span class=\"s1\">수</span> <span class=\"s1\">있으므로</span> <span class=\"s1\">사용자와</span> Bot <span class=\"s1\">사이의</span> <span class=\"s1\">자연스러운</span> <span class=\"s1\">대화가</span> <span class=\"s1\">가능하게</span> <span class=\"s1\">합니다</span>. LUIS<span class=\"s1\">는</span> <span class=\"s1\">현재</span> Preview <span class=\"s1\">버전을</span> <span class=\"s1\">사용해</span> <span class=\"s1\">볼</span> <span class=\"s1\">수</span> <span class=\"s1\">있고</span> <span class=\"s1\">영어</span>, <span class=\"s1\">중국어</span> <span class=\"s1\">등</span> 7<span class=\"s1\">가지</span> <span class=\"s1\">언어를</span> <span class=\"s1\">지원하지만</span> <span class=\"s1\">한국어는</span> 2017<span class=\"s1\">년</span> <span class=\"s1\">공개</span> <span class=\"s1\">예정이고</span> <span class=\"s1\">아직</span> <span class=\"s1\">지원하고</span> <span class=\"s1\">있지</span> <span class=\"s1\">않습니다</span>.</p><p><h2 class=\"p1\"><b>FINKET CS Bot</b></h2>\n[embed]https://www.youtube.com/watch?v=iUrwiaHB7p4[/embed]\n<p class=\"p3\">현재<span class=\"s1\"> LUIS </span>도 한국어를 지원하지 않고 기타<span class=\"s1\"> API</span>형태로 공개된 한국어 자연어 처리 서비스가 없으므로 두 단계의 개발 로드맵을 설정하고 첫번째 단계에서는 자연어 처리를 쓰지 않지만 자연스럽게 대화하는 느낌을 주면서 사용자에게 선택지를 주는 방식으로<span class=\"s1\"> 1</span>차 개발하기로 결정했습니다<span class=\"s1\">. </span></p>\n<p class=\"p3\">사용자에게<span class=\"s1\"> 3 </span>단계의 선택지를 주면서 최종 질문을 알아내고 그 질문에 가장 적절한 답을 줍니다<span class=\"s1\">. </span>대화하는 느낌을 주기 위해서 항상 같은 문장의 질문과 답변이 아닌<span class=\"s1\"> 3</span>가지 정도의 같은 의미의 다른 문장을 준비해서 사용자에게 전달 합니다<span class=\"s1\">.</span></p><p><h2 class=\"p3\"><b>질문</b><span class=\"s1\"><b>/</b></span><b>답</b><b> </b><b>데이터</b></h2>\n<p class=\"p3\">그 동안<span class=\"s1\"> FINKET </span>서비스를 운영하면서 쌓아놓은 고객의 질문과 답변 중에서 가장 빈도가 높은 질문을 뽑아서<span class=\"s1\"> 3</span>단계 카테고리로 정의하고 최종 질문과 그 질문에 적합한 답변 데이터도 준비를 해서 이 데이터들은 데이터베이스에 담았습니다<span class=\"s1\">.</span></p><p><h2 class=\"p1\"><b>기본</b><b> </b><b>아키텍처</b><b> </b><b>다이어그램</b><b> </b></h2>\n<img class=\"alignnone size-full wp-image-3201\" src=\"/content/images/2016/12/madup-bot-diagram.jpg\" alt=\"madup-bot-diagram\" width=\"824\" height=\"440\" />\n<ul class=\"ul1\">\n<ul class=\"ul1\">\n \t<li class=\"li1\">사용자는<span class=\"s1\"> Android</span>앱을 통해서 메시지를 입력하여<span class=\"s1\"> Bot</span>에 전달하거나<span class=\"s1\"> Bot</span>이 전달 해준 메시지를 받습니다<span class=\"s1\">. </span></li>\n \t<li class=\"li3\"><span class=\"s3\">사용자가</span> <span class=\"s3\">입력한</span> <span class=\"s3\">메시지는</span> Direct Line REST API<span class=\"s3\">를</span> <span class=\"s3\">통해서</span> Bot Connector<span class=\"s3\">에</span> <span class=\"s3\">전달</span> <span class=\"s3\">되고</span> Bot Connector<span class=\"s3\">는</span> <span class=\"s3\">올바른</span> Bot<span class=\"s3\">에게</span> <span class=\"s3\">메시지를</span> <span class=\"s3\">전달</span> <span class=\"s3\">합니다</span>.</li>\n \t<li class=\"li1\"><span class=\"s1\">Bot</span>은 적절한 질문과 대답을 데이터베이스에서 조회해서 사용자에게 전달합니다<span class=\"s1\">. </span></li>\n \t<li class=\"li3\">Bot<span class=\"s3\">은</span> Azure Web App <span class=\"s3\">에</span> <span class=\"s3\">배포해서</span> <span class=\"s3\">운영하고</span> <span class=\"s3\">데이터</span> <span class=\"s3\">베이스는</span> Azure SQL Database<span class=\"s3\">를</span> <span class=\"s3\">사용합니다</span>.</li>\n</ul>\n</ul>\n<h2 class=\"p1\"><b>Conversation Channel</b></h2>\n<p class=\"p1\"><span class=\"s1\">기존</span> FINKET<span class=\"s1\">앱에</span> <span class=\"s1\">통합되어</span> <span class=\"s1\">배포가</span> <span class=\"s1\">될</span> <span class=\"s1\">예정이기</span> <span class=\"s1\">때문에</span> Microsoft Bot Framework<span class=\"s1\">가</span> <span class=\"s1\">지원하는</span> Skype, Facebook Messenger <span class=\"s1\">등의</span> <span class=\"s1\">채널을</span> <span class=\"s1\">사용하지</span> <span class=\"s1\">않고</span> Android <span class=\"s1\">기반의</span> <span class=\"s1\">앱을</span> <span class=\"s1\">직접</span> <span class=\"s1\">개발하기로</span> <span class=\"s1\">결정했습니다</span>. Bot Connector<span class=\"s1\">와</span> <span class=\"s1\">연결을</span> <span class=\"s1\">위해서</span> Direct Line<span class=\"s1\">이라는</span> <span class=\"s1\">채널을</span> <span class=\"s1\">사용했습니다</span>.<span class=\"Apple-converted-space\">  </span>Direct Line<span class=\"s1\">은</span> REST <span class=\"s1\">방식의</span> API<span class=\"s1\">로</span> <span class=\"s1\">인증을</span> <span class=\"s1\">하고</span> <span class=\"s1\">대화를</span> <span class=\"s1\">주고</span> <span class=\"s1\">받는</span> API<span class=\"s1\">를</span> <span class=\"s1\">제공</span> <span class=\"s1\">합니다</span>. <span class=\"s1\">현재</span><span class=\"Apple-converted-space\">  </span>Direct Line 3.0 REST API<span class=\"s1\">가</span> <span class=\"s1\">공개되었고</span> FINKET Bot<span class=\"s1\">은</span> Direct Line 1.1 REST API<span class=\"s1\">를</span> <span class=\"s1\">사용했습니다</span>.</p>\n<p class=\"p1\">Direct Line API<span class=\"s1\">에</span> <span class=\"s1\">대한</span> <span class=\"s1\">자세한</span> <span class=\"s1\">내용은</span> <a href=\"https://docs.botframework.com/en-us/restapi/directline3/%22%20%5Cl%20%22navtitle\"><span class=\"s2\">Bot Framework </span><span class=\"s3\">문서</span><span class=\"s2\">(</span><span class=\"s3\">영문</span><span class=\"s2\">)</span></a><span class=\"s1\">나</span> Eva <span class=\"s1\">블로그</span> <span class=\"s1\">포스팅을</span> <span class=\"s1\">참조하세요</span>.</p><p><h2 class=\"p1\"><b>FINKET Bot </b><span class=\"s1\"><b>소스코드</b></span><b> </b></h2>\n<p class=\"p3\"><span class=\"s4\">HackFest</span>의 결과물인 소스코드는 오픈소스로<span class=\"s4\"> <a href=\"https://github.com/MadupPinket/ket-bot\"><span class=\"s2\">Github </span><span class=\"s3\">에</span> <span class=\"s3\">공개</span></a> </span>되어 있습니다<span class=\"s4\">. </span>개발 환경은 아래 표와 같고 실제 구동 방법은<span class=\"s4\"> Github README </span>파일을 참조하세요<span class=\"s4\">. </span></p><p><table class=\"t1\" cellspacing=\"0\" cellpadding=\"0\">\n<tbody>\n<tr>\n<td class=\"td1\" valign=\"top\">\n<p class=\"p2\">Bot</p><p><ul class=\"ul1\">\n<ul class=\"ul1\">\n \t<li class=\"li2\">Windows 10 / Visual Studio 2015</li>\n \t<li class=\"li2\">C#</li>\n \t<li class=\"li3\"><span class=\"s1\"><a href=\"http://aka.ms/bf-bc-vstemplate\"><span class=\"s2\">Bot Framework Template </span></a></span></li>\n \t<li class=\"li3\"><span class=\"s1\"><a href=\"https://aka.ms/bf-bc-emulator\"><span class=\"s2\">Bot Framework Emulator</span></a></span></li>\n</ul>\n</ul>\n</td>\n<td class=\"td1\" valign=\"top\">\n<p class=\"p2\">App</p><p><ul class=\"ul1\">\n<ul class=\"ul1\">\n \t<li class=\"li2\">Windows 10 / Eclipse</li>\n \t<li class=\"li2\">Java</li>\n \t<li class=\"li2\">Android SDK</li>\n</ul>\n</ul>\n</td>\n</tr>\n</tbody>\n</table>\n<p class=\"p2\">Bot Builder SDK<span class=\"s3\">의</span> <span class=\"s3\">가장</span> <span class=\"s3\">핵심적인</span> <span class=\"s3\">코드는</span> <span class=\"s3\">바로</span> <a href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/dialogs.html\"><span class=\"s4\">IDialog </span><span class=\"s5\">인터페이스</span></a><span class=\"s3\">를</span> <span class=\"s3\">상속받은</span> Dialog <span class=\"s3\">클래스들</span> <span class=\"s3\">입니다</span>. FINKET Bot <span class=\"s3\">에서는</span> 5<span class=\"s3\">개의</span> Dialog<span class=\"s3\">를</span> <span class=\"s3\">체인으로</span> <span class=\"s3\">연결해서</span> <span class=\"s3\">대화의</span> <span class=\"s3\">흐름을</span> <span class=\"s3\">만들어</span> <span class=\"s3\">냈습니다</span>. Microsoft Bot Framework<span class=\"s3\">의</span> <span class=\"s3\">기본</span> <span class=\"s3\">설계</span> <span class=\"s3\">철학</span> <span class=\"s3\">중</span> <span class=\"s3\">하나는</span> Stateless <span class=\"s3\">입니다</span>. <span class=\"s3\">따라서</span> <span class=\"s3\">대화</span> <span class=\"s3\">중에</span> <span class=\"s3\">저장되어야</span> <span class=\"s3\">하는</span> <span class=\"s3\">상태</span> <span class=\"s3\">값들은</span> <span class=\"s3\">모두</span> Bot State Service<span class=\"s3\">에</span> <span class=\"s3\">저장해서</span> Bot <span class=\"s3\">자체는</span> <span class=\"s3\">상태를</span> <span class=\"s3\">가지고</span> <span class=\"s3\">있지</span> <span class=\"s3\">않도록</span> <span class=\"s3\">해야만</span> <span class=\"s3\">합니다</span>. <span class=\"s3\">그러면</span> Bot<span class=\"s3\">을</span> <span class=\"s3\">여러</span> <span class=\"s3\">대로</span> <span class=\"s3\">늘리는</span> Scale Out<span class=\"s3\">을</span> <span class=\"s3\">해도</span> <span class=\"s3\">문제가</span> <span class=\"s3\">발생하지</span> <span class=\"s3\">않습니다</span>.</p>\n<p class=\"p2\"><img class=\"alignnone size-full wp-image-3191\" src=\"/content/images/2016/12/madup-bot-code-flow.jpg\" alt=\"madup-bot-code-flow\" width=\"798\" height=\"482\" /></p>\n<p class=\"p4\"><span class=\"s6\">Dialog</span>의 사용 방법은<span class=\"s6\"> Eva </span>블로그 포스트를 참조 바랍니다<span class=\"s6\">.</span></p><p><h2 class=\"p2\"><b>개발하면서</b><b> </b><b>배운점</b><b> </b></h2>\n<ul class=\"ul1\">\n<ul class=\"ul1\">\n \t<li class=\"li2\">질문과 답변이 정해진<span class=\"s1\"> Bot</span>의 경우 질문과 답 데이터를 데이터베이스에 저장해서 가져오는 것이 좋은 방법이 아닐 수도 있습니다<span class=\"s1\">. </span>한글 적용에는 조금 어색한 면이 있지만<span class=\"s1\"> <a href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/forms.htm\"><span class=\"s2\">FormFlow</span></a></span>를 사용하는게 오히려 성능에는 좋을 것 같습니다<span class=\"s1\">. </span></li>\n \t<li class=\"li3\">Direct Line<span class=\"s3\">을</span> <span class=\"s3\">사용하면</span> <span class=\"s3\">채널</span>(Android <span class=\"s3\">앱</span>)<span class=\"s3\">에</span> <span class=\"s3\">여러</span> <span class=\"s3\">기능을</span> <span class=\"s3\">넣어서</span> Bot<span class=\"s3\">의</span> Workload<span class=\"s3\">를</span> <span class=\"s3\">가져갈</span> <span class=\"s3\">수</span> <span class=\"s3\">있지만</span> Skype <span class=\"s3\">등의</span> <span class=\"s3\">다른</span> <span class=\"s3\">채널로</span> <span class=\"s3\">확장을</span> <span class=\"s3\">할</span> <span class=\"s3\">수</span> <span class=\"s3\">없는</span> <span class=\"s3\">문제가</span> <span class=\"s3\">생깁니다</span>. FINKET Bot<span class=\"s3\">의</span> Android <span class=\"s3\">앱도</span> <span class=\"s3\">최대한</span> <span class=\"s3\">메시지만</span> <span class=\"s3\">주고</span> <span class=\"s3\">받도록</span>Dummy <span class=\"s3\">기능만</span> <span class=\"s3\">구현되었습니다</span>.</li>\n</ul>\n</ul>\n<h2 class=\"p2\"><b>향후</b><b> </b><b>과제</b><b> </b></h2>\n<p class=\"p2\"><span class=\"s1\">1</span>차 구현에서 제외 되었던 자연어 처리 서비스를 붙여서 우리의 말과 글로 자연스럽게<span class=\"s1\"> Bot</span>에게 고객지원 관련 질문을 던지고 답을 받을 수 있어야 합니다<span class=\"s1\">. </span>아직<span class=\"s1\"> LUIS </span>가 한국어를 지원하지 않는 상황에서<span class=\"s1\"> Microsoft Translator API </span>를 추가로 붙여서 시도를 해볼 예정입니다<span class=\"s1\">. </span></p>",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1480721719000,
                "created_by": 1,
                "updated_at": 1480721719000,
                "updated_by": 1,
                "published_at": 1480721719000,
                "published_by": 1
            },
            {
                "id": 3251,
                "title": "[Microsoft Bot Framework] Direct Line REST API 3.0",
                "slug": "microsoft-bot-framework-direct-line-rest-api-3-0",
                "markdown": "<h2>Direct Line REST API</h2>\n<a href=\"https://www.botframework.com/\">Microsoft Bot Framework</a>는 Skype, Facebook Messenger, Slack 등의 다양한 Conversation Channel을 지원하고 있고 그 수가 점점 늘어나고 있다. 하지만 내가 만들 모바일 앱에서 Bot 을 만들고 싶으면 어떤 방법이 있을까? Direct Line이라는 REST API를 지원하기 때문에 우리가 잘 알고 있는 프로그래밍 방법으로 쉽게 Bot 과 연결 시킬 수 있다.\n\n즉, 기존에 있는 채널이 아닌 프로그래밍 방식으로 Bot 과 연결 시키고 싶다면 <a href=\"https://docs.botframework.com/en-us/restapi/directline3\">Direct Line API</a>를 사용하면 된다. 실제로 안드로이드 앱에서 Direct Line REST API를 사용하여 Bot에 연결시킨 프로토타입 프로젝트가 Github에 올려져 있다. <a href=\"https://github.com/MadupPinket/ket-bot\">Ket-bot 프로젝트 코드</a>에서 실제 사용한 예를 볼 수 있다.\n\n<img class=\"alignnone size-large wp-image-3291\" src=\"http://ilseokoh.com/content/images/2016/12/bot-framework-1024x576.jpg\" alt=\"microsoft-bot-framework\" width=\"1008\" height=\"567\" />\n\nBot Connector는 Conversation Channel과 Bot 사이에 존재하는 마이크로소프트가 운영하는 서비스다. 채널은 Bot Connector만 연결해주고 메시지를 주고 받으면 된다. Bot 도 역시 Connector만 보고 메시지를 주고 받는다.\n\n현재 최신버전은 3.0이고 <a href=\"https://docs.botframework.com/en-us/restapi/directline3/\">공식 문서</a>에 모든 내용이 나와 있다. 1.1 버전에 비해서 WebSocket을 지원하고 파일 업로드도 지원한다.\n\nAPI 를 이해한 후 C# 개발자라면 <a href=\"https://www.nuget.org/packages/Microsoft.Bot.Connector.DirectLine\">Direct Line Nuget Package</a>를 받아서 활용하면 되고 <a href=\"https://docs.botframework.com/en-us/restapi/directline3/swagger.json\">Swagger file</a> 도 제공하기 때문에 자동으로 클라이언트 코드를 생성해서 빠르게 개발을 할 수 도 있다. 테스트는 REST API이기 때문에  <a href=\"https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop\">Chrome Postman</a>이나 <a href=\"http://www.telerik.com/fiddler\">Fiddler</a> 또는 <a href=\"https://docs.botframework.com/en-us/restapi/directline3/\">공식문서</a> 하단에 있는 Swagger를 이용하면 된다.\n\n이 글에서는 (WebSocket이 아닌)HTTP POST로 메시지를 보내고 GET을 Polling해서 응답 메시지를 받는 방법에 대해서 알아보기로 하겠다.\n<h3>Authentication</h3>\n인증과정은 Bot Dev Center에서 생성한 Secret 키를 던지고 token을 받아오는 과정이다. 받아온 token은 오고 가는 메시지의 HTTP 헤더에 넣어서 사용한다. Secret 키는 <a href=\"https://dev.botframework.com/bots/new\">Bot 등록페이지</a>에서 Direct Line 설정 페이지에서 얻을 수 있다.\n\n<img class=\"alignnone size-large wp-image-3311\" src=\"http://ilseokoh.com/content/images/2016/12/Config-direct-line-1024x540.png\" alt=\"bot-framework-direct-line-secret\" width=\"1008\" height=\"532\" />\n\nPOST로 https://directline.botframework.com/v3/directline/tokens/generate URL에 Authentication이라는 헤더에 \"Bearer \"를 앞에 붙인 Secret를 보내면 token을 받을 수 있다.\n<ul>\n \t<li>URL: /v3/directline/tokens/generate</li>\n \t<li>Method: POST</li>\n \t<li>Header: Authorization: Bearer {secret key}</li>\n \t<li>body : 없음</li>\n</ul>\n<a href=\"/content/images/2016/12/bot-auth-postman.jpg\"><img class=\"aligncenter size-full wp-image-3341\" src=\"/content/images/2016/12/bot-auth-postman.jpg\" alt=\"bot-auth-postman\" width=\"1686\" height=\"864\" /></a>\n\n응답에는 3가지 값이 오는데  우선 이단계에서는 token 만 챙긴다. token은  expires_in 시간이 지나면 무효가 되는데 기본값이 1800초/30분이다. 즉 30분이내에 Refresh 시켜줘야 한다. Refresh 방법은 /v3/directline/tokens/refresh 주소로 POST 전송을 보낼때 헤더에 기존 token을 보내면 된다. 상세 내용은 <a href=\"https://docs.botframework.com/en-us/restapi/directline3/#refreshing-a-token\">Refresh a token</a> 참조\n<h3>대화시작</h3>\n다음 단계는 클라이언트에서 대화를 시작해야 한다.  Auth에서 받은 token을 헤더에 Authentication이라는 헤더로 전달하고 /v3/directline/conversations 주소로 Post Request를 보내면 Auth에서 받은 같은 conversationId 와 새로운 token, streamUrl을 받아온다. 여기서 streamUrl은 웹소켓 URL이다. 이 웹소켓 URL 역시 만료 시간이 있다. 만약 처음 시작한 대화라면 HTTP 201(Created) 응답을 주고 기존 대화라면 200 응답을 준다.\n<ul>\n \t<li>URL: /v3/directline/conversations</li>\n \t<li>Method: POST</li>\n \t<li>Header: Authorization: Bearer {token}</li>\n \t<li>body : 없음</li>\n</ul>\n<a href=\"/content/images/2016/12/bot-start-coversation.jpg\"><img class=\"aligncenter size-full wp-image-3351\" src=\"/content/images/2016/12/bot-start-coversation.jpg\" alt=\"bot-start-coversation\" width=\"1686\" height=\"864\" /></a>\n<pre class=\"prettyprint\">{\n  \"conversationId\": \"JSfqQrtzCDn\",\n  \"token\": \"w9KOqddWUuI.dAA.SgBTAGYAcQBRAHIAdB6AEMARABuAA.sWs_TZNM0gE.oSafVPS2hlU.m2kVr6Zjio_d-Am5cADqbLXHRMB93keAx6_pc7XxPao\",\n  \"expires_in\": 1800,\n  \"streamUrl\": \"wss://directline.botframework.com/v3/directline/conversations/JSfqQrtzCDn/stream?watermark=-&amp;t=w9KOqddWUuI.dAA.SgBTAGYAcQBRAHIAdAB6AEMARABuAA.sX0gQI9M0gE.jEunMa5gKi8.G6GvGGSy6TPSOav8SoNyaJDbIHaCuBrB6hBRRVsoqg8\"\n}</pre>\n<h3>메시지(Activity) 보내기</h3>\n메시지라고 하지 않고 Activity라는 표현을 쓴다. 그 이유는 단순 텍스트 메시지를 보내는 것 외에도 몇가지 타입이 더 있기 때문이다. 메시지를 보내면 응답코드로 상태를 알려주는데 4xx, 5xx 는 오류를 나타내며 성공은 200 상태코드에 보낸 Activity에 ID를 되돌려준다.\n\n프로토콜이 그렇다는 것이고 응답을 받으려면 당연히 응답을 해줄 Bot이 준비되어 있어야 한다. 메시지를 보낼때 Content-Type을 헤더에 써줘야 한다.\n<ul>\n \t<li>URL: /v3/directline/conversations/{conversationId}/activities</li>\n \t<li>Method: POST</li>\n \t<li>Header: Authorization: Bearer {token} / <span style=\"text-decoration: underline;\">Content-Type: application/json</span></li>\n \t<li>body</li>\n</ul>\n<pre class=\"prettyprint\">{\n  \"type\": \"message\",\n  \"from\": {\n    \"id\": \"{대화이름}\"\n  },\n  \"text\": \"안녕하세요!\"\n}</pre>\n<a href=\"/content/images/2016/12/bot-send-message.jpg\"><img class=\"aligncenter size-full wp-image-3381\" src=\"/content/images/2016/12/bot-send-message.jpg\" alt=\"bot-send-message\" width=\"1686\" height=\"993\" /></a>\n<h3>메시지(activity) 받기</h3>\n메시지를 받을 때는 같은 주소로 GET 요청을 하면 된다. 즉시 응답이 오지 않고 시간이 걸린다. 즉, polling을 하면서 메시지를 기다려야 한다.\n<ul>\n \t<li>URL: /v3/directline/conversations/{conversationId}/activities</li>\n \t<li>Method: <span style=\"text-decoration: underline;\"><strong>GET</strong></span></li>\n \t<li>Header: Authorization: Bearer {token}</li>\n</ul>\n응답을 받아보면 아래와 같다. 각 보내고 받은 메시지에도 ID가 부여 된 걸 알 수 있다. 시간과 채널에 대한 정보와 Bot의 이름 정보도 온다.\n<pre class=\"prettyprint\">{\n  \"activities\": [\n    {\n      \"type\": \"message\",\n      \"id\": \"3Dk2pLyFLvc|000000000000000004\",\n      \"timestamp\": \"2016-12-02T12:18:51.0051607Z\",\n      \"channelId\": \"directline\",\n      \"from\": {\n        \"id\": \"ketbotv2\",\n        \"name\": \"ketbotv2\"\n      },\n      \"conversation\": {\n        \"id\": \"3Dk2pLyFLvc\"\n      },\n      \"text\": \"You sent 안녕하세요! which was 6 characters\",\n      \"replyToId\": \"3Dk2pLyFLvc|000000000000000003\"\n    }\n  ],\n  \"watermark\": \"4\"\n}</pre>\n여기서 중요한 값이 하나 오는데 바로 Watermark라는 값이다. 이 값은 메시지를 보낼 때 마다 단순 증가한다. 메시지를 받을 때 GET 요청을 할때 watermark 라는 Query String을 붙여주지 않으면 응답으로 해당 대화의 전체 히스토리를 다 전달 해준다. 메시지를 100번 주고 받았다면 100개의 과거 메시지가 다 전달된다. 이 때 <span style=\"text-decoration: underline;\">Watermark 값을 GET 요청에 Query String으로 전달해 주면 해당 watermark 이후의 메시지만 응답으로</span> 주니 더욱 효율적인 통신을 할 수 있다.\n\n<a href=\"/content/images/2016/12/bot-receive-message.jpg\"><img class=\"aligncenter size-full wp-image-3382\" src=\"/content/images/2016/12/bot-receive-message.jpg\" alt=\"bot-receive-message\" width=\"1686\" height=\"1070\" /></a>\n\n여기까지가 Microsoft Bot Framework의 Direct Line REST API를 이용해서 단순 메시지를 주고 받는 방법이다.\n\n그 외에 <a href=\"https://docs.botframework.com/en-us/restapi/directline3/#/Conversations\">문서</a>를 보면 파일을 업로드 하는 방법과 WebSocket 을 이용하는 방법이 더 소개되어 있다.",
                "html": "<h2>Direct Line REST API</h2>\n<a href=\"https://www.botframework.com/\">Microsoft Bot Framework</a>는 Skype, Facebook Messenger, Slack 등의 다양한 Conversation Channel을 지원하고 있고 그 수가 점점 늘어나고 있다. 하지만 내가 만들 모바일 앱에서 Bot 을 만들고 싶으면 어떤 방법이 있을까? Direct Line이라는 REST API를 지원하기 때문에 우리가 잘 알고 있는 프로그래밍 방법으로 쉽게 Bot 과 연결 시킬 수 있다.<p>즉, 기존에 있는 채널이 아닌 프로그래밍 방식으로 Bot 과 연결 시키고 싶다면 <a href=\"https://docs.botframework.com/en-us/restapi/directline3\">Direct Line API</a>를 사용하면 된다. 실제로 안드로이드 앱에서 Direct Line REST API를 사용하여 Bot에 연결시킨 프로토타입 프로젝트가 Github에 올려져 있다. <a href=\"https://github.com/MadupPinket/ket-bot\">Ket-bot 프로젝트 코드</a>에서 실제 사용한 예를 볼 수 있다.<p><img class=\"alignnone size-large wp-image-3291\" src=\"http://ilseokoh.com/content/images/2016/12/bot-framework-1024x576.jpg\" alt=\"microsoft-bot-framework\" width=\"1008\" height=\"567\" /><p>Bot Connector는 Conversation Channel과 Bot 사이에 존재하는 마이크로소프트가 운영하는 서비스다. 채널은 Bot Connector만 연결해주고 메시지를 주고 받으면 된다. Bot 도 역시 Connector만 보고 메시지를 주고 받는다.<p>현재 최신버전은 3.0이고 <a href=\"https://docs.botframework.com/en-us/restapi/directline3/\">공식 문서</a>에 모든 내용이 나와 있다. 1.1 버전에 비해서 WebSocket을 지원하고 파일 업로드도 지원한다.<p>API 를 이해한 후 C# 개발자라면 <a href=\"https://www.nuget.org/packages/Microsoft.Bot.Connector.DirectLine\">Direct Line Nuget Package</a>를 받아서 활용하면 되고 <a href=\"https://docs.botframework.com/en-us/restapi/directline3/swagger.json\">Swagger file</a> 도 제공하기 때문에 자동으로 클라이언트 코드를 생성해서 빠르게 개발을 할 수 도 있다. 테스트는 REST API이기 때문에  <a href=\"https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop\">Chrome Postman</a>이나 <a href=\"http://www.telerik.com/fiddler\">Fiddler</a> 또는 <a href=\"https://docs.botframework.com/en-us/restapi/directline3/\">공식문서</a> 하단에 있는 Swagger를 이용하면 된다.<p>이 글에서는 (WebSocket이 아닌)HTTP POST로 메시지를 보내고 GET을 Polling해서 응답 메시지를 받는 방법에 대해서 알아보기로 하겠다.\n<h3>Authentication</h3>\n인증과정은 Bot Dev Center에서 생성한 Secret 키를 던지고 token을 받아오는 과정이다. 받아온 token은 오고 가는 메시지의 HTTP 헤더에 넣어서 사용한다. Secret 키는 <a href=\"https://dev.botframework.com/bots/new\">Bot 등록페이지</a>에서 Direct Line 설정 페이지에서 얻을 수 있다.<p><img class=\"alignnone size-large wp-image-3311\" src=\"http://ilseokoh.com/content/images/2016/12/Config-direct-line-1024x540.png\" alt=\"bot-framework-direct-line-secret\" width=\"1008\" height=\"532\" /><p>POST로 https://directline.botframework.com/v3/directline/tokens/generate URL에 Authentication이라는 헤더에 \"Bearer \"를 앞에 붙인 Secret를 보내면 token을 받을 수 있다.\n<ul>\n \t<li>URL: /v3/directline/tokens/generate</li>\n \t<li>Method: POST</li>\n \t<li>Header: Authorization: Bearer {secret key}</li>\n \t<li>body : 없음</li>\n</ul>\n<a href=\"/content/images/2016/12/bot-auth-postman.jpg\"><img class=\"aligncenter size-full wp-image-3341\" src=\"/content/images/2016/12/bot-auth-postman.jpg\" alt=\"bot-auth-postman\" width=\"1686\" height=\"864\" /></a><p>응답에는 3가지 값이 오는데  우선 이단계에서는 token 만 챙긴다. token은  expires_in 시간이 지나면 무효가 되는데 기본값이 1800초/30분이다. 즉 30분이내에 Refresh 시켜줘야 한다. Refresh 방법은 /v3/directline/tokens/refresh 주소로 POST 전송을 보낼때 헤더에 기존 token을 보내면 된다. 상세 내용은 <a href=\"https://docs.botframework.com/en-us/restapi/directline3/#refreshing-a-token\">Refresh a token</a> 참조\n<h3>대화시작</h3>\n다음 단계는 클라이언트에서 대화를 시작해야 한다.  Auth에서 받은 token을 헤더에 Authentication이라는 헤더로 전달하고 /v3/directline/conversations 주소로 Post Request를 보내면 Auth에서 받은 같은 conversationId 와 새로운 token, streamUrl을 받아온다. 여기서 streamUrl은 웹소켓 URL이다. 이 웹소켓 URL 역시 만료 시간이 있다. 만약 처음 시작한 대화라면 HTTP 201(Created) 응답을 주고 기존 대화라면 200 응답을 준다.\n<ul>\n \t<li>URL: /v3/directline/conversations</li>\n \t<li>Method: POST</li>\n \t<li>Header: Authorization: Bearer {token}</li>\n \t<li>body : 없음</li>\n</ul>\n<a href=\"/content/images/2016/12/bot-start-coversation.jpg\"><img class=\"aligncenter size-full wp-image-3351\" src=\"/content/images/2016/12/bot-start-coversation.jpg\" alt=\"bot-start-coversation\" width=\"1686\" height=\"864\" /></a>\n<pre class=\"prettyprint\">{\n  \"conversationId\": \"JSfqQrtzCDn\",\n  \"token\": \"w9KOqddWUuI.dAA.SgBTAGYAcQBRAHIAdB6AEMARABuAA.sWs_TZNM0gE.oSafVPS2hlU.m2kVr6Zjio_d-Am5cADqbLXHRMB93keAx6_pc7XxPao\",\n  \"expires_in\": 1800,\n  \"streamUrl\": \"wss://directline.botframework.com/v3/directline/conversations/JSfqQrtzCDn/stream?watermark=-&amp;t=w9KOqddWUuI.dAA.SgBTAGYAcQBRAHIAdAB6AEMARABuAA.sX0gQI9M0gE.jEunMa5gKi8.G6GvGGSy6TPSOav8SoNyaJDbIHaCuBrB6hBRRVsoqg8\"\n}</pre>\n<h3>메시지(Activity) 보내기</h3>\n메시지라고 하지 않고 Activity라는 표현을 쓴다. 그 이유는 단순 텍스트 메시지를 보내는 것 외에도 몇가지 타입이 더 있기 때문이다. 메시지를 보내면 응답코드로 상태를 알려주는데 4xx, 5xx 는 오류를 나타내며 성공은 200 상태코드에 보낸 Activity에 ID를 되돌려준다.<p>프로토콜이 그렇다는 것이고 응답을 받으려면 당연히 응답을 해줄 Bot이 준비되어 있어야 한다. 메시지를 보낼때 Content-Type을 헤더에 써줘야 한다.\n<ul>\n \t<li>URL: /v3/directline/conversations/{conversationId}/activities</li>\n \t<li>Method: POST</li>\n \t<li>Header: Authorization: Bearer {token} / <span style=\"text-decoration: underline;\">Content-Type: application/json</span></li>\n \t<li>body</li>\n</ul>\n<pre class=\"prettyprint\">{\n  \"type\": \"message\",\n  \"from\": {\n    \"id\": \"{대화이름}\"\n  },\n  \"text\": \"안녕하세요!\"\n}</pre>\n<a href=\"/content/images/2016/12/bot-send-message.jpg\"><img class=\"aligncenter size-full wp-image-3381\" src=\"/content/images/2016/12/bot-send-message.jpg\" alt=\"bot-send-message\" width=\"1686\" height=\"993\" /></a>\n<h3>메시지(activity) 받기</h3>\n메시지를 받을 때는 같은 주소로 GET 요청을 하면 된다. 즉시 응답이 오지 않고 시간이 걸린다. 즉, polling을 하면서 메시지를 기다려야 한다.\n<ul>\n \t<li>URL: /v3/directline/conversations/{conversationId}/activities</li>\n \t<li>Method: <span style=\"text-decoration: underline;\"><strong>GET</strong></span></li>\n \t<li>Header: Authorization: Bearer {token}</li>\n</ul>\n응답을 받아보면 아래와 같다. 각 보내고 받은 메시지에도 ID가 부여 된 걸 알 수 있다. 시간과 채널에 대한 정보와 Bot의 이름 정보도 온다.\n<pre class=\"prettyprint\">{\n  \"activities\": [\n    {\n      \"type\": \"message\",\n      \"id\": \"3Dk2pLyFLvc|000000000000000004\",\n      \"timestamp\": \"2016-12-02T12:18:51.0051607Z\",\n      \"channelId\": \"directline\",\n      \"from\": {\n        \"id\": \"ketbotv2\",\n        \"name\": \"ketbotv2\"\n      },\n      \"conversation\": {\n        \"id\": \"3Dk2pLyFLvc\"\n      },\n      \"text\": \"You sent 안녕하세요! which was 6 characters\",\n      \"replyToId\": \"3Dk2pLyFLvc|000000000000000003\"\n    }\n  ],\n  \"watermark\": \"4\"\n}</pre>\n여기서 중요한 값이 하나 오는데 바로 Watermark라는 값이다. 이 값은 메시지를 보낼 때 마다 단순 증가한다. 메시지를 받을 때 GET 요청을 할때 watermark 라는 Query String을 붙여주지 않으면 응답으로 해당 대화의 전체 히스토리를 다 전달 해준다. 메시지를 100번 주고 받았다면 100개의 과거 메시지가 다 전달된다. 이 때 <span style=\"text-decoration: underline;\">Watermark 값을 GET 요청에 Query String으로 전달해 주면 해당 watermark 이후의 메시지만 응답으로</span> 주니 더욱 효율적인 통신을 할 수 있다.<p><a href=\"/content/images/2016/12/bot-receive-message.jpg\"><img class=\"aligncenter size-full wp-image-3382\" src=\"/content/images/2016/12/bot-receive-message.jpg\" alt=\"bot-receive-message\" width=\"1686\" height=\"1070\" /></a><p>여기까지가 Microsoft Bot Framework의 Direct Line REST API를 이용해서 단순 메시지를 주고 받는 방법이다.<p>그 외에 <a href=\"https://docs.botframework.com/en-us/restapi/directline3/#/Conversations\">문서</a>를 보면 파일을 업로드 하는 방법과 WebSocket 을 이용하는 방법이 더 소개되어 있다.",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1480682914000,
                "created_by": 1,
                "updated_at": 1480682914000,
                "updated_by": 1,
                "published_at": 1480682914000,
                "published_by": 1
            },
            {
                "id": 3421,
                "title": "[Microsoft Bot Framework] Dialog를 사용하여 대화의 흐름 만들기",
                "slug": "microsoft-bot-framework-dialog",
                "markdown": "<span style=\"font-size: 18px;\">대화에는 맥락이라는 것이 있다.  어떤 주제에 대해서 대화들은 같은 맥락 안에서 대화가 이어진다. Bot 을 만들 때도 같은 맥락 안에서 사용자와 Bot간의 대화가 이어져 나가는 방식으로 구현이 된다. 피자를 주문하는 Bot은 피자 주문이라는 맥락에서 크기, 토핑 종류, 음료 등을 물어보고 답을 할 것이다. </span>\n\n<span style=\"font-size: 18px;\">Microsoft Bot Framework에서는 Bot과 사용자 사이의 대화를 만드는 기본 모델이 Dialog 이다. Dialog를 통해서 반복되는 특정 대화를 모듈화해서 재사용성을 높이고 여러 Dialog를 체인 형식으로 연결시켜서 맥락을 이어가도록 프로그래밍 할 수 있다. </span>\n\n<a href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/dialogs.html\">Dialogs 에 대한 공식 문서</a>는 docs.botframework.com 에 있다.\n\nBot framework builder에 이미 만들어져 있는 Dialog들이 있다. 이 Dialog들과 내가 만든 Dialog를 연결하면 좋은 구조를 만들 수 있다.\n<ul>\n \t<li><a href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/d9/d03/class_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_prompt_dialog.html\">PromptDialog</a>: 사용자의 응답 메시지를 기다리는 Dialog로 여러 버전이 있다. <a class=\"el\" href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/d5/d9a/class_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_prompt_dialog_1_1_prompt_attachment.html\">PromptAttachment</a>, <a class=\"el\" href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/dc/df9/class_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_prompt_dialog_1_1_prompt_choice.html\">PromptChoice</a>, <a class=\"el\" href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/dd/d7e/class_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_prompt_dialog_1_1_prompt_confirm.html\">PromptConfirm</a>, <a class=\"el\" href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/d9/d63/class_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_prompt_dialog_1_1_prompt_double.html\">PromptDouble</a>, <a class=\"el\" href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/d4/d27/class_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_prompt_dialog_1_1_prompt_int64.html\">PromptInt64</a>, <a class=\"el\" href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/d3/d39/class_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_prompt_dialog_1_1_prompt_string.html\">PromptString</a>. 예를들어 PromptInt64는 정수형 숫자만 입력 받고 숫자가 아닌 경우는 다시 물어본다.</li>\n \t<li><a class=\"el\" href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/d8/df9/class_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_luis_dialog.html\">LuisDialog</a>: Microsoft의 Cognitive Service 중 자연어 처리를 담당하는 LUIS(Language Understanding Intelligent Service)를 연결해서 대화를 만들어 낼 수 있는 클래스</li>\n \t<li><a class=\"el\" href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/dc/dab/class_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_command_dialog.html\">CommandDialog</a>: 정규표현식이 Match 를 이용하는 Dialog</li>\n</ul>\n<h2>Custom Dialog 만들기</h2>\nStartAsync라는 메서드가 정의되어 있는 <a href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/dd/d5e/interface_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_i_dialog.html\">IDialog</a>를 구현하면 된다.\n<pre class=\"prettyprint\">public async Task StartAsync(IDialogContext context)\n{\n    context.Wait(MessageReceivedAsync);\n}\n\npublic virtual async Task MessageReceivedAsync(IDialogContext context, IAwaitable&lt;IMessageActivity&gt; argument)\n{\n    using (CommentService service = new CommentService(new KetBotContext()))\n    {\n        var activity = await argument;\n\n        // get state \n        KetBotState state = null;\n        context.ConversationData.TryGetValue(\"KetBotState\", out state);\n\n        var cat3 = await service.GetFormsAsync(state.Stage1Selection);\n\n        bool checkflag = false;\n        int selected;\n        if (int.TryParse(activity.Text, out selected) &amp;&amp; selected &gt; 0 &amp;&amp; selected &lt;= cat3.Count)\n        {\n          checkflag = true;\n        }\n\n if (checkflag == true)\n {\n     // save Stage1 selection\n     state.Stage2Selection = activity.Text;\n     // save state\n     context.ConversationData.SetValue(\"KetBotState\", state);\n\n     // final answers \n     var answers = await service.GetAnswerAsync(state.Stage0Selection + state.Stage1Selection + state.Stage2Selection);\n     await context.PostAsync(string.Join(\"\\n\", answers.ToArray()));\n\n     var q = await service.GetCommentAsync(\"RCB02\");\n     List&lt;string&gt; yesno = new List&lt;string&gt;() { \"네, 맞아요!\", \"아닌데요?\" };\n\n     PromptDialog.Choice(context, AfterChoiceAsync, yesno, q, promptStyle: PromptStyle.Keyboard);\n }\n else\n {\n     // Go back to stage 2\n     await context.PostAsync(await service.GetCommentAsync(\"REB01\"));\n     await context.PostAsync(string.Join(\"\\n\", cat3.ToArray()));\n     context.Wait(MessageReceivedAsync);\n  }\n }\n}</pre>\nDialog 안에서는 PINKET Bot의 <a href=\"https://github.com/MadupPinket/ket-bot/blob/master/bot/KetBot/KetBot/Dialogs/Stage3Dialog.cs\">Stage3Dialog.cs</a> 코드처럼\n<ul>\n \t<li>context.PostAsync()로 사용자에게 메시지를 즉시 전송하거나</li>\n \t<li>context.Wait(MessageReceivedAsync)로 사용자로 부터 메시지를 받을 때 까지 기다리거나</li>\n \t<li>PromptDialog를 통해서 형식화된 메시지를 주고 받거나</li>\n \t<li>context.Done(<span class=\"pl-s\"><span class=\"pl-pds\">\"some text)를 호출하면 체인으로 연결된 다음 Dialog가 Active 된다. </span></span></li>\n</ul>\n<h2>Dialog Chain</h2>\nDialog들을 체인으로 연결시켜서 또 다른 Dialog를 만들 수 있다. 내부적으로 DialogStack에 순서를 관리하며 연결을 위한 다양한 <a href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/dialogs.html#Fluent\">Chain Method</a>를 Fluent API로 지원한다.\n<h2>Dialog Chain 샘플코드</h2>\n<ul>\n \t<li>Bot Framework Sample Code 중에 <a href=\"https://github.com/Microsoft/BotBuilder/blob/master/CSharp/Samples/EchoBot/EchoChainDialog.cs\">EchoChainBot </a></li>\n \t<li>FINKET Bot의 소스코드의 <a href=\"https://github.com/MadupPinket/ket-bot/blob/master/bot/KetBot/KetBot/Dialogs/KetBotChainDialog.cs\">KetBotChainDialog</a></li>\n \t<li><a href=\"https://github.com/Microsoft/BotBuilder/blob/master/CSharp/Samples/SimpleFacebookAuthBot/SimpleFacebookAuthDialog.cs\">SimpleFacebookAuthBot</a></li>\n</ul>\nEchoChainBot의 코드를 살펴보면\n<pre class=\"prettyprint\">public static readonly IDialog&lt;string&gt; dialog = Chain.PostToChain()\n .Select(msg =&gt; msg.Text)\n .Switch(\n new Case&lt;string, IDialog&lt;string&gt;&gt;(text =&gt;\n {\n     var regex = new Regex(\"^reset\");\n     return regex.Match(text).Success;\n }, (context, txt) =&gt;\n {\n     return Chain.From(() =&gt; new PromptDialog.PromptConfirm(\"Are you sure you want to reset the count?\",\n     \"Didn't get that!\", 3, PromptStyle.Keyboard)).ContinueWith&lt;bool, string&gt;(async (ctx, res) =&gt;\n {\n string reply;\n if (await res)\n {\n     ctx.UserData.SetValue(\"count\", 0);\n     reply = \"Reset count.\";\n }\n else\n {\n     reply = \"Did not reset count.\";\n }\n return Chain.Return(reply);\n });\n }),\n     new RegexCase&lt;IDialog&lt;string&gt;&gt;(new Regex(\"^help\", RegexOptions.IgnoreCase), (context, txt) =&gt;\n     {\n   return Chain.Return(\"I am a simple echo dialog with a counter! Reset my counter by typing \\\"reset\\\"!\");\n }),\n new DefaultCase&lt;string, IDialog&lt;string&gt;&gt;((context, txt) =&gt;\n {\n int count;\n context.UserData.TryGetValue(\"count\", out count);\n context.UserData.SetValue(\"count\", ++count);\n string reply = string.Format(\"{0}: You said {1}\", count, txt);\n return Chain.Return(reply);\n }))\n .Unwrap()\n .PostToUser();</pre>\n<ul>\n \t<li>Chain.PostToChain() 로 사용자의 메시지로 부터 Chain이 시작되고</li>\n \t<li>Select(msg =&gt; msg.Text) DialogContext에서 Message 부분만 Select 하고</li>\n \t<li>.Switch(<span class=\"pl-k\">new</span> Case&lt;<span class=\"pl-k\">string</span>, IDialog&lt;<span class=\"pl-k\">string</span>&gt;&gt; ...) 에서 메시지가 Match 되면 Callback 메서드가 실행된다.</li>\n \t<li>Switch 에서  RegexCase&lt;IDialog&lt;<span class=\"pl-k\">string</span>&gt;&gt;() 정규표현식을 사용할 수도 있고</li>\n \t<li>매칭이 없으면 DefaultCase가 실행된다.</li>\n \t<li>마지막으로 Unwarp()과 PostToUser()로 체인을 끝낸다.</li>\n</ul>\n이런식으로 Dialog를 연결해서 한 묶음의 대화를 완성한 예제가<a href=\"https://github.com/MadupPinket/ket-bot\"> PINKET Bot</a> 이다. Dialog를 체인으로 엮어서 대화를 만드는 부분을 참조해 볼만하다.",
                "html": "<span style=\"font-size: 18px;\">대화에는 맥락이라는 것이 있다.  어떤 주제에 대해서 대화들은 같은 맥락 안에서 대화가 이어진다. Bot 을 만들 때도 같은 맥락 안에서 사용자와 Bot간의 대화가 이어져 나가는 방식으로 구현이 된다. 피자를 주문하는 Bot은 피자 주문이라는 맥락에서 크기, 토핑 종류, 음료 등을 물어보고 답을 할 것이다. </span><p><span style=\"font-size: 18px;\">Microsoft Bot Framework에서는 Bot과 사용자 사이의 대화를 만드는 기본 모델이 Dialog 이다. Dialog를 통해서 반복되는 특정 대화를 모듈화해서 재사용성을 높이고 여러 Dialog를 체인 형식으로 연결시켜서 맥락을 이어가도록 프로그래밍 할 수 있다. </span><p><a href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/dialogs.html\">Dialogs 에 대한 공식 문서</a>는 docs.botframework.com 에 있다.<p>Bot framework builder에 이미 만들어져 있는 Dialog들이 있다. 이 Dialog들과 내가 만든 Dialog를 연결하면 좋은 구조를 만들 수 있다.\n<ul>\n \t<li><a href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/d9/d03/class_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_prompt_dialog.html\">PromptDialog</a>: 사용자의 응답 메시지를 기다리는 Dialog로 여러 버전이 있다. <a class=\"el\" href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/d5/d9a/class_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_prompt_dialog_1_1_prompt_attachment.html\">PromptAttachment</a>, <a class=\"el\" href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/dc/df9/class_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_prompt_dialog_1_1_prompt_choice.html\">PromptChoice</a>, <a class=\"el\" href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/dd/d7e/class_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_prompt_dialog_1_1_prompt_confirm.html\">PromptConfirm</a>, <a class=\"el\" href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/d9/d63/class_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_prompt_dialog_1_1_prompt_double.html\">PromptDouble</a>, <a class=\"el\" href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/d4/d27/class_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_prompt_dialog_1_1_prompt_int64.html\">PromptInt64</a>, <a class=\"el\" href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/d3/d39/class_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_prompt_dialog_1_1_prompt_string.html\">PromptString</a>. 예를들어 PromptInt64는 정수형 숫자만 입력 받고 숫자가 아닌 경우는 다시 물어본다.</li>\n \t<li><a class=\"el\" href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/d8/df9/class_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_luis_dialog.html\">LuisDialog</a>: Microsoft의 Cognitive Service 중 자연어 처리를 담당하는 LUIS(Language Understanding Intelligent Service)를 연결해서 대화를 만들어 낼 수 있는 클래스</li>\n \t<li><a class=\"el\" href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/dc/dab/class_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_command_dialog.html\">CommandDialog</a>: 정규표현식이 Match 를 이용하는 Dialog</li>\n</ul>\n<h2>Custom Dialog 만들기</h2>\nStartAsync라는 메서드가 정의되어 있는 <a href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/dd/d5e/interface_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_i_dialog.html\">IDialog</a>를 구현하면 된다.\n<pre class=\"prettyprint\">public async Task StartAsync(IDialogContext context)\n{\n    context.Wait(MessageReceivedAsync);\n}<p>public virtual async Task MessageReceivedAsync(IDialogContext context, IAwaitable&lt;IMessageActivity&gt; argument)\n{\n    using (CommentService service = new CommentService(new KetBotContext()))\n    {\n        var activity = await argument;<p>        // get state \n        KetBotState state = null;\n        context.ConversationData.TryGetValue(\"KetBotState\", out state);<p>        var cat3 = await service.GetFormsAsync(state.Stage1Selection);<p>        bool checkflag = false;\n        int selected;\n        if (int.TryParse(activity.Text, out selected) &amp;&amp; selected &gt; 0 &amp;&amp; selected &lt;= cat3.Count)\n        {\n          checkflag = true;\n        }<p> if (checkflag == true)\n {\n     // save Stage1 selection\n     state.Stage2Selection = activity.Text;\n     // save state\n     context.ConversationData.SetValue(\"KetBotState\", state);<p>     // final answers \n     var answers = await service.GetAnswerAsync(state.Stage0Selection + state.Stage1Selection + state.Stage2Selection);\n     await context.PostAsync(string.Join(\"\\n\", answers.ToArray()));<p>     var q = await service.GetCommentAsync(\"RCB02\");\n     List&lt;string&gt; yesno = new List&lt;string&gt;() { \"네, 맞아요!\", \"아닌데요?\" };<p>     PromptDialog.Choice(context, AfterChoiceAsync, yesno, q, promptStyle: PromptStyle.Keyboard);\n }\n else\n {\n     // Go back to stage 2\n     await context.PostAsync(await service.GetCommentAsync(\"REB01\"));\n     await context.PostAsync(string.Join(\"\\n\", cat3.ToArray()));\n     context.Wait(MessageReceivedAsync);\n  }\n }\n}</pre>\nDialog 안에서는 PINKET Bot의 <a href=\"https://github.com/MadupPinket/ket-bot/blob/master/bot/KetBot/KetBot/Dialogs/Stage3Dialog.cs\">Stage3Dialog.cs</a> 코드처럼\n<ul>\n \t<li>context.PostAsync()로 사용자에게 메시지를 즉시 전송하거나</li>\n \t<li>context.Wait(MessageReceivedAsync)로 사용자로 부터 메시지를 받을 때 까지 기다리거나</li>\n \t<li>PromptDialog를 통해서 형식화된 메시지를 주고 받거나</li>\n \t<li>context.Done(<span class=\"pl-s\"><span class=\"pl-pds\">\"some text)를 호출하면 체인으로 연결된 다음 Dialog가 Active 된다. </span></span></li>\n</ul>\n<h2>Dialog Chain</h2>\nDialog들을 체인으로 연결시켜서 또 다른 Dialog를 만들 수 있다. 내부적으로 DialogStack에 순서를 관리하며 연결을 위한 다양한 <a href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/dialogs.html#Fluent\">Chain Method</a>를 Fluent API로 지원한다.\n<h2>Dialog Chain 샘플코드</h2>\n<ul>\n \t<li>Bot Framework Sample Code 중에 <a href=\"https://github.com/Microsoft/BotBuilder/blob/master/CSharp/Samples/EchoBot/EchoChainDialog.cs\">EchoChainBot </a></li>\n \t<li>FINKET Bot의 소스코드의 <a href=\"https://github.com/MadupPinket/ket-bot/blob/master/bot/KetBot/KetBot/Dialogs/KetBotChainDialog.cs\">KetBotChainDialog</a></li>\n \t<li><a href=\"https://github.com/Microsoft/BotBuilder/blob/master/CSharp/Samples/SimpleFacebookAuthBot/SimpleFacebookAuthDialog.cs\">SimpleFacebookAuthBot</a></li>\n</ul>\nEchoChainBot의 코드를 살펴보면\n<pre class=\"prettyprint\">public static readonly IDialog&lt;string&gt; dialog = Chain.PostToChain()\n .Select(msg =&gt; msg.Text)\n .Switch(\n new Case&lt;string, IDialog&lt;string&gt;&gt;(text =&gt;\n {\n     var regex = new Regex(\"^reset\");\n     return regex.Match(text).Success;\n }, (context, txt) =&gt;\n {\n     return Chain.From(() =&gt; new PromptDialog.PromptConfirm(\"Are you sure you want to reset the count?\",\n     \"Didn't get that!\", 3, PromptStyle.Keyboard)).ContinueWith&lt;bool, string&gt;(async (ctx, res) =&gt;\n {\n string reply;\n if (await res)\n {\n     ctx.UserData.SetValue(\"count\", 0);\n     reply = \"Reset count.\";\n }\n else\n {\n     reply = \"Did not reset count.\";\n }\n return Chain.Return(reply);\n });\n }),\n     new RegexCase&lt;IDialog&lt;string&gt;&gt;(new Regex(\"^help\", RegexOptions.IgnoreCase), (context, txt) =&gt;\n     {\n   return Chain.Return(\"I am a simple echo dialog with a counter! Reset my counter by typing \\\"reset\\\"!\");\n }),\n new DefaultCase&lt;string, IDialog&lt;string&gt;&gt;((context, txt) =&gt;\n {\n int count;\n context.UserData.TryGetValue(\"count\", out count);\n context.UserData.SetValue(\"count\", ++count);\n string reply = string.Format(\"{0}: You said {1}\", count, txt);\n return Chain.Return(reply);\n }))\n .Unwrap()\n .PostToUser();</pre>\n<ul>\n \t<li>Chain.PostToChain() 로 사용자의 메시지로 부터 Chain이 시작되고</li>\n \t<li>Select(msg =&gt; msg.Text) DialogContext에서 Message 부분만 Select 하고</li>\n \t<li>.Switch(<span class=\"pl-k\">new</span> Case&lt;<span class=\"pl-k\">string</span>, IDialog&lt;<span class=\"pl-k\">string</span>&gt;&gt; ...) 에서 메시지가 Match 되면 Callback 메서드가 실행된다.</li>\n \t<li>Switch 에서  RegexCase&lt;IDialog&lt;<span class=\"pl-k\">string</span>&gt;&gt;() 정규표현식을 사용할 수도 있고</li>\n \t<li>매칭이 없으면 DefaultCase가 실행된다.</li>\n \t<li>마지막으로 Unwarp()과 PostToUser()로 체인을 끝낸다.</li>\n</ul>\n이런식으로 Dialog를 연결해서 한 묶음의 대화를 완성한 예제가<a href=\"https://github.com/MadupPinket/ket-bot\"> PINKET Bot</a> 이다. Dialog를 체인으로 엮어서 대화를 만드는 부분을 참조해 볼만하다.",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1480910440000,
                "created_by": 1,
                "updated_at": 1480910440000,
                "updated_by": 1,
                "published_at": 1480910440000,
                "published_by": 1
            },
            {
                "id": 3511,
                "title": "[Microsoft Bot Framework] 상태저장을 위한 Bot State Service",
                "slug": "microsoft-bot-framework-%ec%83%81%ed%83%9c%ec%a0%80%ec%9e%a5%ec%9d%84-%ec%9c%84%ed%95%9c-bot-state-service",
                "markdown": "Bot State Service가 2018년 3월 31일부로 문을 닫는다고 합니다. 블로그 내용 참조 바랍니다.\n\nhttps://blog.botframework.com/2017/12/19/bot-state-service-will-soon-retired-march-31st-2018/\n\n&nbsp;\n\n우리가 카카오톡과 같은 메신저를 사용하다 보면 상대방의 질문에 즉시 답하지 못하고 몇 시간이 지난 후에 답을 주는 경우가 있다. 그렇다고 마지막 대화 내용을 놓치지 않고 답을 해줄 수 있다.  Bot 서비스도 역시 Bot이 사용자에게 질문을 던진다면 그 상태를 계속 유지해 줘야한다.\n\n이런 상태 정보를 분리되고 공유된 공간이 아닌 메모리등의 로컬 자원에 의지를 하면 서비스를 확장하는데 문제가 생긴다. 즉, Bot도 기본적으로는 웹 서비스로 구현되기 때문에 서비스 확장에 대비해서 Stateless 로 구현되어야 한다. Microsoft Bot Framework는 이런 상태를 저장하는 공간을 Bot State Service로 제공한다.\n<h2>State 저장소를 구분하기 위한 기본 정보</h2>\n사용자와 Bot간의 메시지는 Activity라고 부르는데(Message 외에도 여러 타입이 있다) 다음과 같은 상태정보와 함께 움직인다. 이 값을 이용해서 특정 대화, 특정 사용자, 특정 대화에서 특정 사용자를 구분해 낼 수 있다. 이 3가지를 이용해서 각 Context에 맞는 데이터 저장소를 만들어서 저장 할 수 있다.\n<ul>\n \t<li>From: 어떤 채널(Skrype같은)에서 특정 사용자 아이디. 사용자 단위의 데이터를 저장 할 때.</li>\n \t<li>Conversation: 특정 대화를 구분하는 ID. 대화에는 여러 User가 포함되어 있을 수 있다. 모든 사용자가 같이 공유할 데이터.</li>\n \t<li>From + Conversation : 특정 대화에서 특정 사용자를 위한 저장공간 구분.</li>\n</ul>\n<h2>State 메서드</h2>\n이 3가지 구분에 의해서 State를 저장하고 가져오는 State 메서드도 3가지로 구분이 된다. 저장되는 데이터는 32 kbyte 보다 작아야 한다.\n<ul>\n \t<li>데이터 가져오기\n<ul>\n \t<li>GetUserData()</li>\n \t<li>GetConversationData()</li>\n \t<li>GetPrivateConversationData()</li>\n</ul>\n</li>\n \t<li>데이터 저장\n<ul>\n \t<li>SetUserData()</li>\n \t<li>SetConversationData()</li>\n \t<li>SetPrivateConversationData()</li>\n</ul>\n</li>\n</ul>\n<h2>IDialogContext.CoversationData</h2>\nBot State Service에 설명되어 있는 Bot State Service의 State Client 보다 <a href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/d1/dc6/interface_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_i_dialog_context.html\">IDialogContext</a> 의 헬퍼 프로퍼티를 사용하면 편리하다.\n\nIDialog를 사용하면 항상 <a href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/d1/dc6/interface_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_i_dialog_context.html\">IDialogContext</a>가 따라다니는데 <a href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/db/d9b/interface_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_internals_1_1_i_bot_data.html#ab32e7cf57ecf897949438ba2573aa54a\">CoversationData</a>, <a href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/db/d9b/interface_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_internals_1_1_i_bot_data.html#afc4166d3d31f3402aa962e48cd1a8f3c\">PrivateConversationData</a>, <a href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/db/d9b/interface_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_internals_1_1_i_bot_data.html#a5fd2f3a1c9280a13aa65dd2b3add257b\">UserData</a> 이렇게 3개의 속성을 제공한다. 이 3개 속성에 구현된 <a href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/d7/dea/interface_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_i_bot_data_bag.html\">IBotDataBag</a> 메서드를 사용하면 쉽게 State를 관리할 수 있다.\n<pre class=\"prettyprint\">[Serializable]\npublic class Stage2Dialog : IDialog&lt;string&gt;\n{\n   public async Task StartAsync(IDialogContext context)\n   {\n        // get state \n        KetBotState state = null;\n        context.ConversationData.TryGetValue(\"KetBotState\", out state);\n        if (KetBotState == null) return;\n\n        // save state\n        context.ConversationData.SetValue(\"KetBotState\", state);\n   }\n}</pre>\n예제로서 <a href=\"https://github.com/MadupPinket/ket-bot\">PINKET Bot</a> 에서는 3가지의 선택지를 사용자에게 물어보고 최종 질문을 찾는 과정에서 3가지 질문의 답변을 State에 저장하면서 대화가 진행되다가 최종 질문이 확인되면 3가지 질문에 대한 답을 조합해서 최종 답변을 찾아 사용자에게 전달한다.",
                "html": "Bot State Service가 2018년 3월 31일부로 문을 닫는다고 합니다. 블로그 내용 참조 바랍니다.<p>https://blog.botframework.com/2017/12/19/bot-state-service-will-soon-retired-march-31st-2018/<p>&nbsp;<p>우리가 카카오톡과 같은 메신저를 사용하다 보면 상대방의 질문에 즉시 답하지 못하고 몇 시간이 지난 후에 답을 주는 경우가 있다. 그렇다고 마지막 대화 내용을 놓치지 않고 답을 해줄 수 있다.  Bot 서비스도 역시 Bot이 사용자에게 질문을 던진다면 그 상태를 계속 유지해 줘야한다.<p>이런 상태 정보를 분리되고 공유된 공간이 아닌 메모리등의 로컬 자원에 의지를 하면 서비스를 확장하는데 문제가 생긴다. 즉, Bot도 기본적으로는 웹 서비스로 구현되기 때문에 서비스 확장에 대비해서 Stateless 로 구현되어야 한다. Microsoft Bot Framework는 이런 상태를 저장하는 공간을 Bot State Service로 제공한다.\n<h2>State 저장소를 구분하기 위한 기본 정보</h2>\n사용자와 Bot간의 메시지는 Activity라고 부르는데(Message 외에도 여러 타입이 있다) 다음과 같은 상태정보와 함께 움직인다. 이 값을 이용해서 특정 대화, 특정 사용자, 특정 대화에서 특정 사용자를 구분해 낼 수 있다. 이 3가지를 이용해서 각 Context에 맞는 데이터 저장소를 만들어서 저장 할 수 있다.\n<ul>\n \t<li>From: 어떤 채널(Skrype같은)에서 특정 사용자 아이디. 사용자 단위의 데이터를 저장 할 때.</li>\n \t<li>Conversation: 특정 대화를 구분하는 ID. 대화에는 여러 User가 포함되어 있을 수 있다. 모든 사용자가 같이 공유할 데이터.</li>\n \t<li>From + Conversation : 특정 대화에서 특정 사용자를 위한 저장공간 구분.</li>\n</ul>\n<h2>State 메서드</h2>\n이 3가지 구분에 의해서 State를 저장하고 가져오는 State 메서드도 3가지로 구분이 된다. 저장되는 데이터는 32 kbyte 보다 작아야 한다.\n<ul>\n \t<li>데이터 가져오기\n<ul>\n \t<li>GetUserData()</li>\n \t<li>GetConversationData()</li>\n \t<li>GetPrivateConversationData()</li>\n</ul>\n</li>\n \t<li>데이터 저장\n<ul>\n \t<li>SetUserData()</li>\n \t<li>SetConversationData()</li>\n \t<li>SetPrivateConversationData()</li>\n</ul>\n</li>\n</ul>\n<h2>IDialogContext.CoversationData</h2>\nBot State Service에 설명되어 있는 Bot State Service의 State Client 보다 <a href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/d1/dc6/interface_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_i_dialog_context.html\">IDialogContext</a> 의 헬퍼 프로퍼티를 사용하면 편리하다.<p>IDialog를 사용하면 항상 <a href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/d1/dc6/interface_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_i_dialog_context.html\">IDialogContext</a>가 따라다니는데 <a href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/db/d9b/interface_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_internals_1_1_i_bot_data.html#ab32e7cf57ecf897949438ba2573aa54a\">CoversationData</a>, <a href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/db/d9b/interface_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_internals_1_1_i_bot_data.html#afc4166d3d31f3402aa962e48cd1a8f3c\">PrivateConversationData</a>, <a href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/db/d9b/interface_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_internals_1_1_i_bot_data.html#a5fd2f3a1c9280a13aa65dd2b3add257b\">UserData</a> 이렇게 3개의 속성을 제공한다. 이 3개 속성에 구현된 <a href=\"https://docs.botframework.com/en-us/csharp/builder/sdkreference/d7/dea/interface_microsoft_1_1_bot_1_1_builder_1_1_dialogs_1_1_i_bot_data_bag.html\">IBotDataBag</a> 메서드를 사용하면 쉽게 State를 관리할 수 있다.\n<pre class=\"prettyprint\">[Serializable]\npublic class Stage2Dialog : IDialog&lt;string&gt;\n{\n   public async Task StartAsync(IDialogContext context)\n   {\n        // get state \n        KetBotState state = null;\n        context.ConversationData.TryGetValue(\"KetBotState\", out state);\n        if (KetBotState == null) return;<p>        // save state\n        context.ConversationData.SetValue(\"KetBotState\", state);\n   }\n}</pre>\n예제로서 <a href=\"https://github.com/MadupPinket/ket-bot\">PINKET Bot</a> 에서는 3가지의 선택지를 사용자에게 물어보고 최종 질문을 찾는 과정에서 3가지 질문의 답변을 State에 저장하면서 대화가 진행되다가 최종 질문이 확인되면 3가지 질문에 대한 답을 조합해서 최종 답변을 찾아 사용자에게 전달한다.",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1481346620000,
                "created_by": 1,
                "updated_at": 1481346620000,
                "updated_by": 1,
                "published_at": 1481346620000,
                "published_by": 1
            },
            {
                "id": 3571,
                "title": "블루투스 뮤직 리시버",
                "slug": "%eb%b8%94%eb%a3%a8%ed%88%ac%ec%8a%a4-%eb%ae%a4%ec%a7%81-%eb%a6%ac%ec%8b%9c%eb%b2%84",
                "markdown": "10년전에 구매했고 지금도 잘 쓰고 있는 스피커가 있다. 접촉 불량도 좀있고 하지만 여전히 명품이지만 한가지 아쉬운 점이 있다. 블루투스가 아쉽다. 무선의 맛을 한번 봤으니 되돌아 갈 수도 없고 모든 음악은 스마트폰에 있으니 여간 불편한게 아니다. 그래서 잘 안쓰게되고 IT 매장을 가면 스피커를 만지작 거리기도 했다.\n\n그래서 구입한 블루투스 리시버가 이 불편함을 해소해 줬다.연결 잘 되고 음질도 뭐 괜찮고 .... 벨킨 블루투스 뮤직 리시버 F8Z492krP 약 3만 5천원.\n\n다시 거실에 음악이 퍼진다.\n<a href=\"/content/images/2016/12/IMG_8045.jpg\"><img class=\"aligncenter size-full wp-image-3591\" src=\"/content/images/2016/12/IMG_8045.jpg\" alt=\"\" width=\"2960\" height=\"2379\" /></a>",
                "html": "10년전에 구매했고 지금도 잘 쓰고 있는 스피커가 있다. 접촉 불량도 좀있고 하지만 여전히 명품이지만 한가지 아쉬운 점이 있다. 블루투스가 아쉽다. 무선의 맛을 한번 봤으니 되돌아 갈 수도 없고 모든 음악은 스마트폰에 있으니 여간 불편한게 아니다. 그래서 잘 안쓰게되고 IT 매장을 가면 스피커를 만지작 거리기도 했다.<p>그래서 구입한 블루투스 리시버가 이 불편함을 해소해 줬다.연결 잘 되고 음질도 뭐 괜찮고 .... 벨킨 블루투스 뮤직 리시버 F8Z492krP 약 3만 5천원.<p>다시 거실에 음악이 퍼진다.\n<a href=\"/content/images/2016/12/IMG_8045.jpg\"><img class=\"aligncenter size-full wp-image-3591\" src=\"/content/images/2016/12/IMG_8045.jpg\" alt=\"\" width=\"2960\" height=\"2379\" /></a>",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1481346473000,
                "created_by": 1,
                "updated_at": 1481346473000,
                "updated_by": 1,
                "published_at": 1481346473000,
                "published_by": 1
            },
            {
                "id": 3651,
                "title": "LEGO Technic 42032",
                "slug": "lego-technic-42032",
                "markdown": "LEGO Technic 42032\n\n&nbsp;",
                "html": "LEGO Technic 42032<p>&nbsp;",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1481366017000,
                "created_by": 1,
                "updated_at": 1481366017000,
                "updated_by": 1,
                "published_at": 1481366017000,
                "published_by": 1
            },
            {
                "id": 3731,
                "title": "미키/미니 마우스 블록 만들기 타임랩스",
                "slug": "%eb%af%b8%ed%82%a4%eb%af%b8%eb%8b%88-%eb%a7%88%ec%9a%b0%ec%8a%a4-%eb%b8%94%eb%a1%9d-%eb%a7%8c%eb%93%a4%ea%b8%b0-%ed%83%80%ec%9e%84%eb%9e%a9%ec%8a%a4",
                "markdown": "[embed]https://youtu.be/3EcoJOABzgs[/embed]",
                "html": "[embed]https://youtu.be/3EcoJOABzgs[/embed]",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1481369036000,
                "created_by": 1,
                "updated_at": 1481369036000,
                "updated_by": 1,
                "published_at": 1481369036000,
                "published_by": 1
            },
            {
                "id": 3801,
                "title": "자전거 출근 - 가양에서 신사까지",
                "slug": "%ec%9e%90%ec%a0%84%ea%b1%b0-%ec%b6%9c%ea%b7%bc-%ea%b0%80%ec%96%91%ec%97%90%ec%84%9c-%ec%8b%a0%ec%82%ac%ea%b9%8c%ec%a7%80",
                "markdown": "자전거로 출근하기 최적의 위치. 가양에서 신사까지...\n<ul>\n \t<li>촬영: iPhone 4 / Instagram Time Lapse App</li>\n \t<li>편집: Apple Final Cut Pro X</li>\n \t<li>촬영일: 2014년 4월 19일</li>\n</ul>\n[embed]https://youtu.be/eFdSO2AM_V8[/embed]",
                "html": "자전거로 출근하기 최적의 위치. 가양에서 신사까지...\n<ul>\n \t<li>촬영: iPhone 4 / Instagram Time Lapse App</li>\n \t<li>편집: Apple Final Cut Pro X</li>\n \t<li>촬영일: 2014년 4월 19일</li>\n</ul>\n[embed]https://youtu.be/eFdSO2AM_V8[/embed]",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1481370934000,
                "created_by": 1,
                "updated_at": 1481370934000,
                "updated_by": 1,
                "published_at": 1481370934000,
                "published_by": 1
            },
            {
                "id": 3831,
                "title": "Evernote --> Onenote 이전",
                "slug": "evernote-onenote-%ec%9d%b4%ec%a0%84",
                "markdown": "Evernote가 싫어진 건 아니고 좋아하는 툴이지만 회사에서 onenote를 쓰면서 점차 사용빈도가 낮아지더니 이제는 거의 쓰지를 않게 되었다. 가끔 예전 노트가 생각 나서 찾아보다가 이걸 통째로 onenote로 이전해서 가까이 두기로 했다. evernote와 거의 이별을 하게 될 텐데 evernote의 경영악화 소식이 오래전에 있었는데 왠지 마음이 아프네.\n\n<a href=\"https://www.onenote.com/import-evernote-to-onenote\">onenote importer</a> 를 이용하면 한번에 자동으로 이전된다. 700개의 노트가 이전되었다.\n\n<img class=\"aligncenter size-large wp-image-3841\" src=\"/content/images/2016/12/onenote-impoter-1024x718.jpg\" alt=\"\" width=\"640\" height=\"449\" />",
                "html": "Evernote가 싫어진 건 아니고 좋아하는 툴이지만 회사에서 onenote를 쓰면서 점차 사용빈도가 낮아지더니 이제는 거의 쓰지를 않게 되었다. 가끔 예전 노트가 생각 나서 찾아보다가 이걸 통째로 onenote로 이전해서 가까이 두기로 했다. evernote와 거의 이별을 하게 될 텐데 evernote의 경영악화 소식이 오래전에 있었는데 왠지 마음이 아프네.<p><a href=\"https://www.onenote.com/import-evernote-to-onenote\">onenote importer</a> 를 이용하면 한번에 자동으로 이전된다. 700개의 노트가 이전되었다.<p><img class=\"aligncenter size-large wp-image-3841\" src=\"/content/images/2016/12/onenote-impoter-1024x718.jpg\" alt=\"\" width=\"640\" height=\"449\" />",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1481374279000,
                "created_by": 1,
                "updated_at": 1481374279000,
                "updated_by": 1,
                "published_at": 1481374279000,
                "published_by": 1
            },
            {
                "id": 3911,
                "title": "Azure IPv6 지원과 애플 \"IPv6 Only Network\"",
                "slug": "azure-ipv6-%ec%a7%80%ec%9b%90%ea%b3%bc-%ec%95%a0%ed%94%8c-ipv6-only-network",
                "markdown": "지난 9월에 있었던 마이크로소프트 Ignite 2016 행사에서는 Azure의 네트워킹 관련 업데이트가 대거 발표되었다. 주요 내용은 DNS, IPv6, WAF, Peering, Accelerated Networking인데 상세 내용은 동영상 또는 <a href=\"https://azure.microsoft.com/en-us/blog/azure-networking-announcements-for-ignite-2016/\">블로그 글</a>을 참조 바란다. 그 중에 <a href=\"https://docs.microsoft.com/ko-kr/azure/load-balancer/load-balancer-ipv6-overview\">IPv6지원에 대한 내용</a>이 포함되어 있었는데 그 내용을 살펴보자.\n\n<a href=\"https://ko.wikipedia.org/wiki/IPv6\">위키백과</a>에 따르면 IPv6는 1994년에 국제인터넷표준화기구에서 채택되었다고 한다. 그리고 내 개인 기억으로는 10년도 전에 IPv4가 고갈될 것이라는 공포심을 자극하면서 잠시 회자가 되나 싶더니 이내 잘 들리지 않는 IT용어 였다. 최근에는 IoT 와 더불어 다시 얘기가 나오고 있지만 아직 낮설다. 그러나 최근 IPv6에 대한 이슈를 끌고 나온 것은 의외로 애플이다.\n\n애플은 <a href=\"https://developer.apple.com/news/?id=05042016a\">WWDC 2015 행사에서 앱 심사 항목에 \"IPv6 Only Network 지원\"을 2016년 6월 1일 부터 넣겠다고 발표를 했다</a>.  그리고 올해  6월이 지나면서 실제 앱스토어의 앱 심사에서 \"IPv6 Only Network 미지원\"으로 반려(Reject)된 사유가 나오면서 앱 개발자들 사이에서 이슈가 되고 있다.\n<blockquote>\n<h4>애플의 \"IPv6 Only Network 지원\" 요건은 서버측이 IPv6를 지원하는 것과는 상관없다.</h4>\n</blockquote>\n먼저 오해를 하지 말아야 할 것이 있다. \"IPv6 Only Network\" 지원은 iOS 기기가 IPv6만 지원하는 네트워크 환경에서도 앱이 정상적으로 작동하는지를 본다는 것이다. 서버측이 IPv6를 지원하고 말고는 상관이 없다. <a href=\"https://forums.developer.apple.com/message/136166#136166\">애플 포럼의 FAQ를 정리해놓은 글</a>을 보면 이런 내용이 있다.\n<blockquote>#3 — <em>Will I need to update my server?</em>\n\n&nbsp;\n\nThat depends on where your server is running:\n<ul>\n \t<li>If you have a server running on the wider Internet, the answer is no.  Your server will be accessible to IPv6-only devices via DNS64/NAT64.You <em>should</em> update your server to support IPv6 as a matter of course, but that’s something you can do in your own time.</li>\n</ul>\n서버를 변경해야 하나요?\n\n&nbsp;\n\n그건 서버환경에 따라 다른데 서버가 인터넷 공간에 연결되어 있다면 대답은 \"NO\". 당신의 서버는 DNS64/NAT64를 통해 IPv6 only device와 통신이 가능할 것이다.\n\n&nbsp;\n\n당연히 서버가 IPv6를 지원하면 좋다. 하지만 시간 날 때 해라.</blockquote>\n<a href=\"https://developer.apple.com/library/content/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/UnderstandingandPreparingfortheIPv6Transition/UnderstandingandPreparingfortheIPv6Transition.html#//apple_ref/doc/uid/TP40010220-CH213-SW16\">애플이 제시한 테스트 환경</a>을 보면 이해가 된다. iOS 기기들은 IPv6 주소를 받아서 IPv6 네트워크에 속하지만 DNS64/NAT64를 거치면서  IPv4로 변환된 주소로 서버와 연결된다. 즉, 서버측은 IPv4라도 상관이 없다. 구구절절 설명하는 이유는 앱이 반려 되었을 때 문제의 원인은 클라이언트(앱의 코드)에 있기 때문에 앱의 코드를 살펴봐야 한다는 것이다.\n<h3>Azure의 IPv6 지원</h3>\n<h4>현재 제약사항</h4>\nAzure의 IPv6 지원은 아직 일부라고 말할 수 있다. 뭔가 해보기 전에 <strong>현재(2016년 12월 14일)</strong>의 제약사항을 먼저 살펴보는게 좋겠다.\n<ol>\n \t<li>Azure의 Iaas 리소스 중에 부하분산집합(LB, Load Balancer)와 그 밑에 붙어 있는 가상머신(VM, Virtual Machine) 에서만 IPv6가 지원된다.\n<ul>\n \t<li>인터넷에 직접 연결된 VM에서는 적용할 수 없다. 정확히 말하면 Public IPv6는 LB에만 만들 수 있다.</li>\n \t<li>VMSS(Virtual Machine Scale Set)에 적용할 수 없다.</li>\n \t<li>LB의 Probe는 IPv4 주소만 가능하다.</li>\n</ul>\n</li>\n \t<li>신규로 생성하는 인프라에만 적용할 수 있다.\n<ul>\n \t<li>기존에 생성되어 있는 LB나 VM에는 적용할 수 없다.</li>\n \t<li>방법이 없는 건 아니다. 서비스 점검 시간을 가지고 기존 VM에서 Disk 를 Detach하고  VM과 LB 그리고 그 주변기기(Network Interface Card, Network Security Group, IP Address)를 삭제하고 다시 만들면서 새로운 VM에 기존 Disk 를 Attach 시키는 방법이 있다. 결국 거의 모두 다시 만드는 상황.</li>\n</ul>\n</li>\n \t<li>Portal에서 만들 수 없고 ARM(Azure Resource Manager Template)이나 PowerShell, Azure CLI를 통해서 생성할 수 있다.</li>\n</ol>\n<h4>Azure Load Balancer에 IPv6 적용</h4>\n공식 문서가 제공 된다.\n<ul>\n \t<li><a href=\"https://docs.microsoft.com/ko-kr/azure/load-balancer/load-balancer-ipv6-overview\">Azure Load Balancer의 IPv6에 대한 개요</a></li>\n \t<li><a href=\"https://docs.microsoft.com/ko-kr/azure/load-balancer/load-balancer-ipv6-internet-template\">템플릿을 사용하여 IPv6와 함께 부하 분산 장치 배포하기</a></li>\n \t<li><a href=\"https://docs.microsoft.com/ko-kr/azure/load-balancer/load-balancer-ipv6-internet-ps\">Azure PowerShell을 사용하여 IPv6와 함께 부하 분산 장치 배포하기</a></li>\n \t<li><a href=\"https://docs.microsoft.com/ko-kr/azure/load-balancer/load-balancer-ipv6-internet-cli\">Azure CLI를 사용하여 IPv6와 함께 부하 분산 장치 배포하기</a></li>\n</ul>\n<img class=\"aligncenter size-full wp-image-4161\" src=\"/content/images/2016/12/load-balancer-ipv6.png\" alt=\"\" width=\"663\" height=\"355\" />\n\n기본 아이디어는 단순하다. LB에 IPv6용 IP Address를 만들어서 붙이고 VM에 붙어 있는 NIC(Network Interface Card)에도 IPv6용 IP Address를 붙여준다. 그리고 LB에서 Front End Address와 Back End Pool 설정을 해주고 Load Balancer Rule를 만들어 적용해준다.\n<h4>ARM Template을 이용하여 IPv6 환경 만들기</h4>\n가장 빨리 테스트 할 수 있는 방법은 이미 만들어져 있는 ARM Template을 활용하는 것이다. Sean Wheeler라는 분이 만들어 놓은 <a href=\"https://azure.microsoft.com/ko-kr/resources/templates/201-load-balancer-ipv6-create/\">Create a Load-balancer with a Public IPv6 Address</a> 페이지에서 \"Azure에 배포\" 버튼을 누르면 Azure Portal로 이동하면서 4가지 속성만 정의해 주면 즉시 만들 수 있다. <a href=\"https://github.com/Azure/azure-quickstart-templates/tree/master/201-load-balancer-ipv6-create\">템플릿의 소스코드는 GitHub</a>에 있다. Windows 서버 2대가 가용성 집합으로 묶여서 부하분산집합 아래에 놓이고 IPv4와 IPv6가 모두 설정된 인프라가 만들어진다.\n<ul>\n \t<li>Load Balancer의 Frontend IP Address가 IPv4 / IPv6 두개가 설정된다. (LoadBalancerFrontEndIPv4, LoadBalancerFrontEndIPv6) <img class=\"size-large wp-image-4191 alignnone\" src=\"/content/images/2016/12/ipv6-lb-frontend-ip-1024x331.png\" alt=\"\" width=\"640\" height=\"207\" /></li>\n \t<li>Load Balancer의 Backend Pools 도 두가지가 설정된다. (BackendPoolIPv4, BackendPoolIPv6)<img class=\"size-large wp-image-4201 alignnone\" src=\"/content/images/2016/12/load-balancer-ipv6-backend-1024x511.png\" alt=\"\" width=\"640\" height=\"319\" /></li>\n \t<li>Load Balancer의 Load Balancer Rule 도 두개로 설정된다. 이 중에서 IPv6에 대한 설정은 80 포트를 8080 포트로 보내는 설정이다. 따라서 VM에서 8080 접속에 대한 설정이 필요하다. 그리고 방화벽도 열어줘야 한다. 여기서는 IIS에 8080포트 바인딩 설정을 추가했다. <img class=\"alignnone size-large wp-image-4221\" src=\"/content/images/2016/12/ipv6-lb-rule-1024x564.png\" alt=\"\" width=\"640\" height=\"353\" /></li>\n</ul>\n<ul>\n \t<li>VM에 붙어 있는 Network Interface Card는 2개의 내부 IPv4, IPv6 IP가 적용되어 있다. <img class=\"size-large wp-image-4211 alignnone\" src=\"/content/images/2016/12/ipv6-nic-address-1024x538.png\" alt=\"\" width=\"640\" height=\"336\" /></li>\n \t<li>실제 머신에서도 네트워크 카드에 두개의 IP가 설정되어 있는 것이 확인된다. <!--?prettify linenums=true?-->\n<pre class=\"prettyprint\">Ethernet adapter Ethernet 2:\n\n   IPv6 Address. . . . . . . . . . . : 2603:1090:d05:f9::644a:a83d\n   Link-local IPv6 Address . . . . . : fe80::88cf:2aff:84b6:2cc8%13\n   IPv4 Address. . . . . . . . . . . : 10.0.0.5\n   Subnet Mask . . . . . . . . . . . : 255.255.255.0\n   Default Gateway . . . . . . . . . : fe80::662:73ff:fef4:56f%13\n                                       10.0.0.1\n</pre>\n</li>\n</ul>\n<h4>IPv6로 접속 테스트</h4>\nLoad Balancer에 연결된 IPv6 주소로 웹브라우저를 이용해서 테스트를 진행 해봤다. 테스트를 위해서는 나의 네트워크 환경이 IPv6를 지원하는지 확인해 봐야 하는데 <a href=\"https://www.test-ipv6.cz/index.html.ko_KR\">IPv6 연결테스트 페이지</a>에서 확인 할 수 있다.\n<h4>먼저 nslookup로 IPv6 주소 확인\n<!--?prettify linenums=true?--></h4>\n<pre class=\"prettyprint\">$ nslookup -query=AAAA gameserver123.japanwest.cloudapp.azure.com\nServer:\t\t168.126.63.1\nAddress:\t168.126.63.1#53\n\nNon-authoritative answer:\ngameserver123.japanwest.cloudapp.azure.com\thas AAAA address <strong>2603:1040:601::154</strong>\n\n$ nslookup gameserver123.japanwest.cloudapp.azure.com\n\nServer: 168.126.63.1\nAddress: 168.126.63.1#53\n\nNon-authoritative answer:\nName: gameserver123.japanwest.cloudapp.azure.com\nAddress: <strong>104.214.148.32</strong></pre>\n<h4>웹브라우저에서 http://[2603:1040:601::154] 로 접속테스트</h4>\nWindows 방화벽을 열지 않아서 문제가 있었지만 잘 접속이 된다.\n\n<img class=\"alignnone size-large wp-image-4371\" src=\"/content/images/2016/12/ipv6-web-browser-1024x719.png\" alt=\"\" width=\"640\" height=\"449\" />\n<h4>정리</h4>\n다시한번 정리를 해야겠습니다.\n<ul>\n \t<li>Azure Load Balancer 와 그 아래 붙어있는 VM에서 IPv6 를 지원한다.</li>\n \t<li>Load Balancer에 Auzre의 Public IP를 두개 붙이는데 IPv4와 IPv6를 생성한다.</li>\n \t<li>VM에도 Azure IP Address를 IPv6로 만들어서 붙인다.</li>\n \t<li>Load Balancer에서 Load Balancing Rule 이 두개가 필요하다. 웹 서비스의 경우 IPv4를 위해서는 80--&gt;80, IPv6에 대해서는 80 --&gt; 8080</li>\n \t<li>VM의 OS 상에서도 방화벽 설정(80, 8080)이나 Application 설정(IIS 설정 같은), Linux의 경우 IPv6를 설정</li>\n</ul>",
                "html": "지난 9월에 있었던 마이크로소프트 Ignite 2016 행사에서는 Azure의 네트워킹 관련 업데이트가 대거 발표되었다. 주요 내용은 DNS, IPv6, WAF, Peering, Accelerated Networking인데 상세 내용은 동영상 또는 <a href=\"https://azure.microsoft.com/en-us/blog/azure-networking-announcements-for-ignite-2016/\">블로그 글</a>을 참조 바란다. 그 중에 <a href=\"https://docs.microsoft.com/ko-kr/azure/load-balancer/load-balancer-ipv6-overview\">IPv6지원에 대한 내용</a>이 포함되어 있었는데 그 내용을 살펴보자.<p><a href=\"https://ko.wikipedia.org/wiki/IPv6\">위키백과</a>에 따르면 IPv6는 1994년에 국제인터넷표준화기구에서 채택되었다고 한다. 그리고 내 개인 기억으로는 10년도 전에 IPv4가 고갈될 것이라는 공포심을 자극하면서 잠시 회자가 되나 싶더니 이내 잘 들리지 않는 IT용어 였다. 최근에는 IoT 와 더불어 다시 얘기가 나오고 있지만 아직 낮설다. 그러나 최근 IPv6에 대한 이슈를 끌고 나온 것은 의외로 애플이다.<p>애플은 <a href=\"https://developer.apple.com/news/?id=05042016a\">WWDC 2015 행사에서 앱 심사 항목에 \"IPv6 Only Network 지원\"을 2016년 6월 1일 부터 넣겠다고 발표를 했다</a>.  그리고 올해  6월이 지나면서 실제 앱스토어의 앱 심사에서 \"IPv6 Only Network 미지원\"으로 반려(Reject)된 사유가 나오면서 앱 개발자들 사이에서 이슈가 되고 있다.\n<blockquote>\n<h4>애플의 \"IPv6 Only Network 지원\" 요건은 서버측이 IPv6를 지원하는 것과는 상관없다.</h4>\n</blockquote>\n먼저 오해를 하지 말아야 할 것이 있다. \"IPv6 Only Network\" 지원은 iOS 기기가 IPv6만 지원하는 네트워크 환경에서도 앱이 정상적으로 작동하는지를 본다는 것이다. 서버측이 IPv6를 지원하고 말고는 상관이 없다. <a href=\"https://forums.developer.apple.com/message/136166#136166\">애플 포럼의 FAQ를 정리해놓은 글</a>을 보면 이런 내용이 있다.\n<blockquote>#3 — <em>Will I need to update my server?</em><p>&nbsp;<p>That depends on where your server is running:\n<ul>\n \t<li>If you have a server running on the wider Internet, the answer is no.  Your server will be accessible to IPv6-only devices via DNS64/NAT64.You <em>should</em> update your server to support IPv6 as a matter of course, but that’s something you can do in your own time.</li>\n</ul>\n서버를 변경해야 하나요?<p>&nbsp;<p>그건 서버환경에 따라 다른데 서버가 인터넷 공간에 연결되어 있다면 대답은 \"NO\". 당신의 서버는 DNS64/NAT64를 통해 IPv6 only device와 통신이 가능할 것이다.<p>&nbsp;<p>당연히 서버가 IPv6를 지원하면 좋다. 하지만 시간 날 때 해라.</blockquote>\n<a href=\"https://developer.apple.com/library/content/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/UnderstandingandPreparingfortheIPv6Transition/UnderstandingandPreparingfortheIPv6Transition.html#//apple_ref/doc/uid/TP40010220-CH213-SW16\">애플이 제시한 테스트 환경</a>을 보면 이해가 된다. iOS 기기들은 IPv6 주소를 받아서 IPv6 네트워크에 속하지만 DNS64/NAT64를 거치면서  IPv4로 변환된 주소로 서버와 연결된다. 즉, 서버측은 IPv4라도 상관이 없다. 구구절절 설명하는 이유는 앱이 반려 되었을 때 문제의 원인은 클라이언트(앱의 코드)에 있기 때문에 앱의 코드를 살펴봐야 한다는 것이다.\n<h3>Azure의 IPv6 지원</h3>\n<h4>현재 제약사항</h4>\nAzure의 IPv6 지원은 아직 일부라고 말할 수 있다. 뭔가 해보기 전에 <strong>현재(2016년 12월 14일)</strong>의 제약사항을 먼저 살펴보는게 좋겠다.\n<ol>\n \t<li>Azure의 Iaas 리소스 중에 부하분산집합(LB, Load Balancer)와 그 밑에 붙어 있는 가상머신(VM, Virtual Machine) 에서만 IPv6가 지원된다.\n<ul>\n \t<li>인터넷에 직접 연결된 VM에서는 적용할 수 없다. 정확히 말하면 Public IPv6는 LB에만 만들 수 있다.</li>\n \t<li>VMSS(Virtual Machine Scale Set)에 적용할 수 없다.</li>\n \t<li>LB의 Probe는 IPv4 주소만 가능하다.</li>\n</ul>\n</li>\n \t<li>신규로 생성하는 인프라에만 적용할 수 있다.\n<ul>\n \t<li>기존에 생성되어 있는 LB나 VM에는 적용할 수 없다.</li>\n \t<li>방법이 없는 건 아니다. 서비스 점검 시간을 가지고 기존 VM에서 Disk 를 Detach하고  VM과 LB 그리고 그 주변기기(Network Interface Card, Network Security Group, IP Address)를 삭제하고 다시 만들면서 새로운 VM에 기존 Disk 를 Attach 시키는 방법이 있다. 결국 거의 모두 다시 만드는 상황.</li>\n</ul>\n</li>\n \t<li>Portal에서 만들 수 없고 ARM(Azure Resource Manager Template)이나 PowerShell, Azure CLI를 통해서 생성할 수 있다.</li>\n</ol>\n<h4>Azure Load Balancer에 IPv6 적용</h4>\n공식 문서가 제공 된다.\n<ul>\n \t<li><a href=\"https://docs.microsoft.com/ko-kr/azure/load-balancer/load-balancer-ipv6-overview\">Azure Load Balancer의 IPv6에 대한 개요</a></li>\n \t<li><a href=\"https://docs.microsoft.com/ko-kr/azure/load-balancer/load-balancer-ipv6-internet-template\">템플릿을 사용하여 IPv6와 함께 부하 분산 장치 배포하기</a></li>\n \t<li><a href=\"https://docs.microsoft.com/ko-kr/azure/load-balancer/load-balancer-ipv6-internet-ps\">Azure PowerShell을 사용하여 IPv6와 함께 부하 분산 장치 배포하기</a></li>\n \t<li><a href=\"https://docs.microsoft.com/ko-kr/azure/load-balancer/load-balancer-ipv6-internet-cli\">Azure CLI를 사용하여 IPv6와 함께 부하 분산 장치 배포하기</a></li>\n</ul>\n<img class=\"aligncenter size-full wp-image-4161\" src=\"/content/images/2016/12/load-balancer-ipv6.png\" alt=\"\" width=\"663\" height=\"355\" /><p>기본 아이디어는 단순하다. LB에 IPv6용 IP Address를 만들어서 붙이고 VM에 붙어 있는 NIC(Network Interface Card)에도 IPv6용 IP Address를 붙여준다. 그리고 LB에서 Front End Address와 Back End Pool 설정을 해주고 Load Balancer Rule를 만들어 적용해준다.\n<h4>ARM Template을 이용하여 IPv6 환경 만들기</h4>\n가장 빨리 테스트 할 수 있는 방법은 이미 만들어져 있는 ARM Template을 활용하는 것이다. Sean Wheeler라는 분이 만들어 놓은 <a href=\"https://azure.microsoft.com/ko-kr/resources/templates/201-load-balancer-ipv6-create/\">Create a Load-balancer with a Public IPv6 Address</a> 페이지에서 \"Azure에 배포\" 버튼을 누르면 Azure Portal로 이동하면서 4가지 속성만 정의해 주면 즉시 만들 수 있다. <a href=\"https://github.com/Azure/azure-quickstart-templates/tree/master/201-load-balancer-ipv6-create\">템플릿의 소스코드는 GitHub</a>에 있다. Windows 서버 2대가 가용성 집합으로 묶여서 부하분산집합 아래에 놓이고 IPv4와 IPv6가 모두 설정된 인프라가 만들어진다.\n<ul>\n \t<li>Load Balancer의 Frontend IP Address가 IPv4 / IPv6 두개가 설정된다. (LoadBalancerFrontEndIPv4, LoadBalancerFrontEndIPv6) <img class=\"size-large wp-image-4191 alignnone\" src=\"/content/images/2016/12/ipv6-lb-frontend-ip-1024x331.png\" alt=\"\" width=\"640\" height=\"207\" /></li>\n \t<li>Load Balancer의 Backend Pools 도 두가지가 설정된다. (BackendPoolIPv4, BackendPoolIPv6)<img class=\"size-large wp-image-4201 alignnone\" src=\"/content/images/2016/12/load-balancer-ipv6-backend-1024x511.png\" alt=\"\" width=\"640\" height=\"319\" /></li>\n \t<li>Load Balancer의 Load Balancer Rule 도 두개로 설정된다. 이 중에서 IPv6에 대한 설정은 80 포트를 8080 포트로 보내는 설정이다. 따라서 VM에서 8080 접속에 대한 설정이 필요하다. 그리고 방화벽도 열어줘야 한다. 여기서는 IIS에 8080포트 바인딩 설정을 추가했다. <img class=\"alignnone size-large wp-image-4221\" src=\"/content/images/2016/12/ipv6-lb-rule-1024x564.png\" alt=\"\" width=\"640\" height=\"353\" /></li>\n</ul>\n<ul>\n \t<li>VM에 붙어 있는 Network Interface Card는 2개의 내부 IPv4, IPv6 IP가 적용되어 있다. <img class=\"size-large wp-image-4211 alignnone\" src=\"/content/images/2016/12/ipv6-nic-address-1024x538.png\" alt=\"\" width=\"640\" height=\"336\" /></li>\n \t<li>실제 머신에서도 네트워크 카드에 두개의 IP가 설정되어 있는 것이 확인된다. <!--?prettify linenums=true?-->\n<pre class=\"prettyprint\">Ethernet adapter Ethernet 2:<p>   IPv6 Address. . . . . . . . . . . : 2603:1090:d05:f9::644a:a83d\n   Link-local IPv6 Address . . . . . : fe80::88cf:2aff:84b6:2cc8%13\n   IPv4 Address. . . . . . . . . . . : 10.0.0.5\n   Subnet Mask . . . . . . . . . . . : 255.255.255.0\n   Default Gateway . . . . . . . . . : fe80::662:73ff:fef4:56f%13\n                                       10.0.0.1\n</pre>\n</li>\n</ul>\n<h4>IPv6로 접속 테스트</h4>\nLoad Balancer에 연결된 IPv6 주소로 웹브라우저를 이용해서 테스트를 진행 해봤다. 테스트를 위해서는 나의 네트워크 환경이 IPv6를 지원하는지 확인해 봐야 하는데 <a href=\"https://www.test-ipv6.cz/index.html.ko_KR\">IPv6 연결테스트 페이지</a>에서 확인 할 수 있다.\n<h4>먼저 nslookup로 IPv6 주소 확인\n<!--?prettify linenums=true?--></h4>\n<pre class=\"prettyprint\">$ nslookup -query=AAAA gameserver123.japanwest.cloudapp.azure.com\nServer:\t\t168.126.63.1\nAddress:\t168.126.63.1#53<p>Non-authoritative answer:\ngameserver123.japanwest.cloudapp.azure.com\thas AAAA address <strong>2603:1040:601::154</strong><p>$ nslookup gameserver123.japanwest.cloudapp.azure.com<p>Server: 168.126.63.1\nAddress: 168.126.63.1#53<p>Non-authoritative answer:\nName: gameserver123.japanwest.cloudapp.azure.com\nAddress: <strong>104.214.148.32</strong></pre>\n<h4>웹브라우저에서 http://[2603:1040:601::154] 로 접속테스트</h4>\nWindows 방화벽을 열지 않아서 문제가 있었지만 잘 접속이 된다.<p><img class=\"alignnone size-large wp-image-4371\" src=\"/content/images/2016/12/ipv6-web-browser-1024x719.png\" alt=\"\" width=\"640\" height=\"449\" />\n<h4>정리</h4>\n다시한번 정리를 해야겠습니다.\n<ul>\n \t<li>Azure Load Balancer 와 그 아래 붙어있는 VM에서 IPv6 를 지원한다.</li>\n \t<li>Load Balancer에 Auzre의 Public IP를 두개 붙이는데 IPv4와 IPv6를 생성한다.</li>\n \t<li>VM에도 Azure IP Address를 IPv6로 만들어서 붙인다.</li>\n \t<li>Load Balancer에서 Load Balancing Rule 이 두개가 필요하다. 웹 서비스의 경우 IPv4를 위해서는 80--&gt;80, IPv6에 대해서는 80 --&gt; 8080</li>\n \t<li>VM의 OS 상에서도 방화벽 설정(80, 8080)이나 Application 설정(IIS 설정 같은), Linux의 경우 IPv6를 설정</li>\n</ul>",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1481881739000,
                "created_by": 1,
                "updated_at": 1481881739000,
                "updated_by": 1,
                "published_at": 1481881739000,
                "published_by": 1
            },
            {
                "id": 4281,
                "title": "Azure SQL Database 데이터 이전 (Full text Search 포함)",
                "slug": "azure-sql-database-%eb%8d%b0%ec%9d%b4%ed%84%b0-%ec%9d%b4%ec%a0%84-full-text-search-%ed%8f%ac%ed%95%a8",
                "markdown": "Microsoft SQL Server를 온프레미스 서버나 Azure VM에 설치해서 사용하다가 Azure SQL Database로 이전하는 경우가 있다. 이전 방법은 총 4가지가 있다.\n<ol>\n \t<li><a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-cloud-migrate-fix-compatibility-issues-ssdt\">Visual Studio용 SQL Server 데이터 도구(\"SSDT\") </a>사용.</li>\n \t<li><a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-cloud-migrate-determine-compatibility-sqlpackage\">SqlPackage.exe 를 이용하는 방법 </a></li>\n \t<li><a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-cloud-migrate-determine-compatibility-ssms\">SQL Server Management Studio 를 사용하는 방법</a></li>\n \t<li><a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-cloud-migrate-fix-compatibility-issues\">SQL Azure 마이그레이션 마법사(\"SAMW\") 를 사용하는 방법</a></li>\n</ol>\n이중에서 SSMS(SQL Server Management Studio)를 사용해서 데이터 이전을 할 때 경험있어 공유 한다.\n\n먼저 Before 환경은 Microsoft SQL Server 2014 Standard 버전이고 Full Text Search 를 사용하는 Database이다. 다행히 <a href=\"https://azure.microsoft.com/ko-kr/blog/full-text-search-is-now-available-for-preview-in-azure-sql-database/\">Azure SQL Server는 최신 버전이 V12라고 하는데 V12에 Full Text Search 도 지원을 </a>하게 되었다.\n\n데이터 이전의 순서와 관련 문서는 아래와 같다. 아래 내용은 Azure Portal / PowerShell / SQLPackage.exe 를 사용해서도 가능하다.\n<h2>1. SSMS 업그레이드: 최신버전으로 받아야 한다.</h2>\n<a href=\"https://msdn.microsoft.com/ko-kr/library/mt238290.aspx\">다운로드 링크</a> (13.0.16100)\n\nAzure SQL Database가 Full Text Search를 지원한 시점이 늦기 때문에 기존 SSMS 툴들이 Validation 과정에서 오류를 내고 작동하지 않는다. 최신버전에서는 이런 문제가 발생하지 않는다. SSMS 2014 (12.0.2548.0) 에서는 아래와 같은 오류를 발생시켰는데 툴을 업그레이드 하면 해결 된다.\n<pre class=\"prettyprint\">Error SQL71564: The element Full-text Catalog: [CAT_FOOTAGE] is not supported in Microsoft Azure SQL Database v12 (Preview).\nError SQL71564: The element Full-text Index on [dbo].[Keyword] is not supported in Microsoft Azure SQL Database v12 (Preview).\nError SQL71564: The element SqlFullTextIndexColumnSpecifier: &lt;unnamed&gt; has property LanguageId set to a value that is not supported in Microsoft Azure SQL Database v12 (Preview).\n</pre>\n<h2>2. <a href=\"https://docs.microsoft.com/en-us/azure/sql-database/sql-database-cloud-migrate-compatible-export-bacpac-ssms\">BACKPAC 파일 만들기 </a></h2>\n<a href=\"https://docs.microsoft.com/en-us/azure/sql-database/sql-database-cloud-migrate-compatible-export-bacpac-ssms\">문서</a>를 따라서 진행하면 된다.\n\n시작하면서  Validation Check를 하는데 흔히 발생하는 오류는 사용자에 관한 오류다. 로컬에 직접 설치된 SQL Server는 Windows 사용자 계정을 데이터베이스 관리자로 추가 하여 Windows 로그인으로 SQL Server로 접속이 가능하지만 Azure SQL은 SQL 사용자만 생성되고 로그인 가능하다. 따라서 Windows 사용자에 관련된 오류가 발 생할 수 있다.\n<h2>3. Azure 포탈에서 SQL Server 만들기</h2>\nAzure 포탈에서 SQL Server(Logical Server) 를 만들어 준비한다. Azure SQL Database를 만들면서 함께 SQL Server 가 만들어지지만 (여기서 용어가 헷갈리는데 SQL Server는 서버 인프라를 말하고 Azure SQL Database는 데이터베이스 자체를 말한다) SSMS를 사용해서 임포트를 할 때 새로운 DB를 만들면서 진행하기 때문에 이름이 겹치지 않게 Database는 만들어 놓지 않아도 된다.\n\n<img class=\"alignnone size-full wp-image-4291\" src=\"/content/images/2016/12/azure-sql.png\" alt=\"\" width=\"890\" height=\"764\" />\n<h2>4. <a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-cloud-migrate-compatible-import-bacpac-ssms\">BACKPAC 파일 임포트</a></h2>\n임포트 과정도 <a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-cloud-migrate-compatible-import-bacpac-ssms\">문서</a>를 따라서 하면 된다.\n\n<img class=\"alignnone size-large wp-image-4301\" src=\"/content/images/2016/12/import-1024x925.png\" alt=\"\" width=\"640\" height=\"578\" />\n\n문서화도 잘 되어 있고 툴도 정비가 되어서 어렵지 않게 걱정했던 데이터 이전을 완료했다.\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;",
                "html": "Microsoft SQL Server를 온프레미스 서버나 Azure VM에 설치해서 사용하다가 Azure SQL Database로 이전하는 경우가 있다. 이전 방법은 총 4가지가 있다.\n<ol>\n \t<li><a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-cloud-migrate-fix-compatibility-issues-ssdt\">Visual Studio용 SQL Server 데이터 도구(\"SSDT\") </a>사용.</li>\n \t<li><a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-cloud-migrate-determine-compatibility-sqlpackage\">SqlPackage.exe 를 이용하는 방법 </a></li>\n \t<li><a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-cloud-migrate-determine-compatibility-ssms\">SQL Server Management Studio 를 사용하는 방법</a></li>\n \t<li><a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-cloud-migrate-fix-compatibility-issues\">SQL Azure 마이그레이션 마법사(\"SAMW\") 를 사용하는 방법</a></li>\n</ol>\n이중에서 SSMS(SQL Server Management Studio)를 사용해서 데이터 이전을 할 때 경험있어 공유 한다.<p>먼저 Before 환경은 Microsoft SQL Server 2014 Standard 버전이고 Full Text Search 를 사용하는 Database이다. 다행히 <a href=\"https://azure.microsoft.com/ko-kr/blog/full-text-search-is-now-available-for-preview-in-azure-sql-database/\">Azure SQL Server는 최신 버전이 V12라고 하는데 V12에 Full Text Search 도 지원을 </a>하게 되었다.<p>데이터 이전의 순서와 관련 문서는 아래와 같다. 아래 내용은 Azure Portal / PowerShell / SQLPackage.exe 를 사용해서도 가능하다.\n<h2>1. SSMS 업그레이드: 최신버전으로 받아야 한다.</h2>\n<a href=\"https://msdn.microsoft.com/ko-kr/library/mt238290.aspx\">다운로드 링크</a> (13.0.16100)<p>Azure SQL Database가 Full Text Search를 지원한 시점이 늦기 때문에 기존 SSMS 툴들이 Validation 과정에서 오류를 내고 작동하지 않는다. 최신버전에서는 이런 문제가 발생하지 않는다. SSMS 2014 (12.0.2548.0) 에서는 아래와 같은 오류를 발생시켰는데 툴을 업그레이드 하면 해결 된다.\n<pre class=\"prettyprint\">Error SQL71564: The element Full-text Catalog: [CAT_FOOTAGE] is not supported in Microsoft Azure SQL Database v12 (Preview).\nError SQL71564: The element Full-text Index on [dbo].[Keyword] is not supported in Microsoft Azure SQL Database v12 (Preview).\nError SQL71564: The element SqlFullTextIndexColumnSpecifier: &lt;unnamed&gt; has property LanguageId set to a value that is not supported in Microsoft Azure SQL Database v12 (Preview).\n</pre>\n<h2>2. <a href=\"https://docs.microsoft.com/en-us/azure/sql-database/sql-database-cloud-migrate-compatible-export-bacpac-ssms\">BACKPAC 파일 만들기 </a></h2>\n<a href=\"https://docs.microsoft.com/en-us/azure/sql-database/sql-database-cloud-migrate-compatible-export-bacpac-ssms\">문서</a>를 따라서 진행하면 된다.<p>시작하면서  Validation Check를 하는데 흔히 발생하는 오류는 사용자에 관한 오류다. 로컬에 직접 설치된 SQL Server는 Windows 사용자 계정을 데이터베이스 관리자로 추가 하여 Windows 로그인으로 SQL Server로 접속이 가능하지만 Azure SQL은 SQL 사용자만 생성되고 로그인 가능하다. 따라서 Windows 사용자에 관련된 오류가 발 생할 수 있다.\n<h2>3. Azure 포탈에서 SQL Server 만들기</h2>\nAzure 포탈에서 SQL Server(Logical Server) 를 만들어 준비한다. Azure SQL Database를 만들면서 함께 SQL Server 가 만들어지지만 (여기서 용어가 헷갈리는데 SQL Server는 서버 인프라를 말하고 Azure SQL Database는 데이터베이스 자체를 말한다) SSMS를 사용해서 임포트를 할 때 새로운 DB를 만들면서 진행하기 때문에 이름이 겹치지 않게 Database는 만들어 놓지 않아도 된다.<p><img class=\"alignnone size-full wp-image-4291\" src=\"/content/images/2016/12/azure-sql.png\" alt=\"\" width=\"890\" height=\"764\" />\n<h2>4. <a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-cloud-migrate-compatible-import-bacpac-ssms\">BACKPAC 파일 임포트</a></h2>\n임포트 과정도 <a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-cloud-migrate-compatible-import-bacpac-ssms\">문서</a>를 따라서 하면 된다.<p><img class=\"alignnone size-large wp-image-4301\" src=\"/content/images/2016/12/import-1024x925.png\" alt=\"\" width=\"640\" height=\"578\" /><p>문서화도 잘 되어 있고 툴도 정비가 되어서 어렵지 않게 걱정했던 데이터 이전을 완료했다.<p>&nbsp;<p>&nbsp;<p>&nbsp;",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1481881439000,
                "created_by": 1,
                "updated_at": 1481881439000,
                "updated_by": 1,
                "published_at": 1481881439000,
                "published_by": 1
            },
            {
                "id": 4431,
                "title": "Visual Studio Code 커맨드에서 바로 실행하는 방법",
                "slug": "visual-studio-code-%ec%bb%a4%eb%a7%a8%eb%93%9c%ec%97%90%ec%84%9c-%eb%b0%94%eb%a1%9c-%ec%8b%a4%ed%96%89%ed%95%98%eb%8a%94-%eb%b0%a9%eb%b2%95",
                "markdown": "쉘에서 커멘드라인에서 바로 VS Code 를 실행하고 싶은 때가 있다. 이렇게 ...\n<pre class=\"prettyprint\">$ code .</pre>\n이렇게 하면 VS Code가 실행되고 현재 디렉토리가 바로 열리니 편리하다. 설정하는 방법은 결국 VS Code의 실행파일을 시스템 PATH에 넣어주는 것인데 쉽게 설정하는 방법이 있다.\n\nVS Code를 실행하고 Command Palette ( 맥의 경우 Shift + Command + P, 윈도우/리눅스의 경우 Ctrl + Shift + P)를 열어서 'shell command'를 입력하면 <strong>Shell Command: Install 'code' command</strong> 를 찾아서 선택하면 된다.\n\n<img class=\"aligncenter size-large\" src=\"https://code.visualstudio.com/images/mac_shell-command.png\" alt=\"shell command install code command in PATH\" width=\"618\" height=\"100\" />",
                "html": "쉘에서 커멘드라인에서 바로 VS Code 를 실행하고 싶은 때가 있다. 이렇게 ...\n<pre class=\"prettyprint\">$ code .</pre>\n이렇게 하면 VS Code가 실행되고 현재 디렉토리가 바로 열리니 편리하다. 설정하는 방법은 결국 VS Code의 실행파일을 시스템 PATH에 넣어주는 것인데 쉽게 설정하는 방법이 있다.<p>VS Code를 실행하고 Command Palette ( 맥의 경우 Shift + Command + P, 윈도우/리눅스의 경우 Ctrl + Shift + P)를 열어서 'shell command'를 입력하면 <strong>Shell Command: Install 'code' command</strong> 를 찾아서 선택하면 된다.<p><img class=\"aligncenter size-large\" src=\"https://code.visualstudio.com/images/mac_shell-command.png\" alt=\"shell command install code command in PATH\" width=\"618\" height=\"100\" />",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1483511597000,
                "created_by": 1,
                "updated_at": 1483511597000,
                "updated_by": 1,
                "published_at": 1483511597000,
                "published_by": 1
            },
            {
                "id": 4471,
                "title": "Microsoft Conversation as a Platform 소개 - 발표영상 및 자료",
                "slug": "microsoft-conversation-as-a-platform-%ec%86%8c%ea%b0%9c-%eb%b0%9c%ed%91%9c%ec%98%81%ec%83%81-%eb%b0%8f-%ec%9e%90%eb%a3%8c",
                "markdown": "2017년 1월 14일에 있었던 Microsoft Azure Korea Group(http://krazure.club) <a href=\"http://onoffmix.com/event/86535\">Saturday Azure Live, 1701 세미나</a>의 첫번째 세션이 었던 \"Microsoft Conversation as a Platform 소개\" 발표영상과 발표 자료 입니다.\n\n<iframe src=\"https://www.youtube.com/embed/DWkwBpdoDf8\" width=\"853\" height=\"480\" frameborder=\"0\" allowfullscreen=\"allowfullscreen\"></iframe>\n\n&nbsp;\n\n<iframe src=\"https://docs.com/d/embed/D25191790-3947-5851-4070-001268338186%7eMe2e6c445-2491-fc63-677c-d119e98c3ac9\" width=\"853px\" height=\"480px\" frameborder=\"0\" allowfullscreen=\"allowfullscreen\"></iframe>",
                "html": "2017년 1월 14일에 있었던 Microsoft Azure Korea Group(http://krazure.club) <a href=\"http://onoffmix.com/event/86535\">Saturday Azure Live, 1701 세미나</a>의 첫번째 세션이 었던 \"Microsoft Conversation as a Platform 소개\" 발표영상과 발표 자료 입니다.<p><iframe src=\"https://www.youtube.com/embed/DWkwBpdoDf8\" width=\"853\" height=\"480\" frameborder=\"0\" allowfullscreen=\"allowfullscreen\"></iframe><p>&nbsp;<p><iframe src=\"https://docs.com/d/embed/D25191790-3947-5851-4070-001268338186%7eMe2e6c445-2491-fc63-677c-d119e98c3ac9\" width=\"853px\" height=\"480px\" frameborder=\"0\" allowfullscreen=\"allowfullscreen\"></iframe>",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1484399343000,
                "created_by": 1,
                "updated_at": 1484399343000,
                "updated_by": 1,
                "published_at": 1484399343000,
                "published_by": 1
            },
            {
                "id": 4611,
                "title": "Xamarin 자격증 취득 후기",
                "slug": "xamarin-%ec%9e%90%ea%b2%a9%ec%a6%9d-%ec%b7%a8%eb%93%9d-%ed%9b%84%ea%b8%b0",
                "markdown": "<a href=\"https://www.xamarin.com/\">Xamarin</a>은 C#, .NET Framework, Visual Studio를 활용해서 크로스플랫폼(iOS, Android, Windows 10 app)을 개발 할 수 있는 플랫폼이다. Xamarin을 익히는 방법은 여러가지가 있지만 <a href=\"https://university.xamarin.com/\">Xamarin University</a>라는 사이트를 통해서 강의를 듣고 공부를 하는 방법이 있다. 물론 모든 강의가 영어로 진행되는 점은 아쉽지만 교육과정과 컨텐츠는 매우 훌륭하다. Xamarin University에서 관리하는 자격증이 하나 있는데 \"<a href=\"https://university.xamarin.com/certification\"><strong>Xamarin Certified Mobile Developer</strong></a>\"가 그 자격증이다. 약 2개월 동안 Xamarin University에서 강의를 듣고 오늘 자격증을 취득했다.\n<h2>1. IT 자격증을 대하는 자세</h2>\n개발자로 10년도 넘게 일하는 동안 '국제 IT 자격증'(뭐라고 불러야 하는지 모르겠다)을 몇 개 가지고 있다. 하지만 대한민국에서 자격증이 내 일자리를 보장해 주지도 않고 어느 누구도 자격증이 있다고 개발을 잘 한다고 인정해주지 않는다. 따라서 가끔 이력서에 빈 공란을 채워주는 역할을 했을 뿐 아무도, 심지어는 나 조차도 자격증을 활용하는 것에는 관심이 없다. 정확히 말하자면 나는 자격증으로 덕을 보고자 하는 마음이 전혀 없다.\n\n그런데 왜 또 자격증 얘기인가? 현재 프로젝트에서 쓰고 있지 않은 기술을 공부하려면 의지력이 중요한데 바쁜 일상에서 그 의지력은 쉽게 사라진다. 이 때 덜컥 돈을 지불하고 자격증 시험을 한두 달 후로 잡아 버린다. 그러면 없던 의지력이 샘솟고 특히 그 날짜가 다가올수록 그 의지력은 점점 올라간다. 그 힘으로 나를 다그쳐서 끝내는 새로운 기술을 익힌다. 세상을 참 피곤하게 사는 방법이다. 피곤해서 나이들고는 잘 안한다.\n\nXamarin 자격증도 \"같은 이유 + 회사에서의 필요성\" 때문에 시작하게 되었다.\n<h2>2. Xamarin University 과정</h2>\nXamarin University 과정은 등록비가 1년에 $999이다. 부담스럽다.\n\n클래스가 많다. Xamarin 자체도 내용이 있지만 iOS, Android, Window 10 app의 개발도 다뤄야 하기 때문에 내용이 여러가지다. 그 중에 Certification과정이 따로 있다. 총 20개의 클래스로 구성되어 있고 그 내용은 주로 Xamarin.Forms로 앱을 개발하기 위한 모든 내용이 들어 있다. 소개와 셋업, Xamarin.iOS 2클래스, Xamarin.Android 2클래스 그리고 나머지는 모두 Xamarin.Forms 내용이다.\n\n내용은 정말 잘 만들었고 실제로 앱을 개발하기 위한 내용이 잘 정리되어 있다. 하지만 모든 강의는 영어로 진행된다. 아쉽다. 각 클래스에서는 실습도 잘 짜여서 들어가 있다. 강의와 실습이 번갈아 가면서 진행된다.\n\n다른 인터넷 강의와는 다른 점이 있다. 내가 원하는 시간에 동영상을 보면서 스스로 학습하는 과정은 20개 중에 8개다. 나머지는 강사가 원격에서 실시간으로 직접 진행한다. 여러 강사가 같은 클래스를 강의하고 강의 시간을 미리 정해놓았고 나는 들어야 하는 강의를 수강신청하고 그 시간에 들어야 한다. 여기서 또 하나 힘든 점은 선택할 수 있는 강사가 한정되어 있다. 왜냐면 어떤 강사는 주로 새벽에 강의를 잡기 때문이다. 나의 경우 2개의 강의는 어쩔 수 없이 밤 11시에 시작하는 강의를 들어야 했다. 장점은 질문을 할 수 있다. 영어로 ... 어떤 강사는 각 학생들을 인사를 시킨다. 영어로 ...\n<h2>3. Xamarin Certification</h2>\n20개의 강의를 다 들으면 하나를 더 해야 시험을 볼 수 있다. 메인 강사와 1:1 원격 미팅을 잡아서 시험에 대한 사전 테스트 겸, 상담 겸 30분간 얘기를 나눠야 한다. 이 세션에서 질문을 하거나 예상문제를 몇가지만 알려달라고 요청할 수 있고 시험준비를 어떻게 하면 좋을지 얘기를 들을 수 있다. 물론 영어로 ...\n\n1:1 세션까지 마치면 드디어 \"시험보기\" 버튼이 보인다. 시험은 총 150문제를 180분간 풀어야 하고 그 중 80% 이상을 맞춰야 통과가 된다. 웹 브라우저에서 그냥 시험이 치러지며 시간을 멈출수는 없다. 내 경우 3시간 동안 전화가 3번 와서 받느라고 시간을 낭비하고 거의 3시간을 다 썼다. 결과는 86% 맞춰서 턱걸이 했다.\n\n시험에 통과 했으니 특별한 혜택이 있는지 궁금해서 봤다. Private LinkedIn Xamarin University 그룹에 가입 할 수 있다. 이상. 1년이면 만료가 되기 때문에 갱신 과정도 있다. 여러가지 면에서 공신력을 갖추기 위한 노력과 장치들이 보인다.\n\n우리 사회도 편법이나 요령이 통하지 않게되면 이정도 노력으로 얻은 자격증은 어느정도 인정해주는 분위기가 생기겠지 ... 바램이다.\n\n<img class=\"size-large wp-image-4621 aligncenter\" src=\"/content/images/2017/01/Xamarin-University_Certificate-1024x724.png\" alt=\"\" width=\"640\" height=\"453\" />",
                "html": "<a href=\"https://www.xamarin.com/\">Xamarin</a>은 C#, .NET Framework, Visual Studio를 활용해서 크로스플랫폼(iOS, Android, Windows 10 app)을 개발 할 수 있는 플랫폼이다. Xamarin을 익히는 방법은 여러가지가 있지만 <a href=\"https://university.xamarin.com/\">Xamarin University</a>라는 사이트를 통해서 강의를 듣고 공부를 하는 방법이 있다. 물론 모든 강의가 영어로 진행되는 점은 아쉽지만 교육과정과 컨텐츠는 매우 훌륭하다. Xamarin University에서 관리하는 자격증이 하나 있는데 \"<a href=\"https://university.xamarin.com/certification\"><strong>Xamarin Certified Mobile Developer</strong></a>\"가 그 자격증이다. 약 2개월 동안 Xamarin University에서 강의를 듣고 오늘 자격증을 취득했다.\n<h2>1. IT 자격증을 대하는 자세</h2>\n개발자로 10년도 넘게 일하는 동안 '국제 IT 자격증'(뭐라고 불러야 하는지 모르겠다)을 몇 개 가지고 있다. 하지만 대한민국에서 자격증이 내 일자리를 보장해 주지도 않고 어느 누구도 자격증이 있다고 개발을 잘 한다고 인정해주지 않는다. 따라서 가끔 이력서에 빈 공란을 채워주는 역할을 했을 뿐 아무도, 심지어는 나 조차도 자격증을 활용하는 것에는 관심이 없다. 정확히 말하자면 나는 자격증으로 덕을 보고자 하는 마음이 전혀 없다.<p>그런데 왜 또 자격증 얘기인가? 현재 프로젝트에서 쓰고 있지 않은 기술을 공부하려면 의지력이 중요한데 바쁜 일상에서 그 의지력은 쉽게 사라진다. 이 때 덜컥 돈을 지불하고 자격증 시험을 한두 달 후로 잡아 버린다. 그러면 없던 의지력이 샘솟고 특히 그 날짜가 다가올수록 그 의지력은 점점 올라간다. 그 힘으로 나를 다그쳐서 끝내는 새로운 기술을 익힌다. 세상을 참 피곤하게 사는 방법이다. 피곤해서 나이들고는 잘 안한다.<p>Xamarin 자격증도 \"같은 이유 + 회사에서의 필요성\" 때문에 시작하게 되었다.\n<h2>2. Xamarin University 과정</h2>\nXamarin University 과정은 등록비가 1년에 $999이다. 부담스럽다.<p>클래스가 많다. Xamarin 자체도 내용이 있지만 iOS, Android, Window 10 app의 개발도 다뤄야 하기 때문에 내용이 여러가지다. 그 중에 Certification과정이 따로 있다. 총 20개의 클래스로 구성되어 있고 그 내용은 주로 Xamarin.Forms로 앱을 개발하기 위한 모든 내용이 들어 있다. 소개와 셋업, Xamarin.iOS 2클래스, Xamarin.Android 2클래스 그리고 나머지는 모두 Xamarin.Forms 내용이다.<p>내용은 정말 잘 만들었고 실제로 앱을 개발하기 위한 내용이 잘 정리되어 있다. 하지만 모든 강의는 영어로 진행된다. 아쉽다. 각 클래스에서는 실습도 잘 짜여서 들어가 있다. 강의와 실습이 번갈아 가면서 진행된다.<p>다른 인터넷 강의와는 다른 점이 있다. 내가 원하는 시간에 동영상을 보면서 스스로 학습하는 과정은 20개 중에 8개다. 나머지는 강사가 원격에서 실시간으로 직접 진행한다. 여러 강사가 같은 클래스를 강의하고 강의 시간을 미리 정해놓았고 나는 들어야 하는 강의를 수강신청하고 그 시간에 들어야 한다. 여기서 또 하나 힘든 점은 선택할 수 있는 강사가 한정되어 있다. 왜냐면 어떤 강사는 주로 새벽에 강의를 잡기 때문이다. 나의 경우 2개의 강의는 어쩔 수 없이 밤 11시에 시작하는 강의를 들어야 했다. 장점은 질문을 할 수 있다. 영어로 ... 어떤 강사는 각 학생들을 인사를 시킨다. 영어로 ...\n<h2>3. Xamarin Certification</h2>\n20개의 강의를 다 들으면 하나를 더 해야 시험을 볼 수 있다. 메인 강사와 1:1 원격 미팅을 잡아서 시험에 대한 사전 테스트 겸, 상담 겸 30분간 얘기를 나눠야 한다. 이 세션에서 질문을 하거나 예상문제를 몇가지만 알려달라고 요청할 수 있고 시험준비를 어떻게 하면 좋을지 얘기를 들을 수 있다. 물론 영어로 ...<p>1:1 세션까지 마치면 드디어 \"시험보기\" 버튼이 보인다. 시험은 총 150문제를 180분간 풀어야 하고 그 중 80% 이상을 맞춰야 통과가 된다. 웹 브라우저에서 그냥 시험이 치러지며 시간을 멈출수는 없다. 내 경우 3시간 동안 전화가 3번 와서 받느라고 시간을 낭비하고 거의 3시간을 다 썼다. 결과는 86% 맞춰서 턱걸이 했다.<p>시험에 통과 했으니 특별한 혜택이 있는지 궁금해서 봤다. Private LinkedIn Xamarin University 그룹에 가입 할 수 있다. 이상. 1년이면 만료가 되기 때문에 갱신 과정도 있다. 여러가지 면에서 공신력을 갖추기 위한 노력과 장치들이 보인다.<p>우리 사회도 편법이나 요령이 통하지 않게되면 이정도 노력으로 얻은 자격증은 어느정도 인정해주는 분위기가 생기겠지 ... 바램이다.<p><img class=\"size-large wp-image-4621 aligncenter\" src=\"/content/images/2017/01/Xamarin-University_Certificate-1024x724.png\" alt=\"\" width=\"640\" height=\"453\" />",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1485327868000,
                "created_by": 1,
                "updated_at": 1485327868000,
                "updated_by": 1,
                "published_at": 1485327868000,
                "published_by": 1
            },
            {
                "id": 4791,
                "title": "Azure에 Elastic Stack을 빠르게 구축하는 방법",
                "slug": "azure%ec%97%90-elastic-stack%ec%9d%84-%eb%b9%a0%eb%a5%b4%ea%b2%8c-%ea%b5%ac%ec%b6%95%ed%95%98%eb%8a%94-%eb%b0%a9%eb%b2%95",
                "markdown": "요즘 분산형 검색엔진으로 큰 관심을 받고 많이 사용하고 있는 제품이 Elastic사의 <a href=\"https://www.elastic.co/kr/\">Elasticsearch</a> 이다. 기본 검색엔진의 기능, 실시간으로 로그를 쌓고 분석하는 용도 등으로 사용되며 클러스터에 노드를 추가하는 것만으로도 확장이 가능해서 대용량의 시스템 구성에 적합하다. 검색엔진인 Elasticsearch, 데이터 시각화 제품인 Kibana, 데이터를 수집하는 Beats 와 Logstash 가 모여서 Elastic Stack이라는 오픈소스 패키지다. 여기에 구매를 해야하는 <a href=\"https://www.elastic.co/kr/products/x-pack\">X-Pack</a> 제품이 있다.\n\nAzure에서 Elasticsearch를 설치하려면 리눅스 가상머신을 만들면서 가상네트워크를 구성해야 한다. Elasticsearch의 데이터 노드, 클라이언트 노드, 마스터 노드를 설정하고 클러스터를 구성해야 하는데 이 과정이 2-3시간은 걸린다.  보단 쉽고 빠르게 구축하는 방법은 없을까?\n\n<a href=\"https://azuremarketplace.microsoft.com/ko-kr/marketplace/\">Azure에는 마켓플레이스</a>가 있다. 전세계 소프트웨어사, 솔루션사가 자신의 제품을 Azure 마켓플레이스에 올려서 Azure 사용자들이 몇 가지 설명만으로 해당 제품을 쉽게  사용하도록 할 수 있다. <a href=\"https://azuremarketplace.microsoft.com/ko-kr/marketplace/apps/elastic.elasticsearch?tab=Overview\">Elasticsearch 도 Azure Maketplace</a>에 있으니 여기에서 시작하면 매우 빠르게 설치를 할 수 있다. 라이센스는 BYOL (Bring Your Own License)로 별도록 Elastic에서 구매를 하면 된다.\n\n<img class=\"aligncenter size-large wp-image-4821\" src=\"/content/images/2017/02/elasticsearch-azure-marketplace-1024x707.png\" alt=\"\" width=\"640\" height=\"442\" />\n\n지금 받기를 누르거나 Azure portal 마켓플레이스에서 검색 후 시작 할 수 있다. 지금 받기를 누르면 Azure Portal이 뜨고 로그인 하면 즉시 설정 화면으로 들어간다. 총 8단계를 거치는데 데이터 노드의 수, 클라이언트 노드의 수, VM 사이즈, 로그인 비밀번호 등의 설정을 해주면 된다. 설정값에 따라 다르겠지만 아래 그림과 같은 구성이 된다.  설정한 노드의 수 만큼 VM들이 만들어지고 가상네트워크와 부하분산기(Load Balancer)가 만들어 진다. 마스터 노드와 데이터노드를 같이 쓸 수 있고 클라이언트 노드는 만들지 않을 수 있다. 그럼 좀더 단순한 구성이 나온다.\n\n&nbsp;\n\n<img class=\"aligncenter size-full wp-image-4831\" src=\"/content/images/2017/02/elasticsearch-azure-diagram.png\" alt=\"\" width=\"974\" height=\"802\" />\n\n&nbsp;\n\nJumpbox를 만들수 있다.  Jumpbox의 용도는 구성된 모든 VM들이 가상네트워크 안에 들어있고 Public IP를 가지지 않기 때문에 SSH 접속을 할 수 없는데 Public IP를 가지고 있는 Jumpbox를 통해서 접속해서 운영을 하는 것이다. Jumpbox를 두는 것이 각각 Public IP를 주는 것보다 보안상 안전하다. 비용을 아끼기 위해서 평소에는 꺼두는 것도 요령이다.\n\n이 전체를 만드는 시간이 15분정도 걸린 것 같다. 이제 인프라가 만들어졌으니 Elasticsearch를 사용하면 된다. 개발만 신경쓰면 된다.\n\n&nbsp;",
                "html": "요즘 분산형 검색엔진으로 큰 관심을 받고 많이 사용하고 있는 제품이 Elastic사의 <a href=\"https://www.elastic.co/kr/\">Elasticsearch</a> 이다. 기본 검색엔진의 기능, 실시간으로 로그를 쌓고 분석하는 용도 등으로 사용되며 클러스터에 노드를 추가하는 것만으로도 확장이 가능해서 대용량의 시스템 구성에 적합하다. 검색엔진인 Elasticsearch, 데이터 시각화 제품인 Kibana, 데이터를 수집하는 Beats 와 Logstash 가 모여서 Elastic Stack이라는 오픈소스 패키지다. 여기에 구매를 해야하는 <a href=\"https://www.elastic.co/kr/products/x-pack\">X-Pack</a> 제품이 있다.<p>Azure에서 Elasticsearch를 설치하려면 리눅스 가상머신을 만들면서 가상네트워크를 구성해야 한다. Elasticsearch의 데이터 노드, 클라이언트 노드, 마스터 노드를 설정하고 클러스터를 구성해야 하는데 이 과정이 2-3시간은 걸린다.  보단 쉽고 빠르게 구축하는 방법은 없을까?<p><a href=\"https://azuremarketplace.microsoft.com/ko-kr/marketplace/\">Azure에는 마켓플레이스</a>가 있다. 전세계 소프트웨어사, 솔루션사가 자신의 제품을 Azure 마켓플레이스에 올려서 Azure 사용자들이 몇 가지 설명만으로 해당 제품을 쉽게  사용하도록 할 수 있다. <a href=\"https://azuremarketplace.microsoft.com/ko-kr/marketplace/apps/elastic.elasticsearch?tab=Overview\">Elasticsearch 도 Azure Maketplace</a>에 있으니 여기에서 시작하면 매우 빠르게 설치를 할 수 있다. 라이센스는 BYOL (Bring Your Own License)로 별도록 Elastic에서 구매를 하면 된다.<p><img class=\"aligncenter size-large wp-image-4821\" src=\"/content/images/2017/02/elasticsearch-azure-marketplace-1024x707.png\" alt=\"\" width=\"640\" height=\"442\" /><p>지금 받기를 누르거나 Azure portal 마켓플레이스에서 검색 후 시작 할 수 있다. 지금 받기를 누르면 Azure Portal이 뜨고 로그인 하면 즉시 설정 화면으로 들어간다. 총 8단계를 거치는데 데이터 노드의 수, 클라이언트 노드의 수, VM 사이즈, 로그인 비밀번호 등의 설정을 해주면 된다. 설정값에 따라 다르겠지만 아래 그림과 같은 구성이 된다.  설정한 노드의 수 만큼 VM들이 만들어지고 가상네트워크와 부하분산기(Load Balancer)가 만들어 진다. 마스터 노드와 데이터노드를 같이 쓸 수 있고 클라이언트 노드는 만들지 않을 수 있다. 그럼 좀더 단순한 구성이 나온다.<p>&nbsp;<p><img class=\"aligncenter size-full wp-image-4831\" src=\"/content/images/2017/02/elasticsearch-azure-diagram.png\" alt=\"\" width=\"974\" height=\"802\" /><p>&nbsp;<p>Jumpbox를 만들수 있다.  Jumpbox의 용도는 구성된 모든 VM들이 가상네트워크 안에 들어있고 Public IP를 가지지 않기 때문에 SSH 접속을 할 수 없는데 Public IP를 가지고 있는 Jumpbox를 통해서 접속해서 운영을 하는 것이다. Jumpbox를 두는 것이 각각 Public IP를 주는 것보다 보안상 안전하다. 비용을 아끼기 위해서 평소에는 꺼두는 것도 요령이다.<p>이 전체를 만드는 시간이 15분정도 걸린 것 같다. 이제 인프라가 만들어졌으니 Elasticsearch를 사용하면 된다. 개발만 신경쓰면 된다.<p>&nbsp;",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1486790836000,
                "created_by": 1,
                "updated_at": 1486790836000,
                "updated_by": 1,
                "published_at": 1486790836000,
                "published_by": 1
            },
            {
                "id": 4951,
                "title": "Azure SQL Database의 백업과 복구",
                "slug": "azure-sql-database%ec%9d%98-%eb%b0%b1%ec%97%85%ea%b3%bc-%eb%b3%b5%ea%b5%ac",
                "markdown": "<a href=\"https://azure.microsoft.com/ko-kr/services/sql-database/\">Azure SQL database</a>는 <a href=\"https://ko.wikipedia.org/wiki/PaaS\">PaaS(Platform as a service)</a> 형태의 데이터베이스로 기본 인프라는 Azure가 책임을 지고 사용자는 Database를 생성해서 바로 테이블을 만들고 데이터를 넣어 사용할 수 있다. 요즘은 Database as a Service 라고도 부른다.\n\n아무리 인프라의 운영을 Azure가 책임지는 PaaS 라고 해도 장애가 없다고 장담할 수 없으며 사람의 실수로 인해 데이터가 망가지는 경우는 언제나 발생할 수 있다. 데이터가 문제가 발생하면 비즈니스에 치명적인 영향을 준다. 이런 상황에서 우리가 믿을 건 백업 밖에 없다. Azure SQL database는 PaaS 답게 추가비용 없이 자동으로 백업을 해준다. 자동 백업이 어떻게 진행되는지 그리고 복구는 어떻게 하는지 살펴보자.\n<h2>백업</h2>\nAzure SQL database의 백업 4가지에 대해서 살펴보자.\n<h3><a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-automated-backups\">자동백업</a></h3>\nAzure SQL database는 매주 전체 백업을 하고 매시간 증분백업과 5분간격으로 트랜젝션 로그 백업을 <a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-automated-backups\">자동으로 진행한다</a>. 그리고 가격 정책 계층에 따라서 백업의 보존기간이 다른데 기본(Basic)은 7일, 표준(Stadard)와 프리미엄(Premium)은 35일 동안 보존한다. 보존기간 내에는 모든 복원지점에서 복구를 할 수 있다. 보존을 하는 위치는 '쌍을 이루는 데이터센터'에 저장되는데 한국 중부의 데이터베이스라면 한국남부에 일본서버의 데이터베이스라면 일본동부에 저장된다.\n\nPortal에서 백업 진행상황을 보려면 개요 블레이드의 상단에 \"복원\" 버튼을 누르면 된다. 가장 오래된 복원지점을 확인 할 수있다.\n\n<img class=\"aligncenter size-large wp-image-4961\" src=\"/content/images/2017/02/azure-sql-server-backup-1024x760.jpg\" alt=\"\" width=\"640\" height=\"475\" />\n<h3><a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-long-term-retention\">장기 백업 보존</a></h3>\n대부분의 경우 자동 백업에 7일 또는 35일 보존기간은 적절하지만 상황에 따라서 백업 기간을 더 연장해야하는 경우가 있을 것이다. 이 경우 <a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-long-term-retention\">장기 백업 보존 기능</a>을 활용하면 최대 10년 동안 백업을 보관 할 수 있다. Azure SQL database를 만들때 '데이터베이스 서버'도 만들게 되어 있는데 (아이콘이 조금 다름) 장기 백업 보존은 데이터베이스 서버에 메뉴가 있다. 미리보기 조건에 동의를 먼저하고 <a href=\"https://docs.microsoft.com/ko-kr/azure/backup/backup-azure-arm-vms\">Recovery service vault</a> 자격 증명 모음을 만든 후 데이터 베이스를 선택하고 구성 버튼을 누르면 설정 블레이드가 나온다. 아래 그림은 일본 동부에 1년 동안 보관하는 설정이다.\n\n<img class=\"aligncenter size-large wp-image-4981\" src=\"/content/images/2017/02/azure-sql-long-term-backup-1024x648.jpg\" alt=\"\" width=\"640\" height=\"405\" />\n<h3><a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-geo-replication-overview\">활성 지역 복제</a></h3>\n<a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-geo-replication-overview\">활성지역 복제(Active Geo-Replication)</a>는 사실 백업이 아니라 Replication이다. 즉 다른 데이터센터에 똑같은 보조 데이터베이스를 만들고 지속적으로 싱크를 한다. 만약 원본 데이터베이스에 문제가 생기면 5초 이내에 복제된 데이터베이스로 마스터가 이전되어 빠르게 복구(Fail over) 된다.\n\nAzure SQL database에서 \"지역에서 복제\"를 누르면 설정 할 수 있고 역시 '쌍으로 연결된 데이터센터'가 보라색으로 추천된다. 지역을 선택하고 해당 지역에 데이터베이스 서버를 만들어주면 자동으로 보조 데이터베이스를 만들어 싱크한다. 보조 데이터베이스를 읽기가능으로 설정해놓으면 데이터 읽기를 분산해줄 수도 있다.\n\n<img class=\"aligncenter size-large wp-image-4971\" src=\"/content/images/2017/02/azure-sql-geo-dr-1024x922.jpg\" alt=\"\" width=\"640\" height=\"576\" />\n<h3>수동으로 백업</h3>\n<a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-export\">데이터베이스 내보내기 기능을 이용하여 BACPAC 파일로 수동 백업</a>이 가능하다. 백업된 파일은 스토리지에 저장된다. 이 방법은 데이터 마이그레이션 직전이나 대량으로 데이터가 생성되는 등 큰 변화의 전후 시점에 수행해 놓으면 좋다. 라이브 데이터베이스에서 내보내기를 하기가 부담스럽다면 복사를 하고 내보내기를 하면된다. 복사는 빠르게 이뤄진다. 내보내기는 크기에 따라서 오래걸릴 수 있다. 가끔 복사를 하지 않고 만든 BACPAC 파일이 복구 과정에서 오류를 발생하는 경우가 있으므로 복사 후 내보내기를 하는게 좋겠다. 이 기능은 포탈에서도 가능하고, SSMS(SQL Server Management Server), PowerShell로도 가능하다.\n\n기존 구포탈에서 제공되었던 Azure SQL Database Automated Export 기능은 2017년 3월 1일로 서비스가 종료되므로 사용하지 않는 것이 좋다.\n\n&nbsp;\n<h2>복구</h2>\n3가지 시나리오로 백업된 데이터베이스를 복구해보자.\n\n자세한 내용은 관련문서 <a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-get-started-backup-recovery\">SQL Database 백업 및 복원시작 문서</a>를 참조 바란다.\n<h3>1. 실수로 Azure SQL database를 삭제했을 때</h3>\n멀쩡한 데이터베이스를 삭제하는 일이 있을 수 없는 상황이지만 이런일이 실제로 일어난다. 데이터베이스만 삭제 했다면 금방 복구 할 수 있다. '데이터베이스 서버'의 개요 블레이드에 보면 삭제된 데이터베이스라는 메뉴가 보이는데 이 메뉴를 열어보면 삭제된 데이터베이스를 볼 수 있다. 이 백업을 선택하고 이름을 다시 정해준 후 복원하면 된다. 데이터베이스 서버를 삭제하면 이 방법을 쓸 수 없다. 만약 데이터베이스를 삭제한 상황이라면 최대한 빨리 Azure의 기술지원 티켓을 끊어서 서비스를 요청해야 한다.\n\n<img class=\"aligncenter size-large wp-image-4991\" src=\"/content/images/2017/02/azure-sql-deleted-db-1024x907.jpg\" alt=\"\" width=\"640\" height=\"567\" />\n\n&nbsp;\n<h3>2. 데이터가 깨져서 이전 백업으로 돌아가야 할 때</h3>\n어떤 이유에 의해서 또는 실수로 데이터 자체에 문제가 생길 수 있다. User 테이블을 지워버린 상황이 그런 예다. 데이터베이스를 선택하고 '개요' 블레이드에서 복원 버튼을 누르면 복원 메뉴가 나온다. 가장 오래된 복원 지점을 확인하고 원하는 날짜와 시각을 정해준 다음 데이터베이스 이름을 지정한 후 확인을 누르면 새로운 데이터베이스가 생성되면서 복원된다. 장기 백업 보존을 설정했다면 Azure 자격 증명 모음 백업에서 원하는 백업을 선택한 후에 확인을 누른다.\n<h3>3. 데이터센터의 데이터베이스 서비스에 장애가 발생하면</h3>\n활성지역 복제를 설정해 놨다면 보조 지역을 선택하고 '페일오버' 버튼을 누르면 5초 이내에 보조 데이터베이스가 주 데이터베이스로 변경되어 서비스된다. 그런 후에 애플리케이션에서 Connection String을 변경해서 Fail over된 데이터베이스에 연결되도록 설정해서 마무리한다.\n\n<img class=\"aligncenter size-large wp-image-5001\" src=\"/content/images/2017/02/azure-sql-fail-over-1024x673.jpg\" alt=\"\" width=\"640\" height=\"421\" />\n\n활성지역 복제가 아니라면 복원의 시점을 잘 생각해야 한다. 장애가 금방 복구될 예정이거나 문제를 금방 해결 할 수 있다면 기다리는게 더 좋은 선택일 수 있다.\n\n백업이 있다면 데이터베이스를 새로 만들면서 복원을 할 수 있다. 데이터베이스 만들기 블레이드에서 소스선택을 '백업'으로 지정하고 백업을 찾아서 만들 수 있다.\n\n<img class=\"aligncenter size-large wp-image-5021\" src=\"/content/images/2017/02/azure-sql-new-db-from-backup-1024x627.jpg\" alt=\"\" width=\"640\" height=\"392\" />\n<h3>4. <a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-disaster-recovery-drills\">재해복구 훈련</a></h3>\n운영중인 서비스에 데이터가 문제가 생겨 장애가 발생하면 마음이 급해지고 힘든 상황이 닥치게 된다. 마음을 가다듬고 복구에 임하려면 평소에 <a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-disaster-recovery-drills\">복구훈련</a>이 필요하다. 일분 일초가 급한상황에서 구글에서 문서를 찾는다면 그게 눈에 들어올리도 없고 정확한 판단이 어려울 수 있다. 프로덕션 환경의 데이터베이스를 복사해서 테스트 환경을 꾸밀 수 있다.\n\n관련문서: <a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-business-continuity\">Azure SQL 데이터베이스의 비즈니스 연속성 개요</a>\n\n&nbsp;",
                "html": "<a href=\"https://azure.microsoft.com/ko-kr/services/sql-database/\">Azure SQL database</a>는 <a href=\"https://ko.wikipedia.org/wiki/PaaS\">PaaS(Platform as a service)</a> 형태의 데이터베이스로 기본 인프라는 Azure가 책임을 지고 사용자는 Database를 생성해서 바로 테이블을 만들고 데이터를 넣어 사용할 수 있다. 요즘은 Database as a Service 라고도 부른다.<p>아무리 인프라의 운영을 Azure가 책임지는 PaaS 라고 해도 장애가 없다고 장담할 수 없으며 사람의 실수로 인해 데이터가 망가지는 경우는 언제나 발생할 수 있다. 데이터가 문제가 발생하면 비즈니스에 치명적인 영향을 준다. 이런 상황에서 우리가 믿을 건 백업 밖에 없다. Azure SQL database는 PaaS 답게 추가비용 없이 자동으로 백업을 해준다. 자동 백업이 어떻게 진행되는지 그리고 복구는 어떻게 하는지 살펴보자.\n<h2>백업</h2>\nAzure SQL database의 백업 4가지에 대해서 살펴보자.\n<h3><a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-automated-backups\">자동백업</a></h3>\nAzure SQL database는 매주 전체 백업을 하고 매시간 증분백업과 5분간격으로 트랜젝션 로그 백업을 <a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-automated-backups\">자동으로 진행한다</a>. 그리고 가격 정책 계층에 따라서 백업의 보존기간이 다른데 기본(Basic)은 7일, 표준(Stadard)와 프리미엄(Premium)은 35일 동안 보존한다. 보존기간 내에는 모든 복원지점에서 복구를 할 수 있다. 보존을 하는 위치는 '쌍을 이루는 데이터센터'에 저장되는데 한국 중부의 데이터베이스라면 한국남부에 일본서버의 데이터베이스라면 일본동부에 저장된다.<p>Portal에서 백업 진행상황을 보려면 개요 블레이드의 상단에 \"복원\" 버튼을 누르면 된다. 가장 오래된 복원지점을 확인 할 수있다.<p><img class=\"aligncenter size-large wp-image-4961\" src=\"/content/images/2017/02/azure-sql-server-backup-1024x760.jpg\" alt=\"\" width=\"640\" height=\"475\" />\n<h3><a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-long-term-retention\">장기 백업 보존</a></h3>\n대부분의 경우 자동 백업에 7일 또는 35일 보존기간은 적절하지만 상황에 따라서 백업 기간을 더 연장해야하는 경우가 있을 것이다. 이 경우 <a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-long-term-retention\">장기 백업 보존 기능</a>을 활용하면 최대 10년 동안 백업을 보관 할 수 있다. Azure SQL database를 만들때 '데이터베이스 서버'도 만들게 되어 있는데 (아이콘이 조금 다름) 장기 백업 보존은 데이터베이스 서버에 메뉴가 있다. 미리보기 조건에 동의를 먼저하고 <a href=\"https://docs.microsoft.com/ko-kr/azure/backup/backup-azure-arm-vms\">Recovery service vault</a> 자격 증명 모음을 만든 후 데이터 베이스를 선택하고 구성 버튼을 누르면 설정 블레이드가 나온다. 아래 그림은 일본 동부에 1년 동안 보관하는 설정이다.<p><img class=\"aligncenter size-large wp-image-4981\" src=\"/content/images/2017/02/azure-sql-long-term-backup-1024x648.jpg\" alt=\"\" width=\"640\" height=\"405\" />\n<h3><a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-geo-replication-overview\">활성 지역 복제</a></h3>\n<a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-geo-replication-overview\">활성지역 복제(Active Geo-Replication)</a>는 사실 백업이 아니라 Replication이다. 즉 다른 데이터센터에 똑같은 보조 데이터베이스를 만들고 지속적으로 싱크를 한다. 만약 원본 데이터베이스에 문제가 생기면 5초 이내에 복제된 데이터베이스로 마스터가 이전되어 빠르게 복구(Fail over) 된다.<p>Azure SQL database에서 \"지역에서 복제\"를 누르면 설정 할 수 있고 역시 '쌍으로 연결된 데이터센터'가 보라색으로 추천된다. 지역을 선택하고 해당 지역에 데이터베이스 서버를 만들어주면 자동으로 보조 데이터베이스를 만들어 싱크한다. 보조 데이터베이스를 읽기가능으로 설정해놓으면 데이터 읽기를 분산해줄 수도 있다.<p><img class=\"aligncenter size-large wp-image-4971\" src=\"/content/images/2017/02/azure-sql-geo-dr-1024x922.jpg\" alt=\"\" width=\"640\" height=\"576\" />\n<h3>수동으로 백업</h3>\n<a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-export\">데이터베이스 내보내기 기능을 이용하여 BACPAC 파일로 수동 백업</a>이 가능하다. 백업된 파일은 스토리지에 저장된다. 이 방법은 데이터 마이그레이션 직전이나 대량으로 데이터가 생성되는 등 큰 변화의 전후 시점에 수행해 놓으면 좋다. 라이브 데이터베이스에서 내보내기를 하기가 부담스럽다면 복사를 하고 내보내기를 하면된다. 복사는 빠르게 이뤄진다. 내보내기는 크기에 따라서 오래걸릴 수 있다. 가끔 복사를 하지 않고 만든 BACPAC 파일이 복구 과정에서 오류를 발생하는 경우가 있으므로 복사 후 내보내기를 하는게 좋겠다. 이 기능은 포탈에서도 가능하고, SSMS(SQL Server Management Server), PowerShell로도 가능하다.<p>기존 구포탈에서 제공되었던 Azure SQL Database Automated Export 기능은 2017년 3월 1일로 서비스가 종료되므로 사용하지 않는 것이 좋다.<p>&nbsp;\n<h2>복구</h2>\n3가지 시나리오로 백업된 데이터베이스를 복구해보자.<p>자세한 내용은 관련문서 <a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-get-started-backup-recovery\">SQL Database 백업 및 복원시작 문서</a>를 참조 바란다.\n<h3>1. 실수로 Azure SQL database를 삭제했을 때</h3>\n멀쩡한 데이터베이스를 삭제하는 일이 있을 수 없는 상황이지만 이런일이 실제로 일어난다. 데이터베이스만 삭제 했다면 금방 복구 할 수 있다. '데이터베이스 서버'의 개요 블레이드에 보면 삭제된 데이터베이스라는 메뉴가 보이는데 이 메뉴를 열어보면 삭제된 데이터베이스를 볼 수 있다. 이 백업을 선택하고 이름을 다시 정해준 후 복원하면 된다. 데이터베이스 서버를 삭제하면 이 방법을 쓸 수 없다. 만약 데이터베이스를 삭제한 상황이라면 최대한 빨리 Azure의 기술지원 티켓을 끊어서 서비스를 요청해야 한다.<p><img class=\"aligncenter size-large wp-image-4991\" src=\"/content/images/2017/02/azure-sql-deleted-db-1024x907.jpg\" alt=\"\" width=\"640\" height=\"567\" /><p>&nbsp;\n<h3>2. 데이터가 깨져서 이전 백업으로 돌아가야 할 때</h3>\n어떤 이유에 의해서 또는 실수로 데이터 자체에 문제가 생길 수 있다. User 테이블을 지워버린 상황이 그런 예다. 데이터베이스를 선택하고 '개요' 블레이드에서 복원 버튼을 누르면 복원 메뉴가 나온다. 가장 오래된 복원 지점을 확인하고 원하는 날짜와 시각을 정해준 다음 데이터베이스 이름을 지정한 후 확인을 누르면 새로운 데이터베이스가 생성되면서 복원된다. 장기 백업 보존을 설정했다면 Azure 자격 증명 모음 백업에서 원하는 백업을 선택한 후에 확인을 누른다.\n<h3>3. 데이터센터의 데이터베이스 서비스에 장애가 발생하면</h3>\n활성지역 복제를 설정해 놨다면 보조 지역을 선택하고 '페일오버' 버튼을 누르면 5초 이내에 보조 데이터베이스가 주 데이터베이스로 변경되어 서비스된다. 그런 후에 애플리케이션에서 Connection String을 변경해서 Fail over된 데이터베이스에 연결되도록 설정해서 마무리한다.<p><img class=\"aligncenter size-large wp-image-5001\" src=\"/content/images/2017/02/azure-sql-fail-over-1024x673.jpg\" alt=\"\" width=\"640\" height=\"421\" /><p>활성지역 복제가 아니라면 복원의 시점을 잘 생각해야 한다. 장애가 금방 복구될 예정이거나 문제를 금방 해결 할 수 있다면 기다리는게 더 좋은 선택일 수 있다.<p>백업이 있다면 데이터베이스를 새로 만들면서 복원을 할 수 있다. 데이터베이스 만들기 블레이드에서 소스선택을 '백업'으로 지정하고 백업을 찾아서 만들 수 있다.<p><img class=\"aligncenter size-large wp-image-5021\" src=\"/content/images/2017/02/azure-sql-new-db-from-backup-1024x627.jpg\" alt=\"\" width=\"640\" height=\"392\" />\n<h3>4. <a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-disaster-recovery-drills\">재해복구 훈련</a></h3>\n운영중인 서비스에 데이터가 문제가 생겨 장애가 발생하면 마음이 급해지고 힘든 상황이 닥치게 된다. 마음을 가다듬고 복구에 임하려면 평소에 <a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-disaster-recovery-drills\">복구훈련</a>이 필요하다. 일분 일초가 급한상황에서 구글에서 문서를 찾는다면 그게 눈에 들어올리도 없고 정확한 판단이 어려울 수 있다. 프로덕션 환경의 데이터베이스를 복사해서 테스트 환경을 꾸밀 수 있다.<p>관련문서: <a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-business-continuity\">Azure SQL 데이터베이스의 비즈니스 연속성 개요</a><p>&nbsp;",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1487207470000,
                "created_by": 1,
                "updated_at": 1487207470000,
                "updated_by": 1,
                "published_at": 1487207470000,
                "published_by": 1
            },
            {
                "id": 5104,
                "title": "GPU가 탑재된 Azure 가상컴퓨터 N 시리즈",
                "slug": "gpu%ea%b0%80-%ed%83%91%ec%9e%ac%eb%90%9c-azure-%ea%b0%80%ec%83%81%ec%bb%b4%ed%93%a8%ed%84%b0-n-%ec%8b%9c%eb%a6%ac%ec%a6%88",
                "markdown": "Azure의 가상컴퓨터 중에 NVIDIA GPU가 탑재된 N 시리즈 가상컴퓨터가 있다. 비주얼 시뮬레이션, 다이나믹 랜더링, 요즘 많이 얘기되고 있는 딥러닝 등 GPU가 많이 쓰이는 작업에 사용할 수 있는 가상컴퓨터다. NC 시리즈는 NVIDIA Tesla K80 GPU가 달려있고 NV 시리즈는 NVIDIA Tesla M60 GPU가 달려있다. 각 시리즈의 용도와 사용사례는 <a href=\"https://azure.microsoft.com/en-us/blog/azure-n-series-general-availability-on-december-1/\">Azure N-Series: General availability on December 1</a> 글을 참조 바란다.\n\n이 글에서는 실제로 N 시리즈 가상컴퓨터를 만들면서 얻은 정보에 대한 것이다.\n<h2>사용 가능한 지역</h2>\n아직은 모든 Azure 데이터 센터에서 사용 가능하지 않다.\n<ul>\n \t<li>NC 시리즈 사용 가능 지역 - East US, North Central US, South Central US, Southeast Asia, West Europe, South Central US</li>\n \t<li>NV 시리즈 사용 가능지역 - South Central US, East US</li>\n</ul>\n<h2>HDD 만 지원</h2>\n아직 Premium(SSD) 디스크 지원을 하지 않는다. 따라서 Azure Portal에서 N시리즈 가상컴퓨터를 생성할때 <em>디스크 타입을 HDD로 설정해야 N시리즈 타입이 보이고 선택할 수 있다</em>.\n데이터 디스크도 SSD를 지원하지 않아서 HDD를 붙여야 한다.\n<h2>현재 지원하는 OS</h2>\n<ul>\n \t<li>Windows Server 2012 R2</li>\n \t<li>Windows Server 2016</li>\n \t<li>Ubuntu 16.04 LTS - NC 시리즈만 지원</li>\n</ul>\n<h2>NVIDA 디바이스 드라이버를 별도로 설치</h2>\n가상컴퓨터를 만들 때 사용하는 이미지는 NVIDIA 디바이스 드라이버가 설치가 안된 이미지이기 때문에 N시리즈 가상컴퓨터를 생성 후에 별도로 드라이버를 설치해야 한다. 설치는 아래 문서에 다운로드 링크와 설치방법이 자세히 나와 있다. 참고로 NC / NV 시리즈를 헷갈려서 잘 못 설치했더니 부팅이 안된다.\n<ul>\n \t<li><a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machines/virtual-machines-windows-n-series-driver-setup\">윈도우 드라이버 셋업</a></li>\n \t<li><a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machines/virtual-machines-linux-n-series-driver-setup\">리눅스 드라이버 셋업</a></li>\n</ul>\n<img class=\"alignnone size-full wp-image-5105\" src=\"/content/images/2017/03/azure-n-series-driver.png\" alt=\"\" width=\"1442\" height=\"753\" />\n\n&nbsp;",
                "html": "Azure의 가상컴퓨터 중에 NVIDIA GPU가 탑재된 N 시리즈 가상컴퓨터가 있다. 비주얼 시뮬레이션, 다이나믹 랜더링, 요즘 많이 얘기되고 있는 딥러닝 등 GPU가 많이 쓰이는 작업에 사용할 수 있는 가상컴퓨터다. NC 시리즈는 NVIDIA Tesla K80 GPU가 달려있고 NV 시리즈는 NVIDIA Tesla M60 GPU가 달려있다. 각 시리즈의 용도와 사용사례는 <a href=\"https://azure.microsoft.com/en-us/blog/azure-n-series-general-availability-on-december-1/\">Azure N-Series: General availability on December 1</a> 글을 참조 바란다.<p>이 글에서는 실제로 N 시리즈 가상컴퓨터를 만들면서 얻은 정보에 대한 것이다.\n<h2>사용 가능한 지역</h2>\n아직은 모든 Azure 데이터 센터에서 사용 가능하지 않다.\n<ul>\n \t<li>NC 시리즈 사용 가능 지역 - East US, North Central US, South Central US, Southeast Asia, West Europe, South Central US</li>\n \t<li>NV 시리즈 사용 가능지역 - South Central US, East US</li>\n</ul>\n<h2>HDD 만 지원</h2>\n아직 Premium(SSD) 디스크 지원을 하지 않는다. 따라서 Azure Portal에서 N시리즈 가상컴퓨터를 생성할때 <em>디스크 타입을 HDD로 설정해야 N시리즈 타입이 보이고 선택할 수 있다</em>.\n데이터 디스크도 SSD를 지원하지 않아서 HDD를 붙여야 한다.\n<h2>현재 지원하는 OS</h2>\n<ul>\n \t<li>Windows Server 2012 R2</li>\n \t<li>Windows Server 2016</li>\n \t<li>Ubuntu 16.04 LTS - NC 시리즈만 지원</li>\n</ul>\n<h2>NVIDA 디바이스 드라이버를 별도로 설치</h2>\n가상컴퓨터를 만들 때 사용하는 이미지는 NVIDIA 디바이스 드라이버가 설치가 안된 이미지이기 때문에 N시리즈 가상컴퓨터를 생성 후에 별도로 드라이버를 설치해야 한다. 설치는 아래 문서에 다운로드 링크와 설치방법이 자세히 나와 있다. 참고로 NC / NV 시리즈를 헷갈려서 잘 못 설치했더니 부팅이 안된다.\n<ul>\n \t<li><a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machines/virtual-machines-windows-n-series-driver-setup\">윈도우 드라이버 셋업</a></li>\n \t<li><a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machines/virtual-machines-linux-n-series-driver-setup\">리눅스 드라이버 셋업</a></li>\n</ul>\n<img class=\"alignnone size-full wp-image-5105\" src=\"/content/images/2017/03/azure-n-series-driver.png\" alt=\"\" width=\"1442\" height=\"753\" /><p>&nbsp;",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1489133888000,
                "created_by": 1,
                "updated_at": 1489133888000,
                "updated_by": 1,
                "published_at": 1489133888000,
                "published_by": 1
            },
            {
                "id": 5118,
                "title": "Azure Automation으로 퇴근시간에 자동으로 가상컴퓨터 끄기",
                "slug": "azure-automation-turn-off-vm",
                "markdown": "클라우드 컴퓨팅 환경에서는 비용을 최소화 하기 위한 노력이 필요하다. 가끔 스토리지에 쓰지 않는 파일이나 백업이 들어 있다던지 테스트로 만든 가상머신들이 삭제되지 않고 쌓여 있는 걸 볼 수 있다. 신경써서 관리 하지 않으면 어느 순간 \"그냥 서버사서 쓰는게 더 싼거 아니야\"라는 의견이 나올 수도 있다. 클라우드 서비스 비용을 아끼려는 노력이 몸에 베인 팀에서는 가끔 밤에 테스트용 서버는 자동으로 끌 수 없는지 문의가 오기도 한다. 이 글에서 Azure Automation을 이용해서 저녁 7시에 특정 Resource Group에 들어 있는 테스트용 가상 컴퓨터들을 Stop 시켜 밤새 쓸데없이 나가는 비용을 줄이는 방법에 대해서 알아보자.\n<h3>Azure Automation</h3>\nAzure Automation은 Azure를 관리할 때 자주 그리고 수동으로 해야하는 일을 자동화 시키는데 유용하다. 예를들어 밤시간에는 방문자가 적은 웹 애플리케이션이라면 새벽시간에 낮은 가격대로 내렸다가 다시 아침에는 원래 가격으로 올린다던지 특정 리소스에서 발생하는 로그를 모으거나 Azure SQL 데이터베이스의 쿼리를 수행해서 데이터를 정리하는 등 반복적인 관리작업들이 있다. Azure Automation은 이런 작업들을 Powershell을 이용하여 수행하며 그래픽 툴을 제공하기 때문에 PowerShell 코드 작성을 최소화해서 구현해 낼 수 있다. Runbook이라는 작업들의 집합 단위로 수행되는데 Runbook 갤러리가 있어서 이미 만들어져 있는 Runbook을 가져다 쓸 수 있다. Runbook을 어떻게 만들고 실행하는지는 \"<a href=\"https://docs.microsoft.com/ko-kr/azure/automation/automation-first-runbook-graphical\">내 첫 번째 그래픽 Runbook</a>\" 문서를 천천히 따라하면 전체 내용을 파악할 수 있다.\n<h3>Azure Automation 만들기</h3>\n리소스그룹(Resource Group)을 하나 만들어서 Azure Automation 계정을 하나 만들자. Automation 계정과 Runbook을 모두 하나의 리소스그룹에 관리하면 깔끔하다. 현재(2017-04-06)은 Korea Central이나 Korea South 지역에는 없다. 다른 지역에 만들자. 트래픽이 오가는 리소스는 아니기 때문에 다른 지역이라도 비용이 크게 발생하지는 않을 것이다. 만들때 꼭 \"Azure 실행 계정 만들기\"를 예로 선택해야 한다. 실행 계정은 PowerShell이 Azure에서 일을 하기 위해서 로그인을 자동으로 해주는 역할을 한다.\n\n<a href=\"/content/images/2017/04/create-automation.png\"><img class=\"size-large wp-image-5119 aligncenter\" src=\"/content/images/2017/04/create-automation-1024x552.png\" alt=\"\" width=\"640\" height=\"345\" /></a>\n\n&nbsp;\n<h3>갤러리에서 \"StopAzureV2Vm\" Runbook 가져오기</h3>\nAutomation이 만들어 졌다. VM을 특정 시간에 자동으로 Stop 시키는 Runbook을 갤러리에서 찾아서 가져오자. 새로만든 Automation에서 Runbook을 선택한 후 \"갤러리 찾아보기\"를 눌러 \"Stop Azure V2 VMs\"를 선택해서 \"가져오기\"를 눌러 가져온다. 이 Runbook은 그래픽 타입이다. 이렇게 가져오면 작성상태가 \"새로 만들기\"로 표시되고 아직 게시되지 않은 상태다.\n\n<a href=\"/content/images/2017/04/automation-gallery.png\"><img class=\"size-large wp-image-5120 aligncenter\" src=\"/content/images/2017/04/automation-gallery-1024x384.png\" alt=\"\" width=\"640\" height=\"240\" /></a>\n<h3>StopAzureV2Vm 설정</h3>\n가져온 Runbook을 눌러서 상세정보를 표시하고 \"편집\" 버튼을 누른다. 이 화면은 Runbook을 편집하는 화면이고 오른쪽에 순서도 처럼 생긴 프로세스가 표시되고 왼쪽에 사용할 수 있는 PowerShell Cmdlet 등이 표시된다. 왼쪽의 라이브러리의 항목을 그래픽화면에 추가하고 화살표를 연결한 후 파라미터를 지정하는 식으로 편집 할 수 있다. 지금은 잘 만들어진 StopAzureV2Vm Runbook을 그대로 사용할 것이기 때문에 편집하지 않고 바로 \"게시\" 버튼을 눌러 게시한다.\n\n<a href=\"/content/images/2017/04/publish-automation.png\"><img class=\"size-large wp-image-5121 aligncenter\" src=\"/content/images/2017/04/publish-automation-1024x598.png\" alt=\"\" width=\"640\" height=\"374\" /></a>\n<h3>Runbook 테스트</h3>\n게시된 화면에서 시작을 누르면 바로 실행이 된다. 테스트로 시작버튼을 눌러 실행해보자. 매개변수를 입력하게 되어 있다. 특정 리소스 그룹에 들어있는 모든 VM을 끄고 싶으면 RESOURCEGROUPNAME에 입력하고 특정 VM을 끄고 싶으면 VM이름을 입력한다. AZURECONNECTIONASSETNAME 은 기본값으로 남겨둡니다. 기본값으로 Azure에 로그인 됩니다. \"확인\"을 누르면 큐에서 대기하다가 실행이 된다. 완료되면 출력을 눌러 로그를 확인해본다. 문제없이 잘 작동한다면 이제 특정 시간에 실행 되도록 스케줄링만 해주면 된다.\n\n<a href=\"/content/images/2017/04/start-automation.png\"><img class=\"size-large wp-image-5122 aligncenter\" src=\"/content/images/2017/04/start-automation-1024x566.png\" alt=\"\" width=\"640\" height=\"354\" /></a>\n<h3>Runbook 실행 일정 설정</h3>\n\"일정\"버튼을 눌르고 \"일정추가\"버튼을 누른다. 매일 오후 7시에 실행이 되도록 그림과 같이 설정한다. 그리고 매개 변수에 리소스그룹이름이나 가상컴퓨터 이름을 입력한다. 모든 설정이 끝났다. 내일 아침에 잘 실행되었는지 확인 하면 된다. 모든 개발자와 시스템 엔지니어들이 6시에 퇴근하고 이렇게 설정된 Automation이 혼자 실행되길 바래본다.\n\n<a href=\"/content/images/2017/04/scheduling-atomatoin.png\"><img class=\"size-large wp-image-5123 aligncenter\" src=\"/content/images/2017/04/scheduling-atomatoin-1024x514.png\" alt=\"\" width=\"640\" height=\"321\" /></a>\n\n&nbsp;",
                "html": "클라우드 컴퓨팅 환경에서는 비용을 최소화 하기 위한 노력이 필요하다. 가끔 스토리지에 쓰지 않는 파일이나 백업이 들어 있다던지 테스트로 만든 가상머신들이 삭제되지 않고 쌓여 있는 걸 볼 수 있다. 신경써서 관리 하지 않으면 어느 순간 \"그냥 서버사서 쓰는게 더 싼거 아니야\"라는 의견이 나올 수도 있다. 클라우드 서비스 비용을 아끼려는 노력이 몸에 베인 팀에서는 가끔 밤에 테스트용 서버는 자동으로 끌 수 없는지 문의가 오기도 한다. 이 글에서 Azure Automation을 이용해서 저녁 7시에 특정 Resource Group에 들어 있는 테스트용 가상 컴퓨터들을 Stop 시켜 밤새 쓸데없이 나가는 비용을 줄이는 방법에 대해서 알아보자.\n<h3>Azure Automation</h3>\nAzure Automation은 Azure를 관리할 때 자주 그리고 수동으로 해야하는 일을 자동화 시키는데 유용하다. 예를들어 밤시간에는 방문자가 적은 웹 애플리케이션이라면 새벽시간에 낮은 가격대로 내렸다가 다시 아침에는 원래 가격으로 올린다던지 특정 리소스에서 발생하는 로그를 모으거나 Azure SQL 데이터베이스의 쿼리를 수행해서 데이터를 정리하는 등 반복적인 관리작업들이 있다. Azure Automation은 이런 작업들을 Powershell을 이용하여 수행하며 그래픽 툴을 제공하기 때문에 PowerShell 코드 작성을 최소화해서 구현해 낼 수 있다. Runbook이라는 작업들의 집합 단위로 수행되는데 Runbook 갤러리가 있어서 이미 만들어져 있는 Runbook을 가져다 쓸 수 있다. Runbook을 어떻게 만들고 실행하는지는 \"<a href=\"https://docs.microsoft.com/ko-kr/azure/automation/automation-first-runbook-graphical\">내 첫 번째 그래픽 Runbook</a>\" 문서를 천천히 따라하면 전체 내용을 파악할 수 있다.\n<h3>Azure Automation 만들기</h3>\n리소스그룹(Resource Group)을 하나 만들어서 Azure Automation 계정을 하나 만들자. Automation 계정과 Runbook을 모두 하나의 리소스그룹에 관리하면 깔끔하다. 현재(2017-04-06)은 Korea Central이나 Korea South 지역에는 없다. 다른 지역에 만들자. 트래픽이 오가는 리소스는 아니기 때문에 다른 지역이라도 비용이 크게 발생하지는 않을 것이다. 만들때 꼭 \"Azure 실행 계정 만들기\"를 예로 선택해야 한다. 실행 계정은 PowerShell이 Azure에서 일을 하기 위해서 로그인을 자동으로 해주는 역할을 한다.<p><a href=\"/content/images/2017/04/create-automation.png\"><img class=\"size-large wp-image-5119 aligncenter\" src=\"/content/images/2017/04/create-automation-1024x552.png\" alt=\"\" width=\"640\" height=\"345\" /></a><p>&nbsp;\n<h3>갤러리에서 \"StopAzureV2Vm\" Runbook 가져오기</h3>\nAutomation이 만들어 졌다. VM을 특정 시간에 자동으로 Stop 시키는 Runbook을 갤러리에서 찾아서 가져오자. 새로만든 Automation에서 Runbook을 선택한 후 \"갤러리 찾아보기\"를 눌러 \"Stop Azure V2 VMs\"를 선택해서 \"가져오기\"를 눌러 가져온다. 이 Runbook은 그래픽 타입이다. 이렇게 가져오면 작성상태가 \"새로 만들기\"로 표시되고 아직 게시되지 않은 상태다.<p><a href=\"/content/images/2017/04/automation-gallery.png\"><img class=\"size-large wp-image-5120 aligncenter\" src=\"/content/images/2017/04/automation-gallery-1024x384.png\" alt=\"\" width=\"640\" height=\"240\" /></a>\n<h3>StopAzureV2Vm 설정</h3>\n가져온 Runbook을 눌러서 상세정보를 표시하고 \"편집\" 버튼을 누른다. 이 화면은 Runbook을 편집하는 화면이고 오른쪽에 순서도 처럼 생긴 프로세스가 표시되고 왼쪽에 사용할 수 있는 PowerShell Cmdlet 등이 표시된다. 왼쪽의 라이브러리의 항목을 그래픽화면에 추가하고 화살표를 연결한 후 파라미터를 지정하는 식으로 편집 할 수 있다. 지금은 잘 만들어진 StopAzureV2Vm Runbook을 그대로 사용할 것이기 때문에 편집하지 않고 바로 \"게시\" 버튼을 눌러 게시한다.<p><a href=\"/content/images/2017/04/publish-automation.png\"><img class=\"size-large wp-image-5121 aligncenter\" src=\"/content/images/2017/04/publish-automation-1024x598.png\" alt=\"\" width=\"640\" height=\"374\" /></a>\n<h3>Runbook 테스트</h3>\n게시된 화면에서 시작을 누르면 바로 실행이 된다. 테스트로 시작버튼을 눌러 실행해보자. 매개변수를 입력하게 되어 있다. 특정 리소스 그룹에 들어있는 모든 VM을 끄고 싶으면 RESOURCEGROUPNAME에 입력하고 특정 VM을 끄고 싶으면 VM이름을 입력한다. AZURECONNECTIONASSETNAME 은 기본값으로 남겨둡니다. 기본값으로 Azure에 로그인 됩니다. \"확인\"을 누르면 큐에서 대기하다가 실행이 된다. 완료되면 출력을 눌러 로그를 확인해본다. 문제없이 잘 작동한다면 이제 특정 시간에 실행 되도록 스케줄링만 해주면 된다.<p><a href=\"/content/images/2017/04/start-automation.png\"><img class=\"size-large wp-image-5122 aligncenter\" src=\"/content/images/2017/04/start-automation-1024x566.png\" alt=\"\" width=\"640\" height=\"354\" /></a>\n<h3>Runbook 실행 일정 설정</h3>\n\"일정\"버튼을 눌르고 \"일정추가\"버튼을 누른다. 매일 오후 7시에 실행이 되도록 그림과 같이 설정한다. 그리고 매개 변수에 리소스그룹이름이나 가상컴퓨터 이름을 입력한다. 모든 설정이 끝났다. 내일 아침에 잘 실행되었는지 확인 하면 된다. 모든 개발자와 시스템 엔지니어들이 6시에 퇴근하고 이렇게 설정된 Automation이 혼자 실행되길 바래본다.<p><a href=\"/content/images/2017/04/scheduling-atomatoin.png\"><img class=\"size-large wp-image-5123 aligncenter\" src=\"/content/images/2017/04/scheduling-atomatoin-1024x514.png\" alt=\"\" width=\"640\" height=\"321\" /></a><p>&nbsp;",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1491473772000,
                "created_by": 1,
                "updated_at": 1491473772000,
                "updated_by": 1,
                "published_at": 1491473772000,
                "published_by": 1
            },
            {
                "id": 5134,
                "title": "퇴근시간에 자동으로 가상컴퓨터 끄기 2",
                "slug": "%ed%87%b4%ea%b7%bc%ec%8b%9c%ea%b0%84%ec%97%90-%ec%9e%90%eb%8f%99%ec%9c%bc%eb%a1%9c-%ea%b0%80%ec%83%81%ec%bb%b4%ed%93%a8%ed%84%b0-%eb%81%84%ea%b8%b0-2",
                "markdown": "<a href=\"http://ilseokoh.com/2017/04/06/azure-automation%ec%9c%bc%eb%a1%9c-%ed%87%b4%ea%b7%bc%ec%8b%9c%ea%b0%84%ec%97%90-%ec%9e%90%eb%8f%99%ec%9c%bc%eb%a1%9c-%ea%b0%80%ec%83%81%ec%bb%b4%ed%93%a8%ed%84%b0-%eb%81%84%ea%b8%b0/\">Azure Atomation으로 가상컴퓨터 자동으로 종료할 수 있다는 포스트</a>를 작성한 후 신고가 들어왔다. 이미 VM에 그런 기능이 있었다. 포탈에서 너무 쉽게 제공이 되고 있었다. 괜히 Automation으로 어렵게 풀지 말고 이 메뉴를 이용하면 되겠다.\n\n<a href=\"/content/images/2017/04/azure-vm-auto-shutdown.png\"><img class=\"size-large wp-image-5135 aligncenter\" src=\"/content/images/2017/04/azure-vm-auto-shutdown-1024x611.png\" alt=\"\" width=\"640\" height=\"382\" /></a>",
                "html": "<a href=\"http://ilseokoh.com/2017/04/06/azure-automation%ec%9c%bc%eb%a1%9c-%ed%87%b4%ea%b7%bc%ec%8b%9c%ea%b0%84%ec%97%90-%ec%9e%90%eb%8f%99%ec%9c%bc%eb%a1%9c-%ea%b0%80%ec%83%81%ec%bb%b4%ed%93%a8%ed%84%b0-%eb%81%84%ea%b8%b0/\">Azure Atomation으로 가상컴퓨터 자동으로 종료할 수 있다는 포스트</a>를 작성한 후 신고가 들어왔다. 이미 VM에 그런 기능이 있었다. 포탈에서 너무 쉽게 제공이 되고 있었다. 괜히 Automation으로 어렵게 풀지 말고 이 메뉴를 이용하면 되겠다.<p><a href=\"/content/images/2017/04/azure-vm-auto-shutdown.png\"><img class=\"size-large wp-image-5135 aligncenter\" src=\"/content/images/2017/04/azure-vm-auto-shutdown-1024x611.png\" alt=\"\" width=\"640\" height=\"382\" /></a>",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1491583717000,
                "created_by": 1,
                "updated_at": 1491583717000,
                "updated_by": 1,
                "published_at": 1491583717000,
                "published_by": 1
            },
            {
                "id": 5138,
                "title": "넙적 사슴벌레 산란",
                "slug": "%eb%84%99%ec%a0%81-%ec%82%ac%ec%8a%b4%eb%b2%8c%eb%a0%88-%ec%82%b0%eb%9e%80",
                "markdown": "집에서 키우는 넙적 사슴벌레가 산란을 했습니다. 무려 18개의 알을 낳았어요. 그 중에 이미 4 마리는 부화를 해서 1령 애벌레가 되었습니다. 둘째 동현이가 지난 크리스마스 선물로 받은 사슴벌레입니다. 새로운 생명에 대한 경이로움에 제가 더 신났어요.\n\n오늘 집근처 <a href=\"http://www.stagbeetles.com/\">충우 박물관</a>에서 본격적으로 알을 키우기 위한 재료들을 사와서 관리를 시작했습니다. 사슴벌레 애벌레는 균사에서 키울 수도 있고 톱밥에서 키울 수도 있어요. 이미 부화한 첫째, 둘째 애벌레는 균사에서 키우고 나머지 알들은 톱밥으로 키우기로 했습니다.\n\n<a href=\"/content/images/2017/04/IMG_8606.jpg\"><img class=\"size-large wp-image-5141\" src=\"/content/images/2017/04/IMG_8606-1024x710.jpg\" alt=\"\" width=\"640\" height=\"444\" /></a> 넙적사슴벌레 알\n\n<a href=\"/content/images/2017/04/IMG_8597-2.jpg\"><img class=\"wp-image-5142 size-large\" src=\"/content/images/2017/04/IMG_8597-2-1024x734.jpg\" alt=\"\" width=\"640\" height=\"459\" /></a> 첫번째 두번째 애벌레\n\n<a href=\"/content/images/2017/04/IMG_8599.jpg\"><img class=\"size-large wp-image-5143\" src=\"/content/images/2017/04/IMG_8599-1024x636.jpg\" alt=\"\" width=\"640\" height=\"398\" /></a> 첫번째 애벌레를 균사통에\n\n<a href=\"/content/images/2017/04/IMG_8604.jpg\"><img class=\"wp-image-5144 size-large\" src=\"/content/images/2017/04/IMG_8604-1024x871.jpg\" alt=\"\" width=\"640\" height=\"544\" /></a> 톱밥으로 사육할 애벌레\n\n<a href=\"/content/images/2017/04/IMG_8602.jpg\"><img class=\"size-large wp-image-5145\" src=\"/content/images/2017/04/IMG_8602-1024x873.jpg\" alt=\"\" width=\"640\" height=\"546\" /></a> 세번째로 부화한 애벌레",
                "html": "집에서 키우는 넙적 사슴벌레가 산란을 했습니다. 무려 18개의 알을 낳았어요. 그 중에 이미 4 마리는 부화를 해서 1령 애벌레가 되었습니다. 둘째 동현이가 지난 크리스마스 선물로 받은 사슴벌레입니다. 새로운 생명에 대한 경이로움에 제가 더 신났어요.<p>오늘 집근처 <a href=\"http://www.stagbeetles.com/\">충우 박물관</a>에서 본격적으로 알을 키우기 위한 재료들을 사와서 관리를 시작했습니다. 사슴벌레 애벌레는 균사에서 키울 수도 있고 톱밥에서 키울 수도 있어요. 이미 부화한 첫째, 둘째 애벌레는 균사에서 키우고 나머지 알들은 톱밥으로 키우기로 했습니다.<p><a href=\"/content/images/2017/04/IMG_8606.jpg\"><img class=\"size-large wp-image-5141\" src=\"/content/images/2017/04/IMG_8606-1024x710.jpg\" alt=\"\" width=\"640\" height=\"444\" /></a> 넙적사슴벌레 알<p><a href=\"/content/images/2017/04/IMG_8597-2.jpg\"><img class=\"wp-image-5142 size-large\" src=\"/content/images/2017/04/IMG_8597-2-1024x734.jpg\" alt=\"\" width=\"640\" height=\"459\" /></a> 첫번째 두번째 애벌레<p><a href=\"/content/images/2017/04/IMG_8599.jpg\"><img class=\"size-large wp-image-5143\" src=\"/content/images/2017/04/IMG_8599-1024x636.jpg\" alt=\"\" width=\"640\" height=\"398\" /></a> 첫번째 애벌레를 균사통에<p><a href=\"/content/images/2017/04/IMG_8604.jpg\"><img class=\"wp-image-5144 size-large\" src=\"/content/images/2017/04/IMG_8604-1024x871.jpg\" alt=\"\" width=\"640\" height=\"544\" /></a> 톱밥으로 사육할 애벌레<p><a href=\"/content/images/2017/04/IMG_8602.jpg\"><img class=\"size-large wp-image-5145\" src=\"/content/images/2017/04/IMG_8602-1024x873.jpg\" alt=\"\" width=\"640\" height=\"546\" /></a> 세번째로 부화한 애벌레",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1492840438000,
                "created_by": 1,
                "updated_at": 1492840438000,
                "updated_by": 1,
                "published_at": 1492840438000,
                "published_by": 1
            },
            {
                "id": 5156,
                "title": "Xamarin.iOS 빌드 오류 - The root assembly conflicts with another assembly",
                "slug": "xamarin-ios-build-error-the-root-assembly-conflicts-with-another-assembly",
                "markdown": "4시간을 고생했기 때문에 공유를 안할 수가 없다. 이 오류는 단지 2017년 4월 25일 경에 발생한 내용이고 시간이 가면 자연스럽게 사라질 오류다. 보다 상세한 내용은 <a href=\"https://bugzilla.xamarin.com/show_bug.cgi?id=54993\">Xamarin 버그 54993</a> 을 참조 바란다. 여기에서 사용한 방법외에 다른 한가지 방법이 더 나온다.\n\nVisual Studio 2017를 최신으로 업데이트하고 Visual Studio for Mac을 다시 최신버전으로 업데이트 하니 Xamarin iOS 빌드가 안된다. 캡쳐를 해놓지는 못했는데 대충 이런 에러다.\n<blockquote> The root assembly conflicts...  with another assembly</blockquote>\n좀 더 자세히 살펴보면 Windows 의 Visual Studio 2017에는 Xamarin.iOS 10.8.0.175 가 설치되어 있고 Mac의 Visual Studio for Mac에는 Xamarin.iOS 10.10.0 이 설치되어 있다. 그럼 결론은 두개의 버전을 맞춰주면 해결이 된다.\n\n그런데 이게 불가능하다.  Xamarin 업데이트를 할때  Alpha, Beta, Stable 이렇게 3가지 채널로 배포한다.  10.8.0.175는 Stable 채널에 있고 10.10.0 은 Alpha 채널에 있다. 그런데 하필이며 지금 Visual Studio 2017은 Stable 버전만 업데이트 가능하고 Alpha 버전을 업데이트 못한다. 반대로 Visual Studio for Mac은 현재 Alpah버전만 업데이트 가능하고 Stable 버전은 업데이트 못한다.\n\n해결 방법\n<ol>\n \t<li>Mac에 10.8.0.175 버전을 별도로 설치한다. <a href=\"https://dl.xamarin.com/MonoTouch/Mac/xamarin.ios-10.8.0.175.pkg\">10.8.0.175 다운로드</a></li>\n \t<li>Visual Studio for Mac 의 업데이트에서 10.10.0을 설치하려고 할 텐데 설치하지 않는다.</li>\n</ol>\n알고보면 아무것도 아닌데, 검색 열심히 하면 찾을 수 있었는데 다급한 마음에 Mac을 초기화 했다.\n\n<img class=\"size-full wp-image-5158 aligncenter\" src=\"/content/images/2017/04/vs-2017-xamarin-version.png\" alt=\"\" width=\"1343\" height=\"983\" />\n\n<img class=\"size-full wp-image-5161\" src=\"/content/images/2017/04/vs-mac-xamarin-update.png\" alt=\"\" width=\"2528\" height=\"1544\" /> Visual Studio for Mac의 Xamarin.iOS 업데이트가 있어도 참아야 한다.",
                "html": "4시간을 고생했기 때문에 공유를 안할 수가 없다. 이 오류는 단지 2017년 4월 25일 경에 발생한 내용이고 시간이 가면 자연스럽게 사라질 오류다. 보다 상세한 내용은 <a href=\"https://bugzilla.xamarin.com/show_bug.cgi?id=54993\">Xamarin 버그 54993</a> 을 참조 바란다. 여기에서 사용한 방법외에 다른 한가지 방법이 더 나온다.<p>Visual Studio 2017를 최신으로 업데이트하고 Visual Studio for Mac을 다시 최신버전으로 업데이트 하니 Xamarin iOS 빌드가 안된다. 캡쳐를 해놓지는 못했는데 대충 이런 에러다.\n<blockquote> The root assembly conflicts...  with another assembly</blockquote>\n좀 더 자세히 살펴보면 Windows 의 Visual Studio 2017에는 Xamarin.iOS 10.8.0.175 가 설치되어 있고 Mac의 Visual Studio for Mac에는 Xamarin.iOS 10.10.0 이 설치되어 있다. 그럼 결론은 두개의 버전을 맞춰주면 해결이 된다.<p>그런데 이게 불가능하다.  Xamarin 업데이트를 할때  Alpha, Beta, Stable 이렇게 3가지 채널로 배포한다.  10.8.0.175는 Stable 채널에 있고 10.10.0 은 Alpha 채널에 있다. 그런데 하필이며 지금 Visual Studio 2017은 Stable 버전만 업데이트 가능하고 Alpha 버전을 업데이트 못한다. 반대로 Visual Studio for Mac은 현재 Alpah버전만 업데이트 가능하고 Stable 버전은 업데이트 못한다.<p>해결 방법\n<ol>\n \t<li>Mac에 10.8.0.175 버전을 별도로 설치한다. <a href=\"https://dl.xamarin.com/MonoTouch/Mac/xamarin.ios-10.8.0.175.pkg\">10.8.0.175 다운로드</a></li>\n \t<li>Visual Studio for Mac 의 업데이트에서 10.10.0을 설치하려고 할 텐데 설치하지 않는다.</li>\n</ol>\n알고보면 아무것도 아닌데, 검색 열심히 하면 찾을 수 있었는데 다급한 마음에 Mac을 초기화 했다.<p><img class=\"size-full wp-image-5158 aligncenter\" src=\"/content/images/2017/04/vs-2017-xamarin-version.png\" alt=\"\" width=\"1343\" height=\"983\" /><p><img class=\"size-full wp-image-5161\" src=\"/content/images/2017/04/vs-mac-xamarin-update.png\" alt=\"\" width=\"2528\" height=\"1544\" /> Visual Studio for Mac의 Xamarin.iOS 업데이트가 있어도 참아야 한다.",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1493118631000,
                "created_by": 1,
                "updated_at": 1493118631000,
                "updated_by": 1,
                "published_at": 1493118631000,
                "published_by": 1
            },
            {
                "id": 5164,
                "title": "[Cognitive Service] Bing Image Search 사용법",
                "slug": "cognitive-service-bing-image-search",
                "markdown": "마이크로소프트 Cognitive Services 중에 Bing Image Search 사용법에 대한 내용이고 상세한 내용은 <a href=\"https://msdn.microsoft.com/en-us/library/dn760784.aspx\">가이드 문서</a>를 참고하면 된다.\n<h3>키 발급 절차</h3>\n<ol>\n \t<li>Cognitive Service API 사이트에 접속</li>\n \t<li>마이크로소프트 계정으로 로그인</li>\n \t<li>로그인하면 Subscription 페이지가 보이는데 여기서 키를 발급 받는다.</li>\n \t<li>(무료로 제공되는 범위를 넘어서면 <a href=\"https://portal.azure.com\">Azure Portal</a> 에서 키를 만들어서 사용하면 Azure 구독과 계정으로 과금된다.)</li>\n</ol>\n<img class=\"size-large wp-image-5165 aligncenter\" src=\"/content/images/2017/04/bing-search-key-1024x695.png\" alt=\"\" width=\"640\" height=\"434\" />\n<h3>사용법</h3>\nHTTP Get 요청을 보내면 바로 결과를 받을 수 있다.\n<ul>\n \t<li>Base URL: https://api.cognitive.microsoft.com/bing/v5.0/images/search</li>\n \t<li>HTTP Method: GET</li>\n \t<li>Query String\n<ul>\n \t<li>q : {검색어}</li>\n \t<li>mkt: ko-kr, en-us</li>\n \t<li>count: {요청개수}</li>\n \t<li>offset: {시작번호}</li>\n \t<li>이외 상세 내용은 <a href=\"https://msdn.microsoft.com/en-us/library/dn760784.aspx\">문서 </a>참조</li>\n</ul>\n</li>\n \t<li>Header: Ocp-Apim-Subscription-Key / {발급받은 Key}</li>\n</ul>\n샘플 URL: https://api.cognitive.microsoft.com/bing/v5.0/images/search?q=2017+대선후보&amp;count=20&amp;offset=0&amp;mkt=ko-kr\n<h3>테스트 및 결과</h3>\n테스트는 PostMan 같은 툴을 사용하면 된다. 결과는 Json으로 나온다.\n\n<a href=\"/content/images/2017/04/bing-search-postman-test.png\"><img class=\"size-large wp-image-5167 aligncenter\" src=\"/content/images/2017/04/bing-search-postman-test-1024x628.png\" alt=\"\" width=\"640\" height=\"393\" /></a>\n\n복잡한 Json 결과 샘플을 보는 것 보다 <a href=\"http://ilseokoh.com/2017/04/26/json-xml-to-cshap-class/\">Json을 C# 클래스로 변환하는 방법</a>을 사용하여 구조를 살펴보면 다음과 같다.\n<pre class=\"prettyprint\">public class Instrumentation\n{\n    public string pageLoadPingUrl { get; set; }\n}\n\npublic class Thumbnail\n{\n    public int width { get; set; }\n    public int height { get; set; }\n}\n\npublic class Image\n{\n    public string name { get; set; }\n    public string webSearchUrl { get; set; }\n    public string thumbnailUrl { get; set; }\n    public string datePublished { get; set; }\n    public string contentUrl { get; set; }\n    public string hostPageUrl { get; set; }\n    public string contentSize { get; set; }\n    public string encodingFormat { get; set; }\n    public string hostPageDisplayUrl { get; set; }\n    public int width { get; set; }\n    public int height { get; set; }\n    public Thumbnail thumbnail { get; set; }\n    public string imageInsightsToken { get; set; }\n    public string imageId { get; set; }\n    public string accentColor { get; set; }\n}\n\npublic class RootObject\n{\n    public string _type { get; set; }\n    public Instrumentation instrumentation { get; set; }\n    public string webSearchUrl { get; set; }\n    public int totalEstimatedMatches { get; set; }\n    public List&lt;Image&gt; Images{ get; set; }\n    public int nextOffsetAddCount { get; set; }\n    public bool displayShoppingSourcesBadges { get; set; }\n    public bool displayRecipeSourcesBadges { get; set; }\n}</pre>",
                "html": "마이크로소프트 Cognitive Services 중에 Bing Image Search 사용법에 대한 내용이고 상세한 내용은 <a href=\"https://msdn.microsoft.com/en-us/library/dn760784.aspx\">가이드 문서</a>를 참고하면 된다.\n<h3>키 발급 절차</h3>\n<ol>\n \t<li>Cognitive Service API 사이트에 접속</li>\n \t<li>마이크로소프트 계정으로 로그인</li>\n \t<li>로그인하면 Subscription 페이지가 보이는데 여기서 키를 발급 받는다.</li>\n \t<li>(무료로 제공되는 범위를 넘어서면 <a href=\"https://portal.azure.com\">Azure Portal</a> 에서 키를 만들어서 사용하면 Azure 구독과 계정으로 과금된다.)</li>\n</ol>\n<img class=\"size-large wp-image-5165 aligncenter\" src=\"/content/images/2017/04/bing-search-key-1024x695.png\" alt=\"\" width=\"640\" height=\"434\" />\n<h3>사용법</h3>\nHTTP Get 요청을 보내면 바로 결과를 받을 수 있다.\n<ul>\n \t<li>Base URL: https://api.cognitive.microsoft.com/bing/v5.0/images/search</li>\n \t<li>HTTP Method: GET</li>\n \t<li>Query String\n<ul>\n \t<li>q : {검색어}</li>\n \t<li>mkt: ko-kr, en-us</li>\n \t<li>count: {요청개수}</li>\n \t<li>offset: {시작번호}</li>\n \t<li>이외 상세 내용은 <a href=\"https://msdn.microsoft.com/en-us/library/dn760784.aspx\">문서 </a>참조</li>\n</ul>\n</li>\n \t<li>Header: Ocp-Apim-Subscription-Key / {발급받은 Key}</li>\n</ul>\n샘플 URL: https://api.cognitive.microsoft.com/bing/v5.0/images/search?q=2017+대선후보&amp;count=20&amp;offset=0&amp;mkt=ko-kr\n<h3>테스트 및 결과</h3>\n테스트는 PostMan 같은 툴을 사용하면 된다. 결과는 Json으로 나온다.<p><a href=\"/content/images/2017/04/bing-search-postman-test.png\"><img class=\"size-large wp-image-5167 aligncenter\" src=\"/content/images/2017/04/bing-search-postman-test-1024x628.png\" alt=\"\" width=\"640\" height=\"393\" /></a><p>복잡한 Json 결과 샘플을 보는 것 보다 <a href=\"http://ilseokoh.com/2017/04/26/json-xml-to-cshap-class/\">Json을 C# 클래스로 변환하는 방법</a>을 사용하여 구조를 살펴보면 다음과 같다.\n<pre class=\"prettyprint\">public class Instrumentation\n{\n    public string pageLoadPingUrl { get; set; }\n}<p>public class Thumbnail\n{\n    public int width { get; set; }\n    public int height { get; set; }\n}<p>public class Image\n{\n    public string name { get; set; }\n    public string webSearchUrl { get; set; }\n    public string thumbnailUrl { get; set; }\n    public string datePublished { get; set; }\n    public string contentUrl { get; set; }\n    public string hostPageUrl { get; set; }\n    public string contentSize { get; set; }\n    public string encodingFormat { get; set; }\n    public string hostPageDisplayUrl { get; set; }\n    public int width { get; set; }\n    public int height { get; set; }\n    public Thumbnail thumbnail { get; set; }\n    public string imageInsightsToken { get; set; }\n    public string imageId { get; set; }\n    public string accentColor { get; set; }\n}<p>public class RootObject\n{\n    public string _type { get; set; }\n    public Instrumentation instrumentation { get; set; }\n    public string webSearchUrl { get; set; }\n    public int totalEstimatedMatches { get; set; }\n    public List&lt;Image&gt; Images{ get; set; }\n    public int nextOffsetAddCount { get; set; }\n    public bool displayShoppingSourcesBadges { get; set; }\n    public bool displayRecipeSourcesBadges { get; set; }\n}</pre>",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1493180534000,
                "created_by": 1,
                "updated_at": 1493180534000,
                "updated_by": 1,
                "published_at": 1493180534000,
                "published_by": 1
            },
            {
                "id": 5186,
                "title": "Microsoft Bot Framework에 카카오톡 붙이기",
                "slug": "microsoft-bot-framework-kakao-talk",
                "markdown": "<a href=\"https://dev.botframework.com/\">마이크로소프트 Bot Framework</a> 는 현재 15개의 채널을 지원하고 있다 (2017-06-22 현재) 페이스북 메신저, Skype, Skype for business, Slack 등 다양한 메신저를 지원하고 동시에 Direct Line REST API를 제공하기 때문에 원한다면 내가 만든 앱에 채팅 UI를 붙여서 만들수도 있다. 하지만 한국의 사정은 조금 다르다. 현재 모바일 메신저 시장의 95%의 점유율을 가지고 있는 카카오톡이 지원되어야 챗봇 서비스가 완성된다고 해도 과언이 아니다. 하지만 카카오톡은 현재 마이크로소프트 Bot Framework의 공식 채널이 아니다. 이런 상황에서 카카오톡에 Microsoft Bot Framework를 붙여서 챗봇을 구현하는 방법을 알아보자.\n<h3>카카오 플러스 친구</h3>\n카카오는 최근에 봇 개발을 위한 프레임워크를 개발중이라고 밝히기도 했다. 그 전까지는 다른 방법을 써야 하는데 한가지 가능한 방법이 있다. <a href=\"https://center-pf.kakao.com\">카카오 플러스 친구</a>는 원래 쇼핑몰 운영자 등이 고객들과 카카오톡을 통해서 소통할 수 있는 방법을 제공한다. 고객과 운영자가 직접 메시지를 주고 받는 대신 \"자동 응답 API\" 도 제공을 하는데 이 API와 마이크로소프트 봇 프레임워크의 Direct Line REST API를 연결해주면 카카오 톡을 통해서 봇과 사용자가 메시지를 주고 받을 수 있다.\n\n<img class=\"size-large wp-image-5189 aligncenter\" src=\"/content/images/2017/06/kakao-plus-friend-1024x354.jpg\" alt=\"\" width=\"640\" height=\"221\" />\n\n챗봇 애플리케이션과 별도의 웹 애플리케이션이 필요하고 \"플러스 친구 자동응답 API\"와 \"Direct Line 3.0 REST API\"를 연결해주는 기능만 해주면 된다. 즉, 카카오 톡에서 입력된 사용자의 메시지를 받고 이 메시지를 다시 Bot Framework 에서 알아 들을 수 있는 포멧으로 변경하여 Direct Line API로 전달하고 반대로 챗봇의 메시지를 다시 카카오 톡까지 전달하면 된다. 단순한 애플리케이션이라고 생각했지만 고려할 사항이 몇가지 있다.\n\n여기에서는 ASP.NET MVC를 이용해서 웹앱을 만들어서 구현한 내용으로 설명을 하고 <a href=\"https://github.com/ilseokoh/ohilseokbot\">전체 코드는 GitHub에 공개</a>되어 있다. '오일석 봇'이라는 샘플이다. 카카오톡으로 메시지를 입력하면 Bot 으로 전달되고 LUIS(Language Understanding Intelligent Service)를 통해 '의도(Intent)'를 알아내고 의도에 적합한 답변을 텍스트 또는 이미지로 응답하는 간단한 봇이다. 웹 앱 2개와 LUIS 앱, 대화의 세션을 저장하기 위한 Azure Cosmos DB로 구성되어 있다.\n\n<img class=\"aligncenter wp-image-5209 size-large\" src=\"/content/images/2017/06/kakao-diagram-1024x633.jpg\" alt=\"\" width=\"640\" height=\"396\" />\n\n&nbsp;\n<h3>카카오 플러스 친구 가입 및 설정</h3>\n<a href=\"https://center-pf.kakao.com/\">카카오 플러스 친구</a>를 가입하고 심사를 거쳐서 승인이된다. 관리자 센터로 가서 배경이미지, 아이콘 설명 등을 설정하고 \"스마트 채팅 &gt; API 형\" 메뉴에 들어가서 \"앱 URL\"을 설정하고 API 테스트를 하고 저장하면 된다. 알림을 받을 전화번호를 입력해 놓으면 오류가 발생할 때 알림이 온다.\n\n<img class=\"aligncenter wp-image-5210 size-full\" src=\"/content/images/2017/06/kakao-plus-config.jpg\" alt=\"\" width=\"1237\" height=\"844\" />\n\n&nbsp;\n<h3>카카오 플러스 친구 API</h3>\n상세한 API 스펙은 <a href=\"https://github.com/plusfriend/auto_reply\">Github 카카오톡 플러스친구 API v. 2.0 개요</a> 페이지에서 확인할 수 있다.  4가지 API(Keyboard, message, friend, chat_room)가 있는데 이중에 message API가 대화를 주고 받을 때 사용한다. 그리고 keyboard는 반드시 구현을 해줘야 한다. 나머지는 필요에 따라서 구현을 해주면 되는데 이 샘플에서는 message와 keyboard를 구현했다.\n<ul>\n \t<li>keyboard: 사용자가 접속하면 호출되어서 카카오톡 키보드 자리에 설정된 버튼을 표시해준다. 카카오 플러스 친구는 처음 시작을 버튼을 보여주면서 시작한다.</li>\n \t<li>friend: 친구가 추가되거나 (POST) 차단(DELETE)될 때 호출된다.</li>\n \t<li>chat_room: 사용자가 채팅방에서 나가면 호출된다.</li>\n \t<li>message: 사용자가 메시지를 입력하면 호출 된다.</li>\n</ul>\n<h4>카카오톡에서 봇으로 메시지 전송</h4>\n사용자가 메시지를 입력하면 message API가 호출되고 user_key, type, content 값이 POST로 전달된다. 여기서 type은 string으로 두가지 \"text\", \"photo\" 이다. 이걸 받아서 Bot Framework가 알아 들을 수 있는 Activity 타입으로 전환을 해서 Direct Line REST API를 통해 보내면 된다.  C# 코드로 구현한다면 아래 코드를 참조하면 된다. 여기에서 보내는 채널에 대한 정보를 ChannelAccount 를 만들때 \"kakao\"라는 이름을 전달하는 코드가 들어 있는데 이는 봇에서 이 메시지가 카카오톡에서 왔음을 구별할 수 있는 방법이 된다.\n<pre class=\"prettyprint\">[AcceptVerbs(HttpVerbs.Post)]\npublic async Task&lt;ActionResult&gt; Index(string user_key, string type, string content)\n{\n try\n {\n    // covert from Kakao talk message to Bot Builder Activity\n    Activity activity = new Activity\n    {\n       // Bot 에서 메시지가 kakao로 부터 요청되었음을 알수 있도록 name에 kakao를 써준다. \n       From = new ChannelAccount(id:user_key,name:\"kakao\"),\n       Type = ActivityTypes.Message\n    };\n    if (type == \"text\")\n    {\n       activity.Text = content;\n    }\n    else if (type == \"photo\")\n    {\n       activity.Attachments = new List&lt;Attachment&gt;();\n       activity.Attachments.Add(new Attachment\n       {\n       ContentUrl = content\n       });\n    }\n    var response = await conversationService.SendAndReceiveMessageAsync(user_key, activity);\n    // 발견된 복수의 Activity를 넘겨서 처리\n    var msg = MessageConvertor.DirectLineToKakao(response);\n    return Json(msg);\n    }\n    catch (Exception ex)\n    {\n       throw new InvalidOperationException(\"Direct Line 연결오류\", ex);\n    }\n}\n\n</pre>\n<h4>봇에서 카카오톡으로 메시지 응답</h4>\n반대로 챗봇이 사용자에게 보내는 메시지의 내용은 아래 Json 데이터처럼 메시지에 text, photo, message_button으로 메시지가 표현되고 키보드 영역에 표시가 되도록 button 도 전달 할 수 있다. C#에서는 이 메시지 JSON타입을 모델로 정의해서 사용하면 된다.\n<pre class=\"prettyprint\">{\n  \"message\": {\n    \"text\": \"안녕하세요\",\n    \"photo\": {\n      \"url\": \"https://photo.jpg\",\n      \"width\": 640,\n      \"height\": 480\n    },\n    \"message_button\": {\n      \"label\": \"인사하기\",\n      \"url\": \"https://coupon/url\"\n    }\n  },\n  \"keyboard\": {\n    \"type\": \"buttons\",\n    \"buttons\": [\n      \"처음으로\",\n      \"다시 인사하기\",\n      \"취소하기\"\n    ]\n  }\n}</pre>\n<h3>메시지 전송과 대화의 유지</h3>\n챗봇에 메시지를 전송하려면 DirectLine REST API를 이용해서 Activity 타입을 만들어서 전송한다. 처음 대화를 시작할 때 Authentication을 거치고 Conversation을 시작해서 ConversationID를 만드는 과정이 필요하다.  상세한 API 스펙은 <a href=\"https://docs.microsoft.com/en-us/bot-framework/rest-api/bot-framework-rest-direct-line-3-0-concepts\">Direct Line REST API 3.0 스펙</a>에 나와있다. C#에서는 <a href=\"https://www.nuget.org/packages/Microsoft.Bot.Connector.DirectLine/3.0.2/\">Microsoft.Bot.Connector.DirectLine</a> 를 사용하면 쉽게 코드를 작성할 수 있다.\n\n원래 채팅은 지금 대화를 나누다가도 내일 다시 대화를 이어나갈 수 있다. 즉, Conversation이라는 채널이 계속 유지되어야 한참 후에도 그 대화를 계속 이어나갈 수 있다. 따라서  생성된 ConversationID를 저장하고 있다가 다시 메시지가 오면 원래 ConversationID를 사용하여 메시지를 전송해야만 대화가 새로 시작되지 않고 이어진다. 마치 웹 애플리케이션에서 세션을 유지하듯이 별도의 저장공간에 CoversationID를 저장하고 있다가 꺼내써야 한다. 이를 위해서 샘플에서는 Azure Cosmos DB를 사용했고 여기에 카카오톡이 전달해준 user_key, Conversation 정도, 타임아웃을 체크하기 위한 시간, 최신 응답 메시지만 가져오기 위한 watermark 정보를 저장했다. 카카오 플러스 친구 API가 전송해준 user_key 는 대화방을 나가기 전까지 유효한 아이디 역할을 하고 Bot Framework 쪽에서는 ConversationID가 대화를 유지하는데 키가 되는 값이기 때문에 카카오 톡에서 대화를 종료하기 전까지 이 두가지를 같이 저장해야 한다. 또한 Bot Framework의 Conversation은 30분의 Timeout이 있기 때문에 30분이 지났다면 다시 연결을 해주는 로직도 필요하다.\n<pre class=\"prettyprint\">// 메시지를 Direct Line API를 사용하여 Bot에 전송\npublic async Task SendMessageAsync(string userkey, Activity activity)\n{\n   DirectLineClient client;\n   client = new DirectLineClient(ConfigurationManager.AppSettings[\"DirectLineSecret\"]);\n   client.SetUserAgent(\"kakao\");\n\n   await ConnectAsync(userkey);\n   await client.Conversations.PostActivityAsync(conversation.ConversationId, activity);\n}\n\n// Direct Line API에 메시지를 보내기 전에 연결\n// userkey를 기준으로 Database에 저장된 정보를 가져와서 Conversation을 새로 만들거나 기존 ID를 사용하여 연결\npublic async Task ConnectAsync(string userkey)\n{\n    if (conversation != null) return;\n\n    // database 에서 ConversationInfo 가져옴 \n    conversationinfo = await sessionService.GetInfoAsync(userkey);\n    if (conversationinfo == null)\n    {\n        conversation = await client.Conversations.StartConversationAsync();\n        await SaveConversationInfoAsync(conversation, userkey, \"\", DateTimeOffset.Now);\n    }\n    else\n    {\n        if (!conversationinfo.coversation.ExpiresIn.HasValue || !conversationinfo.timestamp.HasValue)\n        {\n            conversation = await client.Conversations.ReconnectToConversationAsync(conversationinfo.coversation.ConversationId);\n            await SaveConversationInfoAsync(conversation, userkey, conversationinfo.watermark, DateTimeOffset.Now);\n        }\n        // timeout 체크. 30분\n        var now = DateTimeOffset.Now;\n        var timeoutdate = conversationinfo.timestamp.Value.AddSeconds(conversationinfo.coversation.ExpiresIn.Value - 300);\n        var diff = timeoutdate - now;\n        if (diff &gt; TimeSpan.MinValue)\n        {\n            conversation = conversationinfo.coversation;\n        }\n        else\n        {\n            // 타임아웃이며 다시 커넥트를 해야 한다.\n            conversation = await client.Conversations.ReconnectToConversationAsync(conversationinfo.coversation.ConversationId);\n            await SaveConversationInfoAsync(conversation, userkey, conversationinfo.watermark, DateTimeOffset.Now);\n        }\n    }\n}</pre>\n<h3>챗봇에서 메시지 응답 받기</h3>\n메시지를 응답받는 코드의 핵심은 GetActivityAsync 메서드로 ConversationId 와 watermark를 전달한다. watermark의 용도는 마지막으로 전달 받은 메시지만 가져오기 위함이다. 메시지 하나가 전송될 때마다 watermark 값이 단순 증가하는데 카카오톡에서 받은 메시지를 전송하고 받은 watermark를 저장하고 있다가 GetActivityAsync() 를 호출할때 사용하면 그 이후의 watermark 값을 가지고 있는 응답 메시지만 가져온다. 이 때 여러개의 Activity가 한꺼번에 응답될 수 있으므로 코드에서는 여러개의 activity를 처리할 수 있도록 코딩을 해 놓는게 좋겠다.\n<pre class=\"prettyprint\">public async Task&lt;IList&lt;Activity&gt;&gt; ReceiveMessageAsync(string userkey)\n{\n    await ConnectAsync(userkey);\n    \n    // 응답 메시지를가져온다. \n    var activitySet = await client.Conversations.GetActivitiesAsync(conversationinfo.coversation.ConversationId, conversationinfo.watermark);\n    conversationinfo.watermark = activitySet?.Watermark;\n    // Conversation 저장\n    await SaveConversationInfoAsync(conversation, userkey, conversationinfo.watermark, conversationinfo.timestamp.Value);\n\n    // appSettings 에 설정한 BotId 는 bot을 등록할 때 사용한 Bot handler 와 같아야 한다. \n    var activities = from x in activitySet.Activities\n                            where x.From.Id == botId\n                            select x;\n\n    return activities.ToList();\n}</pre>\n<h3>챗봇에서 전달 받은 메시지의 변환</h3>\n챗봇이 카카오톡으로 메시지를 보낼때는 몇가지 문제가 있다. Bot Framework에서는 단순 메시지나 이미지 전달 말고도 다양한 포멧으로 메시지를 전달할 수 있도록 여러가지 Attachment를 지원한다. <a href=\"https://docs.microsoft.com/ko-kr/bot-framework/dotnet/bot-builder-dotnet-add-rich-card-attachments\">\"Add rich card attachments to message\"</a> 문서를 보면 AdaptiveCard, HeroCard, ThumbnailCard 등 다양한 카드타입을 지원하는 걸 알 수 있다. Bot Framework의 공식 채널(메신저)들은 각자 표현은 조금씩 다르지만 이런 카드들을 사용할 수 있다. 하지만 카카오톡은 그렇지 못하다. 따라서 카카오톡으로만 챗봇 서비스를 하는게 아니라면 사용자에게 전달할 컨텐츠를 어떤 방식을 통해 전달할지에 대해서 기획을 하고 그 내용을 카카오톡에서는 어떻게 표현할지 생각해 봐야 한다.\n\n또한 챗봇은 여러개의 메시지로 응답을 나눠 보낼 수도 있다. 예를들어 안내 텍스트를 하나의 Activity로 보내고 그 다음에 이미지를 한장 보내고 마지막으로 사용자가 선택할 수있는 버튼이 달린 카드를 보낼 수 있다. 즉 3번을 응답할 수 있고 채널에서는 각각의 메시지를 사용자에게 보여준다. 하지만 카카오톡의 API는 message API가 요청되면 그 응답으로 한번의 메시지만 전달 할 수 있다. Request 당 하나의 메시지만 전달 해야한다.\n\n따라서 이런 특성을 이해하고 코드를 작성하는게 중요하다. 여러 고민을 해봤지만 제일 바람직한 방법은 챗봇 코드에서 카카오톡에서 온 요청을 인식하고, 하나의 Activity에 메시지와 이미지 하나를 만들어서 응답하는게 제일 좋은 방법으로 생각된다.\n<pre class=\"prettyprint\">public static Models.MessageResponse DirectLineToKakao(IList&lt;Activity&gt; activities)\n{\n    if (activities == null || activities.Count &lt;= 0) return null;\n\n    var msg = new Models.MessageResponse();\n    // 여러개의 Activity\n    foreach (var activity in activities)\n    {\n        if (activity.Type != ActivityTypes.Message) continue;\n\n        if (msg.message == null) msg.message = new Message();\n        // 텍스트 메시지를 누적 시킴\n        msg.message.text += \"\\n\" + activity.Text;\n\n        if (activity.Attachments != null &amp;&amp; activity.Attachments.Count &gt; 0)\n        {\n            foreach (Attachment attachment in activity.Attachments)\n            {\n                switch (attachment.ContentType)\n                {\n                    case \"image/png\":\n                    case \"image/jpeg\":\n                        // activity는 attachment가 배열로 여러개가 오지만 Kakao는 한개만 가능.\n                        // 따라서 처음 하나만 보여지는 걸로 ... \n                        if (msg.message.photo == null)\n                        {\n                            msg.message.photo = new Photo\n                            {\n                                url = attachment.ContentUrl\n                            };\n                        }\n                        break;\n                }\n            }\n        }\n    }\n    return msg;\n}</pre>\n여러개의 Activity를 받아서 카카오톡이 표현할 수 있는 메시지 형태로 변환해주는 코드는 위와 같다. 텍스트를 붙여서 하나로 만든다거나 Attachment 중에 이미지 타입만 처리하고 그것도 한개만 처리하도록 했다. 데이터가 누락되는 것이다. 여기에서는 이렇게 방어코드를 넣어놓고 챗봇에서 카카오톡으로 보낼 때만 특별히 하나의 Activity 응답으로 만들어서 보내도록 분기를 해주는 방법이 적당할 것 같다. 그 방법은 카카오톡에서 전송된 Activity의 내용중에 From 을 살펴보고 분기하는 방법이다.\n<pre class=\"prettyprint\">[LuisIntent(\"인사\")]\npublic async Task Greeting(IDialogContext context, LuisResult result)\n{\n    if (context.Activity.From.Name == \"kakao\")\n    {\n        string message = $\"안녕하세요. 저는 오일석 봇입니다. 저를 만든 오일석을 대신해서 제가 도움을 드릴 수 있으면 좋겠네요.  저는 이런걸 할 수 있어요.\\n 제 소개를 해드릴 수 있어요.\\n 제 인사를 할수도 있죠.\";\n        await context.PostAsync(message);\n    }\n    else\n    {\n        string message = $\"안녕하세요. 저는 오일석 봇입니다. 저를 만든 오일석을 대신해서 제가 도움을 드릴 수 있으면 좋겠네요.  \";\n        await context.PostAsync(message);\n\n        string message2 = $\"저는 이런걸 할 수 있어요.\\n 제 소개를 해드릴 수 있어요.\\n 제 인사를 할수도 있죠.\";\n        await context.PostAsync(message2);\n        context.Wait(MessageReceived);\n    }\n}\n</pre>\n&nbsp;\n<h3>해결하지 못한 두가지 문제점</h3>\n<ul>\n \t<li>카카오톡으로 이미지를 전달할 때 width와 height를 같이 주도록 되어 있고 값을 넘기지 않으면 이미지를 표시하지 않는다. 하지만 전체 흐름에서 보면 width와 height를 알아내서 전달해주기 위해서는 이미지를 다운받아서 width/height를 직접 알아내는 방법 뿐이다. (굳이 왜 w / h를 받으려고 해쓰가...)</li>\n \t<li>타임아웃 문제 : 카카오톡 API는 5초안에 응답이 안오면 오류를 발생시킨다. 채팅인데 5초 타임아웃은 가혹하다.  봇 커넥터를 통해서 봇까지 가서 LUIS 서비스를 다녀오고 혹여나 백엔드 서비스까지 있다면 타임아웃이 걸릴 수도 있다. 실제로 관리자에게 오류 메시지가 오는데 타임아웃이 원인인 것 같다. 그리고 그 원인을 살펴볼 방법이 없다.</li>\n</ul>\n<h3>마무리</h3>\n두개의 웹앱을 모두 테스트 해야하는데 두개를 모두 로컬 머신에서 테스트하는게 불가능했다. 모두 배포를 한 후에 테스트를 하거나 반쪽씩 테스트를 진행해야 했다. Postman과 fiddler를 모두 동원해서 오고가는 메시지를 확인하면서 테스트를 해야한다. 따라서 별도의 개발환경을 Azure에 구축하고 배포 후 테스트를 하는 방법이 가장 적당할 것이다.\n\n여기까지 주요 코드를 살펴보면서 카카오톡과 Microsoft Bot Framework를 붙여서 챗봇을 서비스하는 방법을 살펴봤다. 카카오에서 좀 더 멋진 챗봇 프레임워크를 만들어서 공개할 것으로 믿고 그 방법이 Microsoft Bot Framework와 잘 연동이 되었으면 하는 바램이다.\n\n<img class=\"size-large wp-image-5222 aligncenter\" src=\"/content/images/2017/06/kakao-screen-1024x599.png\" alt=\"\" width=\"640\" height=\"374\" />\n<h3>추가 자료</h3>\n<ul>\n \t<li>전체 소스: <a href=\"https://github.com/ilseokoh/ohilseokbot\">https://github.com/ilseokoh/ohilseokbot</a></li>\n \t<li>Direct Line 사용 샘플: <a href=\"https://github.com/Microsoft/BotBuilder-Samples/tree/master/CSharp/core-DirectLine\">https://github.com/Microsoft/BotBuilder-Samples/tree/master/CSharp/core-DirectLine </a></li>\n \t<li><a href=\"http://ilseokoh.com/2016/12/05/microsoft-bot-framework-dialog/\">[Microsoft Bot Framework] Dialog를 사용하여 대화의 흐름 만들기</a></li>\n \t<li><a href=\"http://ilseokoh.com/2016/12/10/microsoft-bot-framework-%ec%83%81%ed%83%9c%ec%a0%80%ec%9e%a5%ec%9d%84-%ec%9c%84%ed%95%9c-bot-state-service/\">[Microsoft Bot Framework] 상태저장을 위한 Bot State Service</a></li>\n \t<li><a href=\"http://ilseokoh.com/2016/12/02/microsoft-bot-framework-direct-line-rest-api-3-0/\">[Microsoft Bot Framework] Direct Line REST API 3.0</a></li>\n \t<li><a href=\"http://ilseokoh.com/2016/12/03/%ED%95%80%EC%BC%93-cs-chatbot-%EB%A7%8C%EB%93%A4%EA%B8%B0-hackfest-%EC%82%AC%EB%A1%80/\">핀켓 CS ChatBot 만들기 HackFest 사례</a></li>\n</ul>",
                "html": "<a href=\"https://dev.botframework.com/\">마이크로소프트 Bot Framework</a> 는 현재 15개의 채널을 지원하고 있다 (2017-06-22 현재) 페이스북 메신저, Skype, Skype for business, Slack 등 다양한 메신저를 지원하고 동시에 Direct Line REST API를 제공하기 때문에 원한다면 내가 만든 앱에 채팅 UI를 붙여서 만들수도 있다. 하지만 한국의 사정은 조금 다르다. 현재 모바일 메신저 시장의 95%의 점유율을 가지고 있는 카카오톡이 지원되어야 챗봇 서비스가 완성된다고 해도 과언이 아니다. 하지만 카카오톡은 현재 마이크로소프트 Bot Framework의 공식 채널이 아니다. 이런 상황에서 카카오톡에 Microsoft Bot Framework를 붙여서 챗봇을 구현하는 방법을 알아보자.\n<h3>카카오 플러스 친구</h3>\n카카오는 최근에 봇 개발을 위한 프레임워크를 개발중이라고 밝히기도 했다. 그 전까지는 다른 방법을 써야 하는데 한가지 가능한 방법이 있다. <a href=\"https://center-pf.kakao.com\">카카오 플러스 친구</a>는 원래 쇼핑몰 운영자 등이 고객들과 카카오톡을 통해서 소통할 수 있는 방법을 제공한다. 고객과 운영자가 직접 메시지를 주고 받는 대신 \"자동 응답 API\" 도 제공을 하는데 이 API와 마이크로소프트 봇 프레임워크의 Direct Line REST API를 연결해주면 카카오 톡을 통해서 봇과 사용자가 메시지를 주고 받을 수 있다.<p><img class=\"size-large wp-image-5189 aligncenter\" src=\"/content/images/2017/06/kakao-plus-friend-1024x354.jpg\" alt=\"\" width=\"640\" height=\"221\" /><p>챗봇 애플리케이션과 별도의 웹 애플리케이션이 필요하고 \"플러스 친구 자동응답 API\"와 \"Direct Line 3.0 REST API\"를 연결해주는 기능만 해주면 된다. 즉, 카카오 톡에서 입력된 사용자의 메시지를 받고 이 메시지를 다시 Bot Framework 에서 알아 들을 수 있는 포멧으로 변경하여 Direct Line API로 전달하고 반대로 챗봇의 메시지를 다시 카카오 톡까지 전달하면 된다. 단순한 애플리케이션이라고 생각했지만 고려할 사항이 몇가지 있다.<p>여기에서는 ASP.NET MVC를 이용해서 웹앱을 만들어서 구현한 내용으로 설명을 하고 <a href=\"https://github.com/ilseokoh/ohilseokbot\">전체 코드는 GitHub에 공개</a>되어 있다. '오일석 봇'이라는 샘플이다. 카카오톡으로 메시지를 입력하면 Bot 으로 전달되고 LUIS(Language Understanding Intelligent Service)를 통해 '의도(Intent)'를 알아내고 의도에 적합한 답변을 텍스트 또는 이미지로 응답하는 간단한 봇이다. 웹 앱 2개와 LUIS 앱, 대화의 세션을 저장하기 위한 Azure Cosmos DB로 구성되어 있다.<p><img class=\"aligncenter wp-image-5209 size-large\" src=\"/content/images/2017/06/kakao-diagram-1024x633.jpg\" alt=\"\" width=\"640\" height=\"396\" /><p>&nbsp;\n<h3>카카오 플러스 친구 가입 및 설정</h3>\n<a href=\"https://center-pf.kakao.com/\">카카오 플러스 친구</a>를 가입하고 심사를 거쳐서 승인이된다. 관리자 센터로 가서 배경이미지, 아이콘 설명 등을 설정하고 \"스마트 채팅 &gt; API 형\" 메뉴에 들어가서 \"앱 URL\"을 설정하고 API 테스트를 하고 저장하면 된다. 알림을 받을 전화번호를 입력해 놓으면 오류가 발생할 때 알림이 온다.<p><img class=\"aligncenter wp-image-5210 size-full\" src=\"/content/images/2017/06/kakao-plus-config.jpg\" alt=\"\" width=\"1237\" height=\"844\" /><p>&nbsp;\n<h3>카카오 플러스 친구 API</h3>\n상세한 API 스펙은 <a href=\"https://github.com/plusfriend/auto_reply\">Github 카카오톡 플러스친구 API v. 2.0 개요</a> 페이지에서 확인할 수 있다.  4가지 API(Keyboard, message, friend, chat_room)가 있는데 이중에 message API가 대화를 주고 받을 때 사용한다. 그리고 keyboard는 반드시 구현을 해줘야 한다. 나머지는 필요에 따라서 구현을 해주면 되는데 이 샘플에서는 message와 keyboard를 구현했다.\n<ul>\n \t<li>keyboard: 사용자가 접속하면 호출되어서 카카오톡 키보드 자리에 설정된 버튼을 표시해준다. 카카오 플러스 친구는 처음 시작을 버튼을 보여주면서 시작한다.</li>\n \t<li>friend: 친구가 추가되거나 (POST) 차단(DELETE)될 때 호출된다.</li>\n \t<li>chat_room: 사용자가 채팅방에서 나가면 호출된다.</li>\n \t<li>message: 사용자가 메시지를 입력하면 호출 된다.</li>\n</ul>\n<h4>카카오톡에서 봇으로 메시지 전송</h4>\n사용자가 메시지를 입력하면 message API가 호출되고 user_key, type, content 값이 POST로 전달된다. 여기서 type은 string으로 두가지 \"text\", \"photo\" 이다. 이걸 받아서 Bot Framework가 알아 들을 수 있는 Activity 타입으로 전환을 해서 Direct Line REST API를 통해 보내면 된다.  C# 코드로 구현한다면 아래 코드를 참조하면 된다. 여기에서 보내는 채널에 대한 정보를 ChannelAccount 를 만들때 \"kakao\"라는 이름을 전달하는 코드가 들어 있는데 이는 봇에서 이 메시지가 카카오톡에서 왔음을 구별할 수 있는 방법이 된다.\n<pre class=\"prettyprint\">[AcceptVerbs(HttpVerbs.Post)]\npublic async Task&lt;ActionResult&gt; Index(string user_key, string type, string content)\n{\n try\n {\n    // covert from Kakao talk message to Bot Builder Activity\n    Activity activity = new Activity\n    {\n       // Bot 에서 메시지가 kakao로 부터 요청되었음을 알수 있도록 name에 kakao를 써준다. \n       From = new ChannelAccount(id:user_key,name:\"kakao\"),\n       Type = ActivityTypes.Message\n    };\n    if (type == \"text\")\n    {\n       activity.Text = content;\n    }\n    else if (type == \"photo\")\n    {\n       activity.Attachments = new List&lt;Attachment&gt;();\n       activity.Attachments.Add(new Attachment\n       {\n       ContentUrl = content\n       });\n    }\n    var response = await conversationService.SendAndReceiveMessageAsync(user_key, activity);\n    // 발견된 복수의 Activity를 넘겨서 처리\n    var msg = MessageConvertor.DirectLineToKakao(response);\n    return Json(msg);\n    }\n    catch (Exception ex)\n    {\n       throw new InvalidOperationException(\"Direct Line 연결오류\", ex);\n    }\n}<p></pre>\n<h4>봇에서 카카오톡으로 메시지 응답</h4>\n반대로 챗봇이 사용자에게 보내는 메시지의 내용은 아래 Json 데이터처럼 메시지에 text, photo, message_button으로 메시지가 표현되고 키보드 영역에 표시가 되도록 button 도 전달 할 수 있다. C#에서는 이 메시지 JSON타입을 모델로 정의해서 사용하면 된다.\n<pre class=\"prettyprint\">{\n  \"message\": {\n    \"text\": \"안녕하세요\",\n    \"photo\": {\n      \"url\": \"https://photo.jpg\",\n      \"width\": 640,\n      \"height\": 480\n    },\n    \"message_button\": {\n      \"label\": \"인사하기\",\n      \"url\": \"https://coupon/url\"\n    }\n  },\n  \"keyboard\": {\n    \"type\": \"buttons\",\n    \"buttons\": [\n      \"처음으로\",\n      \"다시 인사하기\",\n      \"취소하기\"\n    ]\n  }\n}</pre>\n<h3>메시지 전송과 대화의 유지</h3>\n챗봇에 메시지를 전송하려면 DirectLine REST API를 이용해서 Activity 타입을 만들어서 전송한다. 처음 대화를 시작할 때 Authentication을 거치고 Conversation을 시작해서 ConversationID를 만드는 과정이 필요하다.  상세한 API 스펙은 <a href=\"https://docs.microsoft.com/en-us/bot-framework/rest-api/bot-framework-rest-direct-line-3-0-concepts\">Direct Line REST API 3.0 스펙</a>에 나와있다. C#에서는 <a href=\"https://www.nuget.org/packages/Microsoft.Bot.Connector.DirectLine/3.0.2/\">Microsoft.Bot.Connector.DirectLine</a> 를 사용하면 쉽게 코드를 작성할 수 있다.<p>원래 채팅은 지금 대화를 나누다가도 내일 다시 대화를 이어나갈 수 있다. 즉, Conversation이라는 채널이 계속 유지되어야 한참 후에도 그 대화를 계속 이어나갈 수 있다. 따라서  생성된 ConversationID를 저장하고 있다가 다시 메시지가 오면 원래 ConversationID를 사용하여 메시지를 전송해야만 대화가 새로 시작되지 않고 이어진다. 마치 웹 애플리케이션에서 세션을 유지하듯이 별도의 저장공간에 CoversationID를 저장하고 있다가 꺼내써야 한다. 이를 위해서 샘플에서는 Azure Cosmos DB를 사용했고 여기에 카카오톡이 전달해준 user_key, Conversation 정도, 타임아웃을 체크하기 위한 시간, 최신 응답 메시지만 가져오기 위한 watermark 정보를 저장했다. 카카오 플러스 친구 API가 전송해준 user_key 는 대화방을 나가기 전까지 유효한 아이디 역할을 하고 Bot Framework 쪽에서는 ConversationID가 대화를 유지하는데 키가 되는 값이기 때문에 카카오 톡에서 대화를 종료하기 전까지 이 두가지를 같이 저장해야 한다. 또한 Bot Framework의 Conversation은 30분의 Timeout이 있기 때문에 30분이 지났다면 다시 연결을 해주는 로직도 필요하다.\n<pre class=\"prettyprint\">// 메시지를 Direct Line API를 사용하여 Bot에 전송\npublic async Task SendMessageAsync(string userkey, Activity activity)\n{\n   DirectLineClient client;\n   client = new DirectLineClient(ConfigurationManager.AppSettings[\"DirectLineSecret\"]);\n   client.SetUserAgent(\"kakao\");<p>   await ConnectAsync(userkey);\n   await client.Conversations.PostActivityAsync(conversation.ConversationId, activity);\n}<p>// Direct Line API에 메시지를 보내기 전에 연결\n// userkey를 기준으로 Database에 저장된 정보를 가져와서 Conversation을 새로 만들거나 기존 ID를 사용하여 연결\npublic async Task ConnectAsync(string userkey)\n{\n    if (conversation != null) return;<p>    // database 에서 ConversationInfo 가져옴 \n    conversationinfo = await sessionService.GetInfoAsync(userkey);\n    if (conversationinfo == null)\n    {\n        conversation = await client.Conversations.StartConversationAsync();\n        await SaveConversationInfoAsync(conversation, userkey, \"\", DateTimeOffset.Now);\n    }\n    else\n    {\n        if (!conversationinfo.coversation.ExpiresIn.HasValue || !conversationinfo.timestamp.HasValue)\n        {\n            conversation = await client.Conversations.ReconnectToConversationAsync(conversationinfo.coversation.ConversationId);\n            await SaveConversationInfoAsync(conversation, userkey, conversationinfo.watermark, DateTimeOffset.Now);\n        }\n        // timeout 체크. 30분\n        var now = DateTimeOffset.Now;\n        var timeoutdate = conversationinfo.timestamp.Value.AddSeconds(conversationinfo.coversation.ExpiresIn.Value - 300);\n        var diff = timeoutdate - now;\n        if (diff &gt; TimeSpan.MinValue)\n        {\n            conversation = conversationinfo.coversation;\n        }\n        else\n        {\n            // 타임아웃이며 다시 커넥트를 해야 한다.\n            conversation = await client.Conversations.ReconnectToConversationAsync(conversationinfo.coversation.ConversationId);\n            await SaveConversationInfoAsync(conversation, userkey, conversationinfo.watermark, DateTimeOffset.Now);\n        }\n    }\n}</pre>\n<h3>챗봇에서 메시지 응답 받기</h3>\n메시지를 응답받는 코드의 핵심은 GetActivityAsync 메서드로 ConversationId 와 watermark를 전달한다. watermark의 용도는 마지막으로 전달 받은 메시지만 가져오기 위함이다. 메시지 하나가 전송될 때마다 watermark 값이 단순 증가하는데 카카오톡에서 받은 메시지를 전송하고 받은 watermark를 저장하고 있다가 GetActivityAsync() 를 호출할때 사용하면 그 이후의 watermark 값을 가지고 있는 응답 메시지만 가져온다. 이 때 여러개의 Activity가 한꺼번에 응답될 수 있으므로 코드에서는 여러개의 activity를 처리할 수 있도록 코딩을 해 놓는게 좋겠다.\n<pre class=\"prettyprint\">public async Task&lt;IList&lt;Activity&gt;&gt; ReceiveMessageAsync(string userkey)\n{\n    await ConnectAsync(userkey);\n    \n    // 응답 메시지를가져온다. \n    var activitySet = await client.Conversations.GetActivitiesAsync(conversationinfo.coversation.ConversationId, conversationinfo.watermark);\n    conversationinfo.watermark = activitySet?.Watermark;\n    // Conversation 저장\n    await SaveConversationInfoAsync(conversation, userkey, conversationinfo.watermark, conversationinfo.timestamp.Value);<p>    // appSettings 에 설정한 BotId 는 bot을 등록할 때 사용한 Bot handler 와 같아야 한다. \n    var activities = from x in activitySet.Activities\n                            where x.From.Id == botId\n                            select x;<p>    return activities.ToList();\n}</pre>\n<h3>챗봇에서 전달 받은 메시지의 변환</h3>\n챗봇이 카카오톡으로 메시지를 보낼때는 몇가지 문제가 있다. Bot Framework에서는 단순 메시지나 이미지 전달 말고도 다양한 포멧으로 메시지를 전달할 수 있도록 여러가지 Attachment를 지원한다. <a href=\"https://docs.microsoft.com/ko-kr/bot-framework/dotnet/bot-builder-dotnet-add-rich-card-attachments\">\"Add rich card attachments to message\"</a> 문서를 보면 AdaptiveCard, HeroCard, ThumbnailCard 등 다양한 카드타입을 지원하는 걸 알 수 있다. Bot Framework의 공식 채널(메신저)들은 각자 표현은 조금씩 다르지만 이런 카드들을 사용할 수 있다. 하지만 카카오톡은 그렇지 못하다. 따라서 카카오톡으로만 챗봇 서비스를 하는게 아니라면 사용자에게 전달할 컨텐츠를 어떤 방식을 통해 전달할지에 대해서 기획을 하고 그 내용을 카카오톡에서는 어떻게 표현할지 생각해 봐야 한다.<p>또한 챗봇은 여러개의 메시지로 응답을 나눠 보낼 수도 있다. 예를들어 안내 텍스트를 하나의 Activity로 보내고 그 다음에 이미지를 한장 보내고 마지막으로 사용자가 선택할 수있는 버튼이 달린 카드를 보낼 수 있다. 즉 3번을 응답할 수 있고 채널에서는 각각의 메시지를 사용자에게 보여준다. 하지만 카카오톡의 API는 message API가 요청되면 그 응답으로 한번의 메시지만 전달 할 수 있다. Request 당 하나의 메시지만 전달 해야한다.<p>따라서 이런 특성을 이해하고 코드를 작성하는게 중요하다. 여러 고민을 해봤지만 제일 바람직한 방법은 챗봇 코드에서 카카오톡에서 온 요청을 인식하고, 하나의 Activity에 메시지와 이미지 하나를 만들어서 응답하는게 제일 좋은 방법으로 생각된다.\n<pre class=\"prettyprint\">public static Models.MessageResponse DirectLineToKakao(IList&lt;Activity&gt; activities)\n{\n    if (activities == null || activities.Count &lt;= 0) return null;<p>    var msg = new Models.MessageResponse();\n    // 여러개의 Activity\n    foreach (var activity in activities)\n    {\n        if (activity.Type != ActivityTypes.Message) continue;<p>        if (msg.message == null) msg.message = new Message();\n        // 텍스트 메시지를 누적 시킴\n        msg.message.text += \"\\n\" + activity.Text;<p>        if (activity.Attachments != null &amp;&amp; activity.Attachments.Count &gt; 0)\n        {\n            foreach (Attachment attachment in activity.Attachments)\n            {\n                switch (attachment.ContentType)\n                {\n                    case \"image/png\":\n                    case \"image/jpeg\":\n                        // activity는 attachment가 배열로 여러개가 오지만 Kakao는 한개만 가능.\n                        // 따라서 처음 하나만 보여지는 걸로 ... \n                        if (msg.message.photo == null)\n                        {\n                            msg.message.photo = new Photo\n                            {\n                                url = attachment.ContentUrl\n                            };\n                        }\n                        break;\n                }\n            }\n        }\n    }\n    return msg;\n}</pre>\n여러개의 Activity를 받아서 카카오톡이 표현할 수 있는 메시지 형태로 변환해주는 코드는 위와 같다. 텍스트를 붙여서 하나로 만든다거나 Attachment 중에 이미지 타입만 처리하고 그것도 한개만 처리하도록 했다. 데이터가 누락되는 것이다. 여기에서는 이렇게 방어코드를 넣어놓고 챗봇에서 카카오톡으로 보낼 때만 특별히 하나의 Activity 응답으로 만들어서 보내도록 분기를 해주는 방법이 적당할 것 같다. 그 방법은 카카오톡에서 전송된 Activity의 내용중에 From 을 살펴보고 분기하는 방법이다.\n<pre class=\"prettyprint\">[LuisIntent(\"인사\")]\npublic async Task Greeting(IDialogContext context, LuisResult result)\n{\n    if (context.Activity.From.Name == \"kakao\")\n    {\n        string message = $\"안녕하세요. 저는 오일석 봇입니다. 저를 만든 오일석을 대신해서 제가 도움을 드릴 수 있으면 좋겠네요.  저는 이런걸 할 수 있어요.\\n 제 소개를 해드릴 수 있어요.\\n 제 인사를 할수도 있죠.\";\n        await context.PostAsync(message);\n    }\n    else\n    {\n        string message = $\"안녕하세요. 저는 오일석 봇입니다. 저를 만든 오일석을 대신해서 제가 도움을 드릴 수 있으면 좋겠네요.  \";\n        await context.PostAsync(message);<p>        string message2 = $\"저는 이런걸 할 수 있어요.\\n 제 소개를 해드릴 수 있어요.\\n 제 인사를 할수도 있죠.\";\n        await context.PostAsync(message2);\n        context.Wait(MessageReceived);\n    }\n}\n</pre>\n&nbsp;\n<h3>해결하지 못한 두가지 문제점</h3>\n<ul>\n \t<li>카카오톡으로 이미지를 전달할 때 width와 height를 같이 주도록 되어 있고 값을 넘기지 않으면 이미지를 표시하지 않는다. 하지만 전체 흐름에서 보면 width와 height를 알아내서 전달해주기 위해서는 이미지를 다운받아서 width/height를 직접 알아내는 방법 뿐이다. (굳이 왜 w / h를 받으려고 해쓰가...)</li>\n \t<li>타임아웃 문제 : 카카오톡 API는 5초안에 응답이 안오면 오류를 발생시킨다. 채팅인데 5초 타임아웃은 가혹하다.  봇 커넥터를 통해서 봇까지 가서 LUIS 서비스를 다녀오고 혹여나 백엔드 서비스까지 있다면 타임아웃이 걸릴 수도 있다. 실제로 관리자에게 오류 메시지가 오는데 타임아웃이 원인인 것 같다. 그리고 그 원인을 살펴볼 방법이 없다.</li>\n</ul>\n<h3>마무리</h3>\n두개의 웹앱을 모두 테스트 해야하는데 두개를 모두 로컬 머신에서 테스트하는게 불가능했다. 모두 배포를 한 후에 테스트를 하거나 반쪽씩 테스트를 진행해야 했다. Postman과 fiddler를 모두 동원해서 오고가는 메시지를 확인하면서 테스트를 해야한다. 따라서 별도의 개발환경을 Azure에 구축하고 배포 후 테스트를 하는 방법이 가장 적당할 것이다.<p>여기까지 주요 코드를 살펴보면서 카카오톡과 Microsoft Bot Framework를 붙여서 챗봇을 서비스하는 방법을 살펴봤다. 카카오에서 좀 더 멋진 챗봇 프레임워크를 만들어서 공개할 것으로 믿고 그 방법이 Microsoft Bot Framework와 잘 연동이 되었으면 하는 바램이다.<p><img class=\"size-large wp-image-5222 aligncenter\" src=\"/content/images/2017/06/kakao-screen-1024x599.png\" alt=\"\" width=\"640\" height=\"374\" />\n<h3>추가 자료</h3>\n<ul>\n \t<li>전체 소스: <a href=\"https://github.com/ilseokoh/ohilseokbot\">https://github.com/ilseokoh/ohilseokbot</a></li>\n \t<li>Direct Line 사용 샘플: <a href=\"https://github.com/Microsoft/BotBuilder-Samples/tree/master/CSharp/core-DirectLine\">https://github.com/Microsoft/BotBuilder-Samples/tree/master/CSharp/core-DirectLine </a></li>\n \t<li><a href=\"http://ilseokoh.com/2016/12/05/microsoft-bot-framework-dialog/\">[Microsoft Bot Framework] Dialog를 사용하여 대화의 흐름 만들기</a></li>\n \t<li><a href=\"http://ilseokoh.com/2016/12/10/microsoft-bot-framework-%ec%83%81%ed%83%9c%ec%a0%80%ec%9e%a5%ec%9d%84-%ec%9c%84%ed%95%9c-bot-state-service/\">[Microsoft Bot Framework] 상태저장을 위한 Bot State Service</a></li>\n \t<li><a href=\"http://ilseokoh.com/2016/12/02/microsoft-bot-framework-direct-line-rest-api-3-0/\">[Microsoft Bot Framework] Direct Line REST API 3.0</a></li>\n \t<li><a href=\"http://ilseokoh.com/2016/12/03/%ED%95%80%EC%BC%93-cs-chatbot-%EB%A7%8C%EB%93%A4%EA%B8%B0-hackfest-%EC%82%AC%EB%A1%80/\">핀켓 CS ChatBot 만들기 HackFest 사례</a></li>\n</ul>",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1498102099000,
                "created_by": 1,
                "updated_at": 1498102099000,
                "updated_by": 1,
                "published_at": 1498102099000,
                "published_by": 1
            },
            {
                "id": 5229,
                "title": "Azure Blob Storage를 사용해서 정적인 웹 사이트 배포",
                "slug": "azure-blob-storage-web-site",
                "markdown": "아주 간단한 웹사이트가 필요할 때가 있다.\n\n로그인도 필요없고 복잡한 기능이 없는, 문서를 공유하자던 웹의 본질에 가까운 그런 사이트가 필요할 때가 있다. 회사소개 홈페이지, 정식 서비스 오픈전에 공사중임을 표시하는 랜딩 페이지,  웹에서 작동되는 게임이 올라간 웹 페이지 등 그런 사례는 많다. 이런 웹사이트의 대걔 html, js, css, 이미지 파일 몇 개로  구성되고 서버측 개발이 필요없다. 이 사이트를 운영하기 위해서 가상컴퓨터나 Azure 웹앱도 부담스럽다. 이럴 때 Azure blob storage에 컨텐츠를 복사해서 쉽게 웹 사이트를 운영할 수 있다. Azure Blob Storage에 http 서버가 내장되어 있기 때문이다.\n\n이 글은 Azure blob storage 정적인 웹사이트를 운영하는 방법과 수정이 되었을 때 배포, 성능향상을 위한 최적화에 대한 내용이다.\n<ul>\n \t<li>gulp 와 여러 gulp 플러그인을 이용해서 html / js/ css를 minify 하고 gzip으로 압축하여 최적화</li>\n \t<li>html / js / css / image 를 Azure Blob Storage에 Dev 환경과 Production 환경에 각각 배포</li>\n</ul>\n이글과 관련된 소스코드는 <a href=\"https://github.com/ilseokoh/jwplayertest\">Github ilseokoh/jwplayertest에 공개</a>되어 있다.\n<h3>사전준비</h3>\n<ul>\n \t<li>Node.js 환경을 이용하지만 잘 알아야 하는 건 아니다.</li>\n \t<li>Gulp 에 대한 학습 - <a href=\"http://programmingsummaries.tistory.com/356\">감성프로그램님이 번역해놓은 글</a> 참조</li>\n \t<li>Node.js 설치 - <a href=\"https://nodejs.org/ko/download/package-manager/\">패키지 매니저로 Node.js 설치하기</a>. 윈도우라면 <a href=\"https://nodejs.org/en/#download\">윈도우 인스톨러</a>로 설치. 맥이라면 <a href=\"https://nodejs.org/en/download/\">맥용 인스톨러</a>로 설치</li>\n \t<li>웹사이트 컨텐츠 준비 - 샘플코드에서는 src 라는 폴더에 html, src/js 폴더에 javascript, src/css 에 CSS 파일, src/img 에 이미지 파일을 준비했다.</li>\n</ul>\n<a href=\"/content/images/2017/07/vscode-tree.jpg\"><img class=\"size-full wp-image-5237 aligncenter\" src=\"/content/images/2017/07/vscode-tree.jpg\" alt=\"\" width=\"2850\" height=\"1706\" /></a>\n<ul>\n \t<li>package.json 파일을 만들고 Gulp 및 Gulp 플러그인 설치</li>\n</ul>\n<pre class=\"prettyprint\">&gt; npm --version\n3.10.10\n\n&gt; npm init\n\nname: (oproject)\nversion: (1.0.0)\ndescription:\nentry point: (index.js)\ntest command:\ngit repository:\nkeywords:\nauthor:\nlicense: (ISC)\nAbout to write to C:\\src\\oproject\\package.json:\n{\n  \"name\": \"oproject\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\"\n}\n\n&gt; npm install gulp -g</pre>\n<ul>\n \t<li>필요한 gulp 플러그인을 아래 명령으로 설치한다. 개발환경에서만 필요하기 때문에 --save-dev 옵션을 붙여준다.</li>\n</ul>\n<pre class=\"prettyprint\">&gt; npm install gulp-clean-css gulp-concat gulp-deploy-azure-cdn gulp-livereload gulp-minify-html gulp-uglify gulp-util gulp-webserver --save-dev</pre>\n<table>\n<tbody>\n<tr>\n<td><a href=\"https://www.npmjs.com/package/gulp-deploy-azure-cdn\">gulp-deploy-azure-cdn</a></td>\n<td>Azure Blob 스토리지로 컨텐츠를 업로드. gzip 압축과 http header 설정 기능도 포함되어 있다.</td>\n</tr>\n<tr>\n<td><a href=\"https://www.npmjs.com/package/gulp-clean-css\">gulp-clean-css</a></td>\n<td>CSS를 minify(공백,코멘트를 제거하여 용량을 줄임)</td>\n</tr>\n<tr>\n<td><a href=\"https://www.npmjs.com/package/gulp-minify-html\">gulp-minify-html</a></td>\n<td>HTML을 minify(공백, 코멘트를 제거해서 용량을 줄이는 방법)해준다.</td>\n</tr>\n<tr>\n<td><a href=\"https://www.npmjs.com/package/gulp-uglify\">gulp-uglify</a></td>\n<td>javascript 파일을 uglify(공백, 코멘트등을 제거해서 용량을 줄이는 방법)해준다.</td>\n</tr>\n<tr>\n<td><a href=\"https://www.npmjs.com/package/gulp-util\">gulp-util</a></td>\n<td>gulp util 여기서는 dev / production 환경을 스위치 하는데 썼다.</td>\n</tr>\n<tr>\n<td><a href=\"https://www.npmjs.com/package/gulp-concat\">gulp-concat</a></td>\n<td>string 붙이는 플러그인</td>\n</tr>\n<tr>\n<td><a href=\"https://www.npmjs.com/package/gulp-webserver\">gulp-webserver</a></td>\n<td>로컬 테스트용 웹서버. http://localhost:8000으로 접근해서 디버깅 용도</td>\n</tr>\n<tr>\n<td><a href=\"https://www.npmjs.com/package/gulp-livereload\">gulp-livereload</a></td>\n<td>로컬에서 테스트할 때 파일이 변경되면 다시 빌드해주는 플러그인</td>\n</tr>\n</tbody>\n</table>\n&nbsp;\n\n최종 package.json 파일\n<pre class=\"prettyprint\">{\n  \"name\": \"o-project\",\n  \"version\": \"1.0.0\",\n  \"description\": \"O Project\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/ilseokoh/jwplayertest.git\"\n  },\n  \"author\": \"kevin\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/ilseokoh/jwplayertest/issues\"\n  },\n  \"homepage\": \"https://github.com/ilseokoh/jwplayertest#readme\",\n  \"devDependencies\": {\n    \"gulp\": \"^3.9.1\",\n    \"gulp-clean-css\": \"^3.5.0\",\n    \"gulp-concat\": \"^2.6.1\",\n    \"gulp-deploy-azure-cdn\": \"^2.0.0\",\n    \"gulp-livereload\": \"^3.8.1\",\n    \"gulp-minify-html\": \"^1.0.6\",\n    \"gulp-uglify\": \"^3.0.0\",\n    \"gulp-util\": \"^3.0.8\",\n    \"gulp-webserver\": \"^0.9.1\"\n  }\n}</pre>\n<h3>Gulp 파일 만들기</h3>\n이제 gulpfile.js 파일을 만들어서 gulp를 이용해서 하나씩 작업을 이어 나가보자. 먼저 텍스트 에디터를 사용해서 gulpfile.js 파일을 만든다.\n<h3>1. 플러그인 로드와 설정</h3>\ngulpfile.js 상단에 플러그인을 require 문을 이용해서 로딩하고 config 오브젝트에 필요한 설정값들을 준비한다. config에는 소스파일들의 종류에 따른 위치, 결과물이 담길 dist 폴더 그리고 Azure Blob 스토리지의 이름과 키를 설정해준다.\n<pre class=\"prettyprint\">var gulp = require('gulp');\nvar concat = require('gulp-concat');\nvar uglify = require('gulp-uglify');\nvar minifyhtml = require('gulp-minify-html');\nvar cleanCSS = require('gulp-clean-css');\nvar webserver = require('gulp-webserver');\nvar livereload = require('gulp-livereload');\nvar util = require('gulp-util');\nvar deployCdn = require('gulp-deploy-azure-cdn');\n\nconsole.log('Production build? : ' + util.env.production);\n\nvar config = {\n\tjs: 'src/js/**/*.js',\n\tcss: 'src/css/**/*.css',\n\timg: 'src/img/*.*',\n\thtml: 'src/*.html',\n\tdist: 'dist/',\n\tproduction: !!util.env.production,\n\tazureStorageAccountName: 'blobwebapp1',\n\tazureStorageKey: 'uS7lkWaTb+515uR6MsruXWDPJJ4UNxoNJ4Wu8oPZ8O+w4V0CffnsxEW0RhKQ=='\n};\n</pre>\n<h3>2. HTML, Javascript, css 최적화 및 이미지 복사</h3>\nCloud 서비스는 대부분 outbound 트래픽에 과금을 한다. CDN도 마찬가지로 전송된 만큼 과금한다. 따라서 전송 용량을 줄이면 비용이 줄어든다. 아주 작은 용량이라도 오랫동안 절약하면 절약된 비용은 생각보다 크다. 클라우드는 항상 아껴서 사용해야 한다. 또한 용량이 작으면 빠르다. 사용자가 조금이라도 쾌적하게 사이트를 사용할 수 있도록 최적화 해줘야 한다. 그 첫번째 방법이 minify 다.텍스트 기반의 파일들은 모두 minify를 할 수 있다. minify는 공백, 주석 등을 제거하고 js 파일의 경우 긴 변수 이름도 짧게 변경하는 방법등으로 용량을 줄이는 방법이다.\n\n또한 이미지나 동영상에 비해 작은 javascript, CSS 파일의 경우 여러개로 구성되어 있을 경우 여러 번의 HTTP connection을 맺고 끊는 시간 때문에 속도가 느려진다. 따라서 가능하다면 javascript 파일을 하나로 합쳐서 효과를 볼 수 있다.\n\n이 작업을 gulp의 몇 가지 플러그인을 이용해서 할 수 있다. gulp의 태스크를 만들고 pipe로 이어서 명령을 만들어준다.\n\n여기서 config.production 가 true 일때만 minify 최적화를 실행하는데 이건 gulp 명령어의 옵션으로 production과 dev를 구분해준다. &gt; gulp --production 명령은 config.production을 true로 만들어서 minify를 수행한다. 이렇게 하는 이유는 dev 환경에서는 디버깅을 쉽게 하기 위해서 minify를 하지 않는 소스를 사용하는 것이 유리하기 때문이다.\n<pre class=\"prettyprint\">// js 파일을 합치고 uglify, gzip\n// 소스 폴더의 모든 js 파일을 main.js 하나로 합치고 uglify()로 최적화 한다. \ngulp.task('combine-js', function () {\n\treturn gulp.src(config.js)\n\t\t.pipe(concat('main.js'))\n\t\t.pipe(config.production ? uglify() : util.noop())  // production 일때만\n\t\t.pipe(gulp.dest(config.dist + 'js/'));\n});\n\n// HTML 파일 압축 , gzip\ngulp.task('compress-html', function () {\n\treturn gulp.src(config.html)\n\t\t.pipe(config.production ? minifyhtml() : util.noop())\n\t\t.pipe(gulp.dest(config.dist));\n});\n\n// css minify, gzip\ngulp.task('minify-css', () =&gt; {\n  return gulp.src(config.css)\n    .pipe(config.production ? cleanCSS({compatibility: 'ie8'}) : util.noop())\n    .pipe(gulp.dest(config.dist + 'css/'));\n});\n\n// img 폴더 복사. 단순히 복사만 한다. \ngulp.task('copy-img', function () {\n\treturn gulp.src(config.img)\n\t\t.pipe(gulp.dest(config.dist + 'img/'));\n});\n\n// jwplayer 폴더 복사. 외부에서 가져온 소스와 관련 파일은 만지지 않고 그냥 복사만 했다. \ngulp.task('copy-jwplayer', function () {\n\treturn gulp.src('src/jwplayer/**/*')\n\t\t.pipe(gulp.dest(config.dist + 'jwplayer/'));\n});\n\ngulp.task('build', ['combine-js','compress-html','copy-img','minify-css', 'copy-jwplayer']);</pre>\n&nbsp;\n\n마지막 라인에서는 build 라는 태스크를 만들고 위에서 정의한 4가지 태스크를 한번에 수행하는 명령을 만들었다. 이 build 태스크로 지금까지 만든 최적화 코드를 실행할 수 있다. command line 에서 다음과 같이 명령하면 4가지 작업이 수행된다. 결과는 dist 폴더에 생성된다. --production 옵션을 붙였다 떼었다 하면서 minify가 수행되는지도 확인해본다.\n<pre class=\"prettyprint\">&gt; gulp build\n&gt; gulp build --production</pre>\n<h3>3. 로컬 개발환경 설정</h3>\n아무리 간단하고 정적인 코드라고 해도 디버깅이 필요하고 테스트가 필요하기 때문에 gulp-webserver를 사용해서 환경을 만들어준다. 그리고 default 작업을 만들어서 gulp 명령으로 실행되도록 한다. &gt; gulp 명령을 실행하면 build 가 실행되고 watch와 server도 실행된다. 웹 브라우저에서 http://localhost:8000 으로 접속한다. 그러면 index.html이 표시된다. 이 상태에서 소스를 수정하고 웹 브라우저에서 확인하면서 개발을 진행하면 된다.\n<pre class=\"prettyprint\">// 개발용 웹서버 실행 localhost:8000 \ngulp.task('server', function () {\n\treturn gulp.src(config.dist)\n\t\t.pipe(webserver());\n});\n\n// 변경 감지 및 업데이트 \ngulp.task('watch', function () {\n\tlivereload.listen();\n\tgulp.watch(config.js, ['combine-js']);\n\tgulp.watch(config.html, ['compress-html']);\n\tgulp.watch(config.img, ['copy-img']);\n\tgulp.watch(config.css, ['minify-css']);\n\tgulp.watch('dist/**').on('change', livereload.changed);\n});\n\ngulp.task('default', ['build','watch','server']);</pre>\n<h3>4. Azure Blob 스토리지로 업로드</h3>\nAzure Blob 스토리지로 배포를 할 때 Dev 사이트와 Prod(production) 사이트를 구분해서 진행하고 Prod 사이트에는 CDN을 붙여서 라이브 서비스에 활용하고 Dev 사이트는 개발 및 테스트용도록 사용하도록 해보자. 간단한 사이트지만 나름 DevOps 환경을 만들고 향후에 Visual Studio Team Services 같은 협업 툴을 이용하여 CI (Continuous Integration), CD (Continuous Deployment) 까지 설정 가능하다. Azure Storage Account를 만들고 Blob에 dev와 prod라는 이름으로 Container 두 개를 만든다.  두 개 모두 액세스 형식을 Blob 으로 오픈해준다.\n\n<a href=\"/content/images/2017/07/azure-blob-container.png\"><img class=\"size-full wp-image-5241 aligncenter\" src=\"/content/images/2017/07/azure-blob-container.png\" alt=\"\" width=\"2560\" height=\"1600\" /></a>\n\n업로드 중에 한가지 더 최적화를 해줄 수 있다. HTTP 압축을 이용해서 용량을 더 줄여보자. Azure Blob 스토리지로 올릴 때 텍스트 기반의 파일들 (HTML, Javascript, CSS)은 gzip으로 압축을 해주고 이미지나 동영상 같은 파일들은 이미 압축이 되어 있기 때문에 그냥 업로드 하는 방법을 쓰면된다. 다행히 gulp-deploy-azure-cdn 플러그인에 그 기능이 들어있다.  zip: true 옵션을 사용하면 컨텐츠를 gzip으로 압축하고 contentEncoding 값을 gzip으로 설정해서 업로드 한다. 이렇게 되면 HTTP 헤더에 contentEncoding: gzip 값이 설정되어 웹브라우저에서 올바로 컨텐츠를 표시할 수 있다. 전송용량이 또 한번 줄어들기 때문에 비용과 속도 면에서 효과를 볼 수 있다.\n<pre class=\"prettyprint\">// css, js, html파일을 제외한 파일들을 gzip하지 않고 Azure blog에 업로드\ngulp.task('dev-without-gzip', function () { \n\treturn gulp.src(config.dist + \"**/!(*.css|*.js|*.html)\")\n\t\t\t.pipe(deployCdn({\n                containerName: 'dev',\n                serviceOptions: [config.azureStorageAccountName, config.azureStorageKey],\n                folder:  '',\n                zip: false,\n\t\t\t\tconcurrentUploadThreads: 10,\n\t\t\t}));\n});\n\n// css, js, html 파일은 gzip으로 압축하고 contentEncoding을 gzip으로 설정하고 업로드\ngulp.task('dev-gzip', function () { \n\treturn gulp.src(config.dist + \"**/*.{css,js,html}\")\n\t\t\t.pipe(deployCdn({\n                containerName: 'dev',\n                serviceOptions: [config.azureStorageAccountName, config.azureStorageKey],\n                folder:  '',\n                zip: true,\n\t\t\t\tconcurrentUploadThreads: 10,\n\t\t\t}));\n});\n\ngulp.task('prod-without-gzip', function () { \n\treturn gulp.src(config.dist + '**/!(*.css|*.js|*.html)')\n\t\t\t.pipe(deployCdn({\n                containerName: 'prod',\n                serviceOptions: [config.azureStorageAccountName, config.azureStorageKey],\n                folder:  '',\n                zip: false,\n\t\t\t\tconcurrentUploadThreads: 10,\n\t\t\t}));\n});\n\ngulp.task('prod-gzip', function () { \n\treturn gulp.src(config.dist + '**/*.{css,js,html}')\n\t\t\t.pipe(deployCdn({\n                containerName: 'prod',\n                serviceOptions: [config.azureStorageAccountName, config.azureStorageKey],\n                folder:  '',\n                zip: true,\n\t\t\t\tconcurrentUploadThreads: 10,\n\t\t\t}));\n});\n\ngulp.task('deploy-dev', ['build','dev-gzip', 'dev-without-gzip']);\ngulp.task('deploy-prod', ['build','prod-gzip', 'prod-without-gzip']);</pre>\n이제 아래 명령으로 배포를 실행한다. prod 배포는 --production 스위치를 붙여준다.\n<pre class=\"prettyprint\">&gt; gulp deploy-dev\n&gt; gulp deploy-prod --production</pre>\n<a href=\"/content/images/2017/07/deploy-prod.png\"><img class=\"size-full wp-image-5244 aligncenter\" src=\"/content/images/2017/07/deploy-prod.png\" alt=\"\" width=\"2402\" height=\"1760\" /></a>\n\n여기까지 gulpfile.js에 대한 설명이고 <a href=\"https://github.com/ilseokoh/jwplayertest/blob/master/gulpfile.js\">전체 소스코드는 github</a>에서 살펴볼 수 있다.\n\n최종 결과물을 보려면 Blob URL (예를들어 https://blobwebapp1.blob.core.windows.net/prod/index.html) 로 접속해서 결과물을 확인할 수 있다.\n\n&nbsp;",
                "html": "아주 간단한 웹사이트가 필요할 때가 있다.<p>로그인도 필요없고 복잡한 기능이 없는, 문서를 공유하자던 웹의 본질에 가까운 그런 사이트가 필요할 때가 있다. 회사소개 홈페이지, 정식 서비스 오픈전에 공사중임을 표시하는 랜딩 페이지,  웹에서 작동되는 게임이 올라간 웹 페이지 등 그런 사례는 많다. 이런 웹사이트의 대걔 html, js, css, 이미지 파일 몇 개로  구성되고 서버측 개발이 필요없다. 이 사이트를 운영하기 위해서 가상컴퓨터나 Azure 웹앱도 부담스럽다. 이럴 때 Azure blob storage에 컨텐츠를 복사해서 쉽게 웹 사이트를 운영할 수 있다. Azure Blob Storage에 http 서버가 내장되어 있기 때문이다.<p>이 글은 Azure blob storage 정적인 웹사이트를 운영하는 방법과 수정이 되었을 때 배포, 성능향상을 위한 최적화에 대한 내용이다.\n<ul>\n \t<li>gulp 와 여러 gulp 플러그인을 이용해서 html / js/ css를 minify 하고 gzip으로 압축하여 최적화</li>\n \t<li>html / js / css / image 를 Azure Blob Storage에 Dev 환경과 Production 환경에 각각 배포</li>\n</ul>\n이글과 관련된 소스코드는 <a href=\"https://github.com/ilseokoh/jwplayertest\">Github ilseokoh/jwplayertest에 공개</a>되어 있다.\n<h3>사전준비</h3>\n<ul>\n \t<li>Node.js 환경을 이용하지만 잘 알아야 하는 건 아니다.</li>\n \t<li>Gulp 에 대한 학습 - <a href=\"http://programmingsummaries.tistory.com/356\">감성프로그램님이 번역해놓은 글</a> 참조</li>\n \t<li>Node.js 설치 - <a href=\"https://nodejs.org/ko/download/package-manager/\">패키지 매니저로 Node.js 설치하기</a>. 윈도우라면 <a href=\"https://nodejs.org/en/#download\">윈도우 인스톨러</a>로 설치. 맥이라면 <a href=\"https://nodejs.org/en/download/\">맥용 인스톨러</a>로 설치</li>\n \t<li>웹사이트 컨텐츠 준비 - 샘플코드에서는 src 라는 폴더에 html, src/js 폴더에 javascript, src/css 에 CSS 파일, src/img 에 이미지 파일을 준비했다.</li>\n</ul>\n<a href=\"/content/images/2017/07/vscode-tree.jpg\"><img class=\"size-full wp-image-5237 aligncenter\" src=\"/content/images/2017/07/vscode-tree.jpg\" alt=\"\" width=\"2850\" height=\"1706\" /></a>\n<ul>\n \t<li>package.json 파일을 만들고 Gulp 및 Gulp 플러그인 설치</li>\n</ul>\n<pre class=\"prettyprint\">&gt; npm --version\n3.10.10<p>&gt; npm init<p>name: (oproject)\nversion: (1.0.0)\ndescription:\nentry point: (index.js)\ntest command:\ngit repository:\nkeywords:\nauthor:\nlicense: (ISC)\nAbout to write to C:\\src\\oproject\\package.json:\n{\n  \"name\": \"oproject\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\"\n}<p>&gt; npm install gulp -g</pre>\n<ul>\n \t<li>필요한 gulp 플러그인을 아래 명령으로 설치한다. 개발환경에서만 필요하기 때문에 --save-dev 옵션을 붙여준다.</li>\n</ul>\n<pre class=\"prettyprint\">&gt; npm install gulp-clean-css gulp-concat gulp-deploy-azure-cdn gulp-livereload gulp-minify-html gulp-uglify gulp-util gulp-webserver --save-dev</pre>\n<table>\n<tbody>\n<tr>\n<td><a href=\"https://www.npmjs.com/package/gulp-deploy-azure-cdn\">gulp-deploy-azure-cdn</a></td>\n<td>Azure Blob 스토리지로 컨텐츠를 업로드. gzip 압축과 http header 설정 기능도 포함되어 있다.</td>\n</tr>\n<tr>\n<td><a href=\"https://www.npmjs.com/package/gulp-clean-css\">gulp-clean-css</a></td>\n<td>CSS를 minify(공백,코멘트를 제거하여 용량을 줄임)</td>\n</tr>\n<tr>\n<td><a href=\"https://www.npmjs.com/package/gulp-minify-html\">gulp-minify-html</a></td>\n<td>HTML을 minify(공백, 코멘트를 제거해서 용량을 줄이는 방법)해준다.</td>\n</tr>\n<tr>\n<td><a href=\"https://www.npmjs.com/package/gulp-uglify\">gulp-uglify</a></td>\n<td>javascript 파일을 uglify(공백, 코멘트등을 제거해서 용량을 줄이는 방법)해준다.</td>\n</tr>\n<tr>\n<td><a href=\"https://www.npmjs.com/package/gulp-util\">gulp-util</a></td>\n<td>gulp util 여기서는 dev / production 환경을 스위치 하는데 썼다.</td>\n</tr>\n<tr>\n<td><a href=\"https://www.npmjs.com/package/gulp-concat\">gulp-concat</a></td>\n<td>string 붙이는 플러그인</td>\n</tr>\n<tr>\n<td><a href=\"https://www.npmjs.com/package/gulp-webserver\">gulp-webserver</a></td>\n<td>로컬 테스트용 웹서버. http://localhost:8000으로 접근해서 디버깅 용도</td>\n</tr>\n<tr>\n<td><a href=\"https://www.npmjs.com/package/gulp-livereload\">gulp-livereload</a></td>\n<td>로컬에서 테스트할 때 파일이 변경되면 다시 빌드해주는 플러그인</td>\n</tr>\n</tbody>\n</table>\n&nbsp;<p>최종 package.json 파일\n<pre class=\"prettyprint\">{\n  \"name\": \"o-project\",\n  \"version\": \"1.0.0\",\n  \"description\": \"O Project\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/ilseokoh/jwplayertest.git\"\n  },\n  \"author\": \"kevin\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/ilseokoh/jwplayertest/issues\"\n  },\n  \"homepage\": \"https://github.com/ilseokoh/jwplayertest#readme\",\n  \"devDependencies\": {\n    \"gulp\": \"^3.9.1\",\n    \"gulp-clean-css\": \"^3.5.0\",\n    \"gulp-concat\": \"^2.6.1\",\n    \"gulp-deploy-azure-cdn\": \"^2.0.0\",\n    \"gulp-livereload\": \"^3.8.1\",\n    \"gulp-minify-html\": \"^1.0.6\",\n    \"gulp-uglify\": \"^3.0.0\",\n    \"gulp-util\": \"^3.0.8\",\n    \"gulp-webserver\": \"^0.9.1\"\n  }\n}</pre>\n<h3>Gulp 파일 만들기</h3>\n이제 gulpfile.js 파일을 만들어서 gulp를 이용해서 하나씩 작업을 이어 나가보자. 먼저 텍스트 에디터를 사용해서 gulpfile.js 파일을 만든다.\n<h3>1. 플러그인 로드와 설정</h3>\ngulpfile.js 상단에 플러그인을 require 문을 이용해서 로딩하고 config 오브젝트에 필요한 설정값들을 준비한다. config에는 소스파일들의 종류에 따른 위치, 결과물이 담길 dist 폴더 그리고 Azure Blob 스토리지의 이름과 키를 설정해준다.\n<pre class=\"prettyprint\">var gulp = require('gulp');\nvar concat = require('gulp-concat');\nvar uglify = require('gulp-uglify');\nvar minifyhtml = require('gulp-minify-html');\nvar cleanCSS = require('gulp-clean-css');\nvar webserver = require('gulp-webserver');\nvar livereload = require('gulp-livereload');\nvar util = require('gulp-util');\nvar deployCdn = require('gulp-deploy-azure-cdn');<p>console.log('Production build? : ' + util.env.production);<p>var config = {\n\tjs: 'src/js/**/*.js',\n\tcss: 'src/css/**/*.css',\n\timg: 'src/img/*.*',\n\thtml: 'src/*.html',\n\tdist: 'dist/',\n\tproduction: !!util.env.production,\n\tazureStorageAccountName: 'blobwebapp1',\n\tazureStorageKey: 'uS7lkWaTb+515uR6MsruXWDPJJ4UNxoNJ4Wu8oPZ8O+w4V0CffnsxEW0RhKQ=='\n};\n</pre>\n<h3>2. HTML, Javascript, css 최적화 및 이미지 복사</h3>\nCloud 서비스는 대부분 outbound 트래픽에 과금을 한다. CDN도 마찬가지로 전송된 만큼 과금한다. 따라서 전송 용량을 줄이면 비용이 줄어든다. 아주 작은 용량이라도 오랫동안 절약하면 절약된 비용은 생각보다 크다. 클라우드는 항상 아껴서 사용해야 한다. 또한 용량이 작으면 빠르다. 사용자가 조금이라도 쾌적하게 사이트를 사용할 수 있도록 최적화 해줘야 한다. 그 첫번째 방법이 minify 다.텍스트 기반의 파일들은 모두 minify를 할 수 있다. minify는 공백, 주석 등을 제거하고 js 파일의 경우 긴 변수 이름도 짧게 변경하는 방법등으로 용량을 줄이는 방법이다.<p>또한 이미지나 동영상에 비해 작은 javascript, CSS 파일의 경우 여러개로 구성되어 있을 경우 여러 번의 HTTP connection을 맺고 끊는 시간 때문에 속도가 느려진다. 따라서 가능하다면 javascript 파일을 하나로 합쳐서 효과를 볼 수 있다.<p>이 작업을 gulp의 몇 가지 플러그인을 이용해서 할 수 있다. gulp의 태스크를 만들고 pipe로 이어서 명령을 만들어준다.<p>여기서 config.production 가 true 일때만 minify 최적화를 실행하는데 이건 gulp 명령어의 옵션으로 production과 dev를 구분해준다. &gt; gulp --production 명령은 config.production을 true로 만들어서 minify를 수행한다. 이렇게 하는 이유는 dev 환경에서는 디버깅을 쉽게 하기 위해서 minify를 하지 않는 소스를 사용하는 것이 유리하기 때문이다.\n<pre class=\"prettyprint\">// js 파일을 합치고 uglify, gzip\n// 소스 폴더의 모든 js 파일을 main.js 하나로 합치고 uglify()로 최적화 한다. \ngulp.task('combine-js', function () {\n\treturn gulp.src(config.js)\n\t\t.pipe(concat('main.js'))\n\t\t.pipe(config.production ? uglify() : util.noop())  // production 일때만\n\t\t.pipe(gulp.dest(config.dist + 'js/'));\n});<p>// HTML 파일 압축 , gzip\ngulp.task('compress-html', function () {\n\treturn gulp.src(config.html)\n\t\t.pipe(config.production ? minifyhtml() : util.noop())\n\t\t.pipe(gulp.dest(config.dist));\n});<p>// css minify, gzip\ngulp.task('minify-css', () =&gt; {\n  return gulp.src(config.css)\n    .pipe(config.production ? cleanCSS({compatibility: 'ie8'}) : util.noop())\n    .pipe(gulp.dest(config.dist + 'css/'));\n});<p>// img 폴더 복사. 단순히 복사만 한다. \ngulp.task('copy-img', function () {\n\treturn gulp.src(config.img)\n\t\t.pipe(gulp.dest(config.dist + 'img/'));\n});<p>// jwplayer 폴더 복사. 외부에서 가져온 소스와 관련 파일은 만지지 않고 그냥 복사만 했다. \ngulp.task('copy-jwplayer', function () {\n\treturn gulp.src('src/jwplayer/**/*')\n\t\t.pipe(gulp.dest(config.dist + 'jwplayer/'));\n});<p>gulp.task('build', ['combine-js','compress-html','copy-img','minify-css', 'copy-jwplayer']);</pre>\n&nbsp;<p>마지막 라인에서는 build 라는 태스크를 만들고 위에서 정의한 4가지 태스크를 한번에 수행하는 명령을 만들었다. 이 build 태스크로 지금까지 만든 최적화 코드를 실행할 수 있다. command line 에서 다음과 같이 명령하면 4가지 작업이 수행된다. 결과는 dist 폴더에 생성된다. --production 옵션을 붙였다 떼었다 하면서 minify가 수행되는지도 확인해본다.\n<pre class=\"prettyprint\">&gt; gulp build\n&gt; gulp build --production</pre>\n<h3>3. 로컬 개발환경 설정</h3>\n아무리 간단하고 정적인 코드라고 해도 디버깅이 필요하고 테스트가 필요하기 때문에 gulp-webserver를 사용해서 환경을 만들어준다. 그리고 default 작업을 만들어서 gulp 명령으로 실행되도록 한다. &gt; gulp 명령을 실행하면 build 가 실행되고 watch와 server도 실행된다. 웹 브라우저에서 http://localhost:8000 으로 접속한다. 그러면 index.html이 표시된다. 이 상태에서 소스를 수정하고 웹 브라우저에서 확인하면서 개발을 진행하면 된다.\n<pre class=\"prettyprint\">// 개발용 웹서버 실행 localhost:8000 \ngulp.task('server', function () {\n\treturn gulp.src(config.dist)\n\t\t.pipe(webserver());\n});<p>// 변경 감지 및 업데이트 \ngulp.task('watch', function () {\n\tlivereload.listen();\n\tgulp.watch(config.js, ['combine-js']);\n\tgulp.watch(config.html, ['compress-html']);\n\tgulp.watch(config.img, ['copy-img']);\n\tgulp.watch(config.css, ['minify-css']);\n\tgulp.watch('dist/**').on('change', livereload.changed);\n});<p>gulp.task('default', ['build','watch','server']);</pre>\n<h3>4. Azure Blob 스토리지로 업로드</h3>\nAzure Blob 스토리지로 배포를 할 때 Dev 사이트와 Prod(production) 사이트를 구분해서 진행하고 Prod 사이트에는 CDN을 붙여서 라이브 서비스에 활용하고 Dev 사이트는 개발 및 테스트용도록 사용하도록 해보자. 간단한 사이트지만 나름 DevOps 환경을 만들고 향후에 Visual Studio Team Services 같은 협업 툴을 이용하여 CI (Continuous Integration), CD (Continuous Deployment) 까지 설정 가능하다. Azure Storage Account를 만들고 Blob에 dev와 prod라는 이름으로 Container 두 개를 만든다.  두 개 모두 액세스 형식을 Blob 으로 오픈해준다.<p><a href=\"/content/images/2017/07/azure-blob-container.png\"><img class=\"size-full wp-image-5241 aligncenter\" src=\"/content/images/2017/07/azure-blob-container.png\" alt=\"\" width=\"2560\" height=\"1600\" /></a><p>업로드 중에 한가지 더 최적화를 해줄 수 있다. HTTP 압축을 이용해서 용량을 더 줄여보자. Azure Blob 스토리지로 올릴 때 텍스트 기반의 파일들 (HTML, Javascript, CSS)은 gzip으로 압축을 해주고 이미지나 동영상 같은 파일들은 이미 압축이 되어 있기 때문에 그냥 업로드 하는 방법을 쓰면된다. 다행히 gulp-deploy-azure-cdn 플러그인에 그 기능이 들어있다.  zip: true 옵션을 사용하면 컨텐츠를 gzip으로 압축하고 contentEncoding 값을 gzip으로 설정해서 업로드 한다. 이렇게 되면 HTTP 헤더에 contentEncoding: gzip 값이 설정되어 웹브라우저에서 올바로 컨텐츠를 표시할 수 있다. 전송용량이 또 한번 줄어들기 때문에 비용과 속도 면에서 효과를 볼 수 있다.\n<pre class=\"prettyprint\">// css, js, html파일을 제외한 파일들을 gzip하지 않고 Azure blog에 업로드\ngulp.task('dev-without-gzip', function () { \n\treturn gulp.src(config.dist + \"**/!(*.css|*.js|*.html)\")\n\t\t\t.pipe(deployCdn({\n                containerName: 'dev',\n                serviceOptions: [config.azureStorageAccountName, config.azureStorageKey],\n                folder:  '',\n                zip: false,\n\t\t\t\tconcurrentUploadThreads: 10,\n\t\t\t}));\n});<p>// css, js, html 파일은 gzip으로 압축하고 contentEncoding을 gzip으로 설정하고 업로드\ngulp.task('dev-gzip', function () { \n\treturn gulp.src(config.dist + \"**/*.{css,js,html}\")\n\t\t\t.pipe(deployCdn({\n                containerName: 'dev',\n                serviceOptions: [config.azureStorageAccountName, config.azureStorageKey],\n                folder:  '',\n                zip: true,\n\t\t\t\tconcurrentUploadThreads: 10,\n\t\t\t}));\n});<p>gulp.task('prod-without-gzip', function () { \n\treturn gulp.src(config.dist + '**/!(*.css|*.js|*.html)')\n\t\t\t.pipe(deployCdn({\n                containerName: 'prod',\n                serviceOptions: [config.azureStorageAccountName, config.azureStorageKey],\n                folder:  '',\n                zip: false,\n\t\t\t\tconcurrentUploadThreads: 10,\n\t\t\t}));\n});<p>gulp.task('prod-gzip', function () { \n\treturn gulp.src(config.dist + '**/*.{css,js,html}')\n\t\t\t.pipe(deployCdn({\n                containerName: 'prod',\n                serviceOptions: [config.azureStorageAccountName, config.azureStorageKey],\n                folder:  '',\n                zip: true,\n\t\t\t\tconcurrentUploadThreads: 10,\n\t\t\t}));\n});<p>gulp.task('deploy-dev', ['build','dev-gzip', 'dev-without-gzip']);\ngulp.task('deploy-prod', ['build','prod-gzip', 'prod-without-gzip']);</pre>\n이제 아래 명령으로 배포를 실행한다. prod 배포는 --production 스위치를 붙여준다.\n<pre class=\"prettyprint\">&gt; gulp deploy-dev\n&gt; gulp deploy-prod --production</pre>\n<a href=\"/content/images/2017/07/deploy-prod.png\"><img class=\"size-full wp-image-5244 aligncenter\" src=\"/content/images/2017/07/deploy-prod.png\" alt=\"\" width=\"2402\" height=\"1760\" /></a><p>여기까지 gulpfile.js에 대한 설명이고 <a href=\"https://github.com/ilseokoh/jwplayertest/blob/master/gulpfile.js\">전체 소스코드는 github</a>에서 살펴볼 수 있다.<p>최종 결과물을 보려면 Blob URL (예를들어 https://blobwebapp1.blob.core.windows.net/prod/index.html) 로 접속해서 결과물을 확인할 수 있다.<p>&nbsp;",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1499094905000,
                "created_by": 1,
                "updated_at": 1499094905000,
                "updated_by": 1,
                "published_at": 1499094905000,
                "published_by": 1
            },
            {
                "id": 5258,
                "title": "사슴벌레 애벌레 횽뭉이",
                "slug": "stag-beetle",
                "markdown": "<ul>\n \t<li>넙적사슴벌레 애벌레 횽뭉이</li>\n \t<li>4.22일 부화, 현재 3령, 수컷</li>\n \t<li>균사통에서 사육중</li>\n</ul>\n균사통 뚜껑쪽으로 올라 왔길래 잠시 놀아줌.\n\n<a href=\"/content/images/2017/08/IMG_9955.jpg\"><img class=\"alignnone size-large wp-image-5260\" src=\"/content/images/2017/08/IMG_9955-1024x768.jpg\" alt=\"\" width=\"640\" height=\"480\" /></a>\n\n<a href=\"/content/images/2017/08/IMG_9953.jpg\"><img class=\"alignnone size-large wp-image-5259\" src=\"/content/images/2017/08/IMG_9953-1024x768.jpg\" alt=\"\" width=\"640\" height=\"480\" /></a>\n\n&nbsp;",
                "html": "<ul>\n \t<li>넙적사슴벌레 애벌레 횽뭉이</li>\n \t<li>4.22일 부화, 현재 3령, 수컷</li>\n \t<li>균사통에서 사육중</li>\n</ul>\n균사통 뚜껑쪽으로 올라 왔길래 잠시 놀아줌.<p><a href=\"/content/images/2017/08/IMG_9955.jpg\"><img class=\"alignnone size-large wp-image-5260\" src=\"/content/images/2017/08/IMG_9955-1024x768.jpg\" alt=\"\" width=\"640\" height=\"480\" /></a><p><a href=\"/content/images/2017/08/IMG_9953.jpg\"><img class=\"alignnone size-large wp-image-5259\" src=\"/content/images/2017/08/IMG_9953-1024x768.jpg\" alt=\"\" width=\"640\" height=\"480\" /></a><p>&nbsp;",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1503490957000,
                "created_by": 1,
                "updated_at": 1503490957000,
                "updated_by": 1,
                "published_at": 1503490957000,
                "published_by": 1
            },
            {
                "id": 5292,
                "title": "Managed Disk로 만든 Azure VM을 다른 지역/구독으로 이동",
                "slug": "azure-vm-image-copy",
                "markdown": "<h3>Managed 이미지</h3>\nManaged Disk로 생성된 VM은 Azure 포탈에서 이미지로 만들고 그 이미지에서 새로운 VM을 생성할 수 있다. 이렇게 하면 원본 VM에 설치되어 있던 미들웨어, 애플리케이션이 설치된 그대로 새로운 VM이 생성되기 때문에 여러 곳에 같은 VM을 배포해야 하는 상황에 적용할 수 있다. 하지만 2017년 9월 현재 Managed 이미지에 제약사항이 있다. 다른 지역, 다른 구독으로는 이미지를 복사할 수 없다. 즉 다른 지역/구독으로 새로운 VM을 만들 수 없다. 현재 개발중.\n<h3>Azure VM 이미지를 다른 지역과 구독으로 이전</h3>\n조금 단계가 추가되지만 다른 방법을 쓰면 할 수 있다. 순서는 아래와 같다.\n<div role=\"main\">\n<div id=\"js-repo-pjax-container\" data-pjax-container=\"\">\n<div class=\"container new-discussion-timeline experiment-repo-nav\">\n<div class=\"repository-content\">\n<div id=\"readme\" class=\"readme boxed-group clearfix announce instapaper_body md\"><article class=\"markdown-body entry-content\">\n<ol>\n \t<li>(옵션) 포탈에서 대상이 되는 VM의 디스크를 Snapshot으로 백업한다. (<a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machines/windows/snapshot-copy-managed-disk\">참조문서</a>)</li>\n \t<li>VM을 일반화 (Generalize)한다. (참조문서 <a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machines/windows/capture-image-resource\">윈도우 서버</a>, <a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machines/linux/capture-image\">리눅스</a>)</li>\n \t<li>(옵션) 포탈에서 VM에서 이미지를 만들고 VM으로 잘 생성되는지 테스트한다.</li>\n \t<li>포탈에서 디스크를 찾아 Export 메뉴로 스토리지 SAS URL 생성</li>\n \t<li>타겟이 되는 지역에 리소스그룹과 스토리지를 하나 만들어준다.</li>\n \t<li>Powershell 또는 Azure CLI 2.0을 이용하여 스크립트 실행. 스크립트 상단에 변수를 설정해야 한다.</li>\n</ol>\nPowerShell과 Azure CLI 2.0을 사용한 쉘 스크립트는 Github에 공개했다.\n\n<a href=\"https://github.com/ilseokoh/azure-managed-image-copy\">https://github.com/ilseokoh/azure-managed-image-copy</a>\n\n스크립트를 적용하기 전후에 Azure 포탈에서 할 수 있는 작업들이 있다. 아래 동영상을 보면 전체 과정에 대한 데모를 볼 수 있다.\n\n[embed]https://www.youtube.com/watch?v=5n4256-z16o[/embed]\n\n</article></div>\n</div>\n</div>\n</div>\n</div>",
                "html": "<h3>Managed 이미지</h3>\nManaged Disk로 생성된 VM은 Azure 포탈에서 이미지로 만들고 그 이미지에서 새로운 VM을 생성할 수 있다. 이렇게 하면 원본 VM에 설치되어 있던 미들웨어, 애플리케이션이 설치된 그대로 새로운 VM이 생성되기 때문에 여러 곳에 같은 VM을 배포해야 하는 상황에 적용할 수 있다. 하지만 2017년 9월 현재 Managed 이미지에 제약사항이 있다. 다른 지역, 다른 구독으로는 이미지를 복사할 수 없다. 즉 다른 지역/구독으로 새로운 VM을 만들 수 없다. 현재 개발중.\n<h3>Azure VM 이미지를 다른 지역과 구독으로 이전</h3>\n조금 단계가 추가되지만 다른 방법을 쓰면 할 수 있다. 순서는 아래와 같다.\n<div role=\"main\">\n<div id=\"js-repo-pjax-container\" data-pjax-container=\"\">\n<div class=\"container new-discussion-timeline experiment-repo-nav\">\n<div class=\"repository-content\">\n<div id=\"readme\" class=\"readme boxed-group clearfix announce instapaper_body md\"><article class=\"markdown-body entry-content\">\n<ol>\n \t<li>(옵션) 포탈에서 대상이 되는 VM의 디스크를 Snapshot으로 백업한다. (<a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machines/windows/snapshot-copy-managed-disk\">참조문서</a>)</li>\n \t<li>VM을 일반화 (Generalize)한다. (참조문서 <a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machines/windows/capture-image-resource\">윈도우 서버</a>, <a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machines/linux/capture-image\">리눅스</a>)</li>\n \t<li>(옵션) 포탈에서 VM에서 이미지를 만들고 VM으로 잘 생성되는지 테스트한다.</li>\n \t<li>포탈에서 디스크를 찾아 Export 메뉴로 스토리지 SAS URL 생성</li>\n \t<li>타겟이 되는 지역에 리소스그룹과 스토리지를 하나 만들어준다.</li>\n \t<li>Powershell 또는 Azure CLI 2.0을 이용하여 스크립트 실행. 스크립트 상단에 변수를 설정해야 한다.</li>\n</ol>\nPowerShell과 Azure CLI 2.0을 사용한 쉘 스크립트는 Github에 공개했다.<p><a href=\"https://github.com/ilseokoh/azure-managed-image-copy\">https://github.com/ilseokoh/azure-managed-image-copy</a><p>스크립트를 적용하기 전후에 Azure 포탈에서 할 수 있는 작업들이 있다. 아래 동영상을 보면 전체 과정에 대한 데모를 볼 수 있다.<p>[embed]https://www.youtube.com/watch?v=5n4256-z16o[/embed]<p></article></div>\n</div>\n</div>\n</div>\n</div>",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1506503314000,
                "created_by": 1,
                "updated_at": 1506503314000,
                "updated_by": 1,
                "published_at": 1506503314000,
                "published_by": 1
            },
            {
                "id": 5301,
                "title": "Potable Lamp #1 - Idea sketch",
                "slug": "lamp-1-sketch",
                "markdown": "<a href=\"/content/images/2017/10/sketch-v1.jpeg\"><img class=\"size-full wp-image-5303 aligncenter\" src=\"/content/images/2017/10/sketch-v1.jpeg\" alt=\"\" width=\"626\" height=\"606\" /></a>\n<h3>Portable Lamp</h3>\nMaker Academy Project - Fab lab SEOUL\n<h4>기능</h4>\n<ul>\n \t<li>Rechargeable: Micro USB, Charging Indicator : Red / Green</li>\n \t<li>Soft Latch Power Button</li>\n \t<li>Touch based dimmer controller</li>\n</ul>\n<h4>외관</h4>\n<ul>\n \t<li>가죽끈 손잡이</li>\n \t<li>흰색 플라스틱 바디 - 3D Printed</li>\n \t<li>나무 베이스</li>\n</ul>\n<h4>목표</h4>\n<ul>\n \t<li>Simple and minimal design</li>\n \t<li>Low Cost</li>\n \t<li>Long lighting time</li>\n</ul>\n&nbsp;",
                "html": "<a href=\"/content/images/2017/10/sketch-v1.jpeg\"><img class=\"size-full wp-image-5303 aligncenter\" src=\"/content/images/2017/10/sketch-v1.jpeg\" alt=\"\" width=\"626\" height=\"606\" /></a>\n<h3>Portable Lamp</h3>\nMaker Academy Project - Fab lab SEOUL\n<h4>기능</h4>\n<ul>\n \t<li>Rechargeable: Micro USB, Charging Indicator : Red / Green</li>\n \t<li>Soft Latch Power Button</li>\n \t<li>Touch based dimmer controller</li>\n</ul>\n<h4>외관</h4>\n<ul>\n \t<li>가죽끈 손잡이</li>\n \t<li>흰색 플라스틱 바디 - 3D Printed</li>\n \t<li>나무 베이스</li>\n</ul>\n<h4>목표</h4>\n<ul>\n \t<li>Simple and minimal design</li>\n \t<li>Low Cost</li>\n \t<li>Long lighting time</li>\n</ul>\n&nbsp;",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1507845584000,
                "created_by": 1,
                "updated_at": 1507845584000,
                "updated_by": 1,
                "published_at": 1507845584000,
                "published_by": 1
            },
            {
                "id": 5305,
                "title": "Fusion 360 스터디",
                "slug": "fusion-360-study",
                "markdown": "물건을 만들기 위한 3D 모델링에 적합한 툴은 따로 있었다. Autodesk 사의 Fusion 360. 그 외 Solidworks 같은 툴이 원조격 인가보다. 그 동안 애니메이션 제작에 최적화 되었다고 보이는 Foundry사의 Modo에 시간과 돈을 투자했지만 정확한 치수가 필요한 모델링에는 적합하지 않았다.\n\n기초 과정은 Lynda.com에서 <a href=\"https://www.lynda.com/Fusion-360-tutorials/Fusion-360-Essential-Training/614292-2.html\">\"Fusion 360 Essential\" 강좌</a>를 들었다. 더 찾아보니 <a href=\"https://www.autodesk.co.kr/products/fusion-360/learn-training-tutorials\">Autodesk 홈페이지에 기초 강좌</a>가 많이 있었다.\n\n그리고 연휴를 이용해서 유투브 강좌를 몇 가지 따라했다.\n\n1. 경첩 : <a href=\"https://www.youtube.com/watch?v=iMXEjyda9rk&amp;index=12&amp;list=PLjyiWW2QlmFwUgSxZJONo1uoyN23CksZ4\">Fusion 360 3D Sketch Hinges | Tutorial Beginner | Exercise 5</a>\n\n<a href=\"/content/images/2017/10/hinge.png\"><img class=\"alignnone size-full wp-image-5309\" src=\"/content/images/2017/10/hinge.png\" alt=\"\" width=\"1273\" height=\"742\" /></a>\n\n2. 기어: <a href=\"https://www.youtube.com/watch?v=VKJjzdWjZ4U&amp;list=PLjyiWW2QlmFwUgSxZJONo1uoyN23CksZ4&amp;index=16\">Fusion 360 3D Sketch Gear Tutorial | Beginner Practice 1</a>\n\n<a href=\"/content/images/2017/10/gear.png\"><img class=\"alignnone size-full wp-image-5307\" src=\"/content/images/2017/10/gear.png\" alt=\"\" width=\"1679\" height=\"746\" /></a>\n\n3. 너트 : <a href=\"https://www.youtube.com/watch?v=UN4mUJWckS0&amp;index=15&amp;list=PLjyiWW2QlmFwUgSxZJONo1uoyN23CksZ4\">Fusion 360 3D Sketch Nuts Tutorial | Beginner Practice 2</a>\n\n<a href=\"/content/images/2017/10/nut.png\"><img class=\"alignnone size-full wp-image-5308\" src=\"/content/images/2017/10/nut.png\" alt=\"\" width=\"1679\" height=\"746\" /></a>\n\n4. 볼트: <a href=\"https://www.youtube.com/watch?v=lsoEUDIFoNI&amp;list=PLjyiWW2QlmFwUgSxZJONo1uoyN23CksZ4&amp;index=14\">Fusion 360 3D Sketch Cap Screw Tutorial | Beginner Practice 3</a>\n\n<a href=\"/content/images/2017/10/bolt-v1.png\"><img class=\"alignnone size-full wp-image-5312\" src=\"/content/images/2017/10/bolt-v1.png\" alt=\"\" width=\"1273\" height=\"742\" /></a>\n\n5. 베어링: <a href=\"https://www.youtube.com/watch?v=IWFT1fOpYMo&amp;list=PLjyiWW2QlmFwUgSxZJONo1uoyN23CksZ4&amp;index=8\">Fusion 360 3D Bearing Tutorial Beginner Practice 9</a>\n\n<a href=\"/content/images/2017/10/bearing.png\"><img class=\"alignnone size-full wp-image-5310\" src=\"/content/images/2017/10/bearing.png\" alt=\"\" width=\"1678\" height=\"745\" /></a>\n\n6. Drive Flange: <a href=\"https://www.youtube.com/watch?v=vmMlyQseBRE&amp;index=7&amp;list=PLjyiWW2QlmFwUgSxZJONo1uoyN23CksZ4\">Fusion 360 3D Drive Flange Tutorial Beginner Practice 10</a>\n\n<a href=\"/content/images/2017/10/drive-flange-v2.png\"><img class=\"alignnone size-full wp-image-5311\" src=\"/content/images/2017/10/drive-flange-v2.png\" alt=\"\" width=\"1678\" height=\"745\" /></a>\n\n7. 쓰레받이: <a href=\"https://www.youtube.com/watch?v=_1PzvFyLQpk&amp;index=9&amp;list=PLjyiWW2QlmFwUgSxZJONo1uoyN23CksZ4\">Fusion 360 3D Garbage Shovel Tutorial Beginner Practice 8</a>\n\n<a href=\"/content/images/2017/10/gabage-shovel-v6.png\"><img class=\"alignnone size-full wp-image-5314\" src=\"/content/images/2017/10/gabage-shovel-v6.png\" alt=\"\" width=\"1273\" height=\"742\" /></a>\n\n8. 나무상자: <a href=\"https://www.youtube.com/watch?v=ao27Hac5Uk4&amp;index=11&amp;list=PLjyiWW2QlmFwUgSxZJONo1uoyN23CksZ4\">Fusion 360 3D Wooden Toolbox | Tutorial Beginner | Practice 6</a>\n\n<a href=\"/content/images/2017/10/wooden-box-v3.png\"><img class=\"alignnone size-full wp-image-5313\" src=\"/content/images/2017/10/wooden-box-v3.png\" alt=\"\" width=\"1679\" height=\"746\" /></a>\n\n9. 전등갓 : <a href=\"https://www.youtube.com/watch?v=3PnKBSOulwo\">Fusion 360: Design a 3D Printed Lampshade</a>\n\n<a href=\"/content/images/2017/10/lamp.png\"><img class=\"alignnone size-full wp-image-5317\" src=\"/content/images/2017/10/lamp.png\" alt=\"\" width=\"1677\" height=\"744\" /></a>\n\n10. 손잡이 : <a href=\"https://www.youtube.com/watch?v=NypRE2aFhh4\">Surface Modeling with Fusion 360</a>\n\n<a href=\"/content/images/2017/10/handle-v5.png\"><img class=\"alignnone size-full wp-image-5315\" src=\"/content/images/2017/10/handle-v5.png\" alt=\"\" width=\"1707\" height=\"675\" /></a>\n\n11. 피젯스피너 : 메이커 아카데미 과제\n\n<a href=\"/content/images/2017/10/spinner.png\"><img class=\"alignnone size-full wp-image-5318\" src=\"/content/images/2017/10/spinner.png\" alt=\"\" width=\"1273\" height=\"742\" /></a>",
                "html": "물건을 만들기 위한 3D 모델링에 적합한 툴은 따로 있었다. Autodesk 사의 Fusion 360. 그 외 Solidworks 같은 툴이 원조격 인가보다. 그 동안 애니메이션 제작에 최적화 되었다고 보이는 Foundry사의 Modo에 시간과 돈을 투자했지만 정확한 치수가 필요한 모델링에는 적합하지 않았다.<p>기초 과정은 Lynda.com에서 <a href=\"https://www.lynda.com/Fusion-360-tutorials/Fusion-360-Essential-Training/614292-2.html\">\"Fusion 360 Essential\" 강좌</a>를 들었다. 더 찾아보니 <a href=\"https://www.autodesk.co.kr/products/fusion-360/learn-training-tutorials\">Autodesk 홈페이지에 기초 강좌</a>가 많이 있었다.<p>그리고 연휴를 이용해서 유투브 강좌를 몇 가지 따라했다.<p>1. 경첩 : <a href=\"https://www.youtube.com/watch?v=iMXEjyda9rk&amp;index=12&amp;list=PLjyiWW2QlmFwUgSxZJONo1uoyN23CksZ4\">Fusion 360 3D Sketch Hinges | Tutorial Beginner | Exercise 5</a><p><a href=\"/content/images/2017/10/hinge.png\"><img class=\"alignnone size-full wp-image-5309\" src=\"/content/images/2017/10/hinge.png\" alt=\"\" width=\"1273\" height=\"742\" /></a><p>2. 기어: <a href=\"https://www.youtube.com/watch?v=VKJjzdWjZ4U&amp;list=PLjyiWW2QlmFwUgSxZJONo1uoyN23CksZ4&amp;index=16\">Fusion 360 3D Sketch Gear Tutorial | Beginner Practice 1</a><p><a href=\"/content/images/2017/10/gear.png\"><img class=\"alignnone size-full wp-image-5307\" src=\"/content/images/2017/10/gear.png\" alt=\"\" width=\"1679\" height=\"746\" /></a><p>3. 너트 : <a href=\"https://www.youtube.com/watch?v=UN4mUJWckS0&amp;index=15&amp;list=PLjyiWW2QlmFwUgSxZJONo1uoyN23CksZ4\">Fusion 360 3D Sketch Nuts Tutorial | Beginner Practice 2</a><p><a href=\"/content/images/2017/10/nut.png\"><img class=\"alignnone size-full wp-image-5308\" src=\"/content/images/2017/10/nut.png\" alt=\"\" width=\"1679\" height=\"746\" /></a><p>4. 볼트: <a href=\"https://www.youtube.com/watch?v=lsoEUDIFoNI&amp;list=PLjyiWW2QlmFwUgSxZJONo1uoyN23CksZ4&amp;index=14\">Fusion 360 3D Sketch Cap Screw Tutorial | Beginner Practice 3</a><p><a href=\"/content/images/2017/10/bolt-v1.png\"><img class=\"alignnone size-full wp-image-5312\" src=\"/content/images/2017/10/bolt-v1.png\" alt=\"\" width=\"1273\" height=\"742\" /></a><p>5. 베어링: <a href=\"https://www.youtube.com/watch?v=IWFT1fOpYMo&amp;list=PLjyiWW2QlmFwUgSxZJONo1uoyN23CksZ4&amp;index=8\">Fusion 360 3D Bearing Tutorial Beginner Practice 9</a><p><a href=\"/content/images/2017/10/bearing.png\"><img class=\"alignnone size-full wp-image-5310\" src=\"/content/images/2017/10/bearing.png\" alt=\"\" width=\"1678\" height=\"745\" /></a><p>6. Drive Flange: <a href=\"https://www.youtube.com/watch?v=vmMlyQseBRE&amp;index=7&amp;list=PLjyiWW2QlmFwUgSxZJONo1uoyN23CksZ4\">Fusion 360 3D Drive Flange Tutorial Beginner Practice 10</a><p><a href=\"/content/images/2017/10/drive-flange-v2.png\"><img class=\"alignnone size-full wp-image-5311\" src=\"/content/images/2017/10/drive-flange-v2.png\" alt=\"\" width=\"1678\" height=\"745\" /></a><p>7. 쓰레받이: <a href=\"https://www.youtube.com/watch?v=_1PzvFyLQpk&amp;index=9&amp;list=PLjyiWW2QlmFwUgSxZJONo1uoyN23CksZ4\">Fusion 360 3D Garbage Shovel Tutorial Beginner Practice 8</a><p><a href=\"/content/images/2017/10/gabage-shovel-v6.png\"><img class=\"alignnone size-full wp-image-5314\" src=\"/content/images/2017/10/gabage-shovel-v6.png\" alt=\"\" width=\"1273\" height=\"742\" /></a><p>8. 나무상자: <a href=\"https://www.youtube.com/watch?v=ao27Hac5Uk4&amp;index=11&amp;list=PLjyiWW2QlmFwUgSxZJONo1uoyN23CksZ4\">Fusion 360 3D Wooden Toolbox | Tutorial Beginner | Practice 6</a><p><a href=\"/content/images/2017/10/wooden-box-v3.png\"><img class=\"alignnone size-full wp-image-5313\" src=\"/content/images/2017/10/wooden-box-v3.png\" alt=\"\" width=\"1679\" height=\"746\" /></a><p>9. 전등갓 : <a href=\"https://www.youtube.com/watch?v=3PnKBSOulwo\">Fusion 360: Design a 3D Printed Lampshade</a><p><a href=\"/content/images/2017/10/lamp.png\"><img class=\"alignnone size-full wp-image-5317\" src=\"/content/images/2017/10/lamp.png\" alt=\"\" width=\"1677\" height=\"744\" /></a><p>10. 손잡이 : <a href=\"https://www.youtube.com/watch?v=NypRE2aFhh4\">Surface Modeling with Fusion 360</a><p><a href=\"/content/images/2017/10/handle-v5.png\"><img class=\"alignnone size-full wp-image-5315\" src=\"/content/images/2017/10/handle-v5.png\" alt=\"\" width=\"1707\" height=\"675\" /></a><p>11. 피젯스피너 : 메이커 아카데미 과제<p><a href=\"/content/images/2017/10/spinner.png\"><img class=\"alignnone size-full wp-image-5318\" src=\"/content/images/2017/10/spinner.png\" alt=\"\" width=\"1273\" height=\"742\" /></a>",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1507849056000,
                "created_by": 1,
                "updated_at": 1507849056000,
                "updated_by": 1,
                "published_at": 1507849056000,
                "published_by": 1
            },
            {
                "id": 5320,
                "title": "Portable Lamp #2 - Concept Design",
                "slug": "portable-lamp-2-concept-design",
                "markdown": "<h3>포터블 램프 컨셉 디자인</h3>\n<a href=\"http://ilseokoh.com/2017/10/13/lamp-1-sketch/\">아이디어</a>에서 제품까지 가는 과정에서 생각도 바뀌고, 문제도 생기고, 내가 가진 기술과 경험으로 할 수 없는 것 들이 생기게 마련이다.\n<ul>\n \t<li>이 제품에 디머(Dimmer)가 무슨 필요가 있을까? 삭제</li>\n \t<li>곡면에 디자인을 적용하고 뭔가 배치하는게 쉬운일이 아니었다.</li>\n \t<li>디머가 빠지니까 더 심플해지고 좋아졌다.</li>\n \t<li>컨셉은 잡기 쉬운데 내부 부품의 배치와 지지대, 결합 등을 생각하면 내부 모델링이 쉽지는 않아 보인다.</li>\n</ul>\n<a href=\"/content/images/2017/10/portable-lamp-concept-design.jpg\"><img class=\"alignnone size-full wp-image-5321\" src=\"/content/images/2017/10/portable-lamp-concept-design.jpg\" alt=\"\" width=\"1280\" height=\"720\" /></a>",
                "html": "<h3>포터블 램프 컨셉 디자인</h3>\n<a href=\"http://ilseokoh.com/2017/10/13/lamp-1-sketch/\">아이디어</a>에서 제품까지 가는 과정에서 생각도 바뀌고, 문제도 생기고, 내가 가진 기술과 경험으로 할 수 없는 것 들이 생기게 마련이다.\n<ul>\n \t<li>이 제품에 디머(Dimmer)가 무슨 필요가 있을까? 삭제</li>\n \t<li>곡면에 디자인을 적용하고 뭔가 배치하는게 쉬운일이 아니었다.</li>\n \t<li>디머가 빠지니까 더 심플해지고 좋아졌다.</li>\n \t<li>컨셉은 잡기 쉬운데 내부 부품의 배치와 지지대, 결합 등을 생각하면 내부 모델링이 쉽지는 않아 보인다.</li>\n</ul>\n<a href=\"/content/images/2017/10/portable-lamp-concept-design.jpg\"><img class=\"alignnone size-full wp-image-5321\" src=\"/content/images/2017/10/portable-lamp-concept-design.jpg\" alt=\"\" width=\"1280\" height=\"720\" /></a>",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1508118833000,
                "created_by": 1,
                "updated_at": 1508118833000,
                "updated_by": 1,
                "published_at": 1508118833000,
                "published_by": 1
            },
            {
                "id": 5326,
                "title": "Portable Lamp #3 - 회로 및 부품",
                "slug": "portable-lamp-3-circuit",
                "markdown": "LED를 켜는 단순한 구조의 램프지만 필요한 회로들이 여러가지가 필요하다. 리튬이온 전지를 충전도 해야하고, 전원 스위치도 필요하고, LED를 켜야한다. 여기에 충전을 무선충전 기능을 넣기로 했으므로 USB와 Qi Charging Receiver로 부터 받는 전원 두 가지를 자연스럽게 스위칭 해줘야 한다.\n<ul>\n \t<li>두 개의 전원(Qi Receiver, USB)이 들어왔을 때 USB가 우선순위로 공급되도록 스위칭하는 회로</li>\n \t<li>3.7v 리튬이온 배터리 (3.7v, 2600mAh x 3개) 충전회로</li>\n \t<li>전원 스위치. 기계적인 토글 스위치가 아닌 Soft Latch 전원 스위치</li>\n \t<li>LED 회로</li>\n</ul>\n짧은 시간에 이런 회로들을 설계하고 테스트하기에는 시간이 너무 부족해서 모듈화 되어 있는 제품들을 구매해서 조합하는 방법을 사용하기로 했다. 세 가지 회로를 찾아서 구매 했다.\n<ol>\n \t<li>리튬이온 배터리 충전 회로 :<a href=\"https://www.adafruit.com/product/259\">USB LiIon/LiPoly charger - v1.2</a></li>\n \t<li>Soft Latch 전원 스위치 : <a href=\"https://www.adafruit.com/product/1400\">Adafruit Push-button Power Switch Breakout</a></li>\n \t<li>무선충전 리시버: Universal Qi Wireless Receiver Module</li>\n \t<li>리튬이온 배터리 팩: 3개 병렬 연결</li>\n</ol>\nAfdfuit 라는 사이트는 필요한 회로들을 어떻게 이렇게 꼭 집어서 다 준비해놓았고 관련 동영상, 응용 방법 등 너무 편리하게 되어 있는지 감동적이다. 배송비가 약 2만원이 들었다.\n\n배터리는 세운상가를 돌아다니면서 배터리 전문점에서 3개의 팩을 병렬로 패키징해서 만들었다. 구매하고 보니 LG 배터리였다.  <span class=\"ma-title-text\" title=\"Original LG 18650B4 battery LGABB41865 li ion battery 3.7v 2600mAh LG B4 18650 battery\">LGABB41865 li ion battery 3.7v 2600mAh 3개를 병렬로 묶었으니 3.7v 7400mAh 의 용량을 가진다. </span>\n\n&nbsp;",
                "html": "LED를 켜는 단순한 구조의 램프지만 필요한 회로들이 여러가지가 필요하다. 리튬이온 전지를 충전도 해야하고, 전원 스위치도 필요하고, LED를 켜야한다. 여기에 충전을 무선충전 기능을 넣기로 했으므로 USB와 Qi Charging Receiver로 부터 받는 전원 두 가지를 자연스럽게 스위칭 해줘야 한다.\n<ul>\n \t<li>두 개의 전원(Qi Receiver, USB)이 들어왔을 때 USB가 우선순위로 공급되도록 스위칭하는 회로</li>\n \t<li>3.7v 리튬이온 배터리 (3.7v, 2600mAh x 3개) 충전회로</li>\n \t<li>전원 스위치. 기계적인 토글 스위치가 아닌 Soft Latch 전원 스위치</li>\n \t<li>LED 회로</li>\n</ul>\n짧은 시간에 이런 회로들을 설계하고 테스트하기에는 시간이 너무 부족해서 모듈화 되어 있는 제품들을 구매해서 조합하는 방법을 사용하기로 했다. 세 가지 회로를 찾아서 구매 했다.\n<ol>\n \t<li>리튬이온 배터리 충전 회로 :<a href=\"https://www.adafruit.com/product/259\">USB LiIon/LiPoly charger - v1.2</a></li>\n \t<li>Soft Latch 전원 스위치 : <a href=\"https://www.adafruit.com/product/1400\">Adafruit Push-button Power Switch Breakout</a></li>\n \t<li>무선충전 리시버: Universal Qi Wireless Receiver Module</li>\n \t<li>리튬이온 배터리 팩: 3개 병렬 연결</li>\n</ol>\nAfdfuit 라는 사이트는 필요한 회로들을 어떻게 이렇게 꼭 집어서 다 준비해놓았고 관련 동영상, 응용 방법 등 너무 편리하게 되어 있는지 감동적이다. 배송비가 약 2만원이 들었다.<p>배터리는 세운상가를 돌아다니면서 배터리 전문점에서 3개의 팩을 병렬로 패키징해서 만들었다. 구매하고 보니 LG 배터리였다.  <span class=\"ma-title-text\" title=\"Original LG 18650B4 battery LGABB41865 li ion battery 3.7v 2600mAh LG B4 18650 battery\">LGABB41865 li ion battery 3.7v 2600mAh 3개를 병렬로 묶었으니 3.7v 7400mAh 의 용량을 가진다. </span><p>&nbsp;",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1508676085000,
                "created_by": 1,
                "updated_at": 1508676085000,
                "updated_by": 1,
                "published_at": 1508676085000,
                "published_by": 1
            },
            {
                "id": 5330,
                "title": "Portable Lamp #4 - 회로 테스트",
                "slug": "portable-lamp-4-circuit-test",
                "markdown": "<a href=\"http://ilseokoh.com/2017/10/22/portable-lamp-3-circuit/\">부품을 구입 했으니</a> 회로 테스트가 필요하다. 직접 회로를 그리고 PCB를 만들어야 할 두개의 전원 소스 입력 부분과 LED  부분을 제외하고 나머지 부분을 테스트 해봤다. 대부분 모듈 형태의 검증된 회로를 단순히 서로 연결하는 것이기 때문에 큰 어려움은 없었다. 테스트는 \"전원(USB 또는 Qi Wireless Receiver) - 배터리 충전 회로 - 배터리 - 전원버튼\" 이 회로를 연결하고 배터리가 충전이 되면서 3.7v 전원이 공급되는 걸 보는 것이다. 테스트 환경에 오실로스코프가 없어서 전압을 잴 수 있는 멀티 미터(일명 테스터기)를 사용했고 회로의 연결은 Bread Board(일명 빵판)을 사용했다.\n\n스펙으로 확인하고 머리속에서만 작동하던 회로가 서로 연결되고 작동이 확인되는 순간이다.\n<h3>무선 충전 리시버의 확인</h3>\n무선충전은 대표적으로 갤럭시 시리즈가 가능하기 시작해서 이제는 아이폰 8까지 가능하게 되었다. 사실 무선 충전이라는 말이 어색할 정도로 충전기와 폰이 딱 붙어야 만 충전이 가능하다. 내가 구입한 리시버는 어떤 특성을 가지고 있을까? 이걸 아는 건 중요한데 램프의 가장 밑바닥은 나무고 그 나무를 통과해서 충전이 되기 때문에 테스트가 필요했다. 나무라는 재질을 사이에 두고 어떤 거리에서 전원 공급이 가능할까?\n\n결론은 최대 2.7mm까지 가능하다. 즉, 바닥의 두께를 그 이하로 만들면서 동시에 너무 얇아져서 나무가 깨지는 일이 없도록 조정을 해야한다. 2.5mm로 만들면 되겠다. 테스트는 합판으로 했지만 원목을 사용할 예정이므로 한번 더 테스트가 필요하다.\n\n&nbsp;\n\n<a href=\"/content/images/2017/10/qi-reciever.jpg\"><img class=\"alignnone size-full wp-image-5335\" src=\"/content/images/2017/10/qi-reciever.jpg\" alt=\"\" width=\"3291\" height=\"2231\" /></a>",
                "html": "<a href=\"http://ilseokoh.com/2017/10/22/portable-lamp-3-circuit/\">부품을 구입 했으니</a> 회로 테스트가 필요하다. 직접 회로를 그리고 PCB를 만들어야 할 두개의 전원 소스 입력 부분과 LED  부분을 제외하고 나머지 부분을 테스트 해봤다. 대부분 모듈 형태의 검증된 회로를 단순히 서로 연결하는 것이기 때문에 큰 어려움은 없었다. 테스트는 \"전원(USB 또는 Qi Wireless Receiver) - 배터리 충전 회로 - 배터리 - 전원버튼\" 이 회로를 연결하고 배터리가 충전이 되면서 3.7v 전원이 공급되는 걸 보는 것이다. 테스트 환경에 오실로스코프가 없어서 전압을 잴 수 있는 멀티 미터(일명 테스터기)를 사용했고 회로의 연결은 Bread Board(일명 빵판)을 사용했다.<p>스펙으로 확인하고 머리속에서만 작동하던 회로가 서로 연결되고 작동이 확인되는 순간이다.\n<h3>무선 충전 리시버의 확인</h3>\n무선충전은 대표적으로 갤럭시 시리즈가 가능하기 시작해서 이제는 아이폰 8까지 가능하게 되었다. 사실 무선 충전이라는 말이 어색할 정도로 충전기와 폰이 딱 붙어야 만 충전이 가능하다. 내가 구입한 리시버는 어떤 특성을 가지고 있을까? 이걸 아는 건 중요한데 램프의 가장 밑바닥은 나무고 그 나무를 통과해서 충전이 되기 때문에 테스트가 필요했다. 나무라는 재질을 사이에 두고 어떤 거리에서 전원 공급이 가능할까?<p>결론은 최대 2.7mm까지 가능하다. 즉, 바닥의 두께를 그 이하로 만들면서 동시에 너무 얇아져서 나무가 깨지는 일이 없도록 조정을 해야한다. 2.5mm로 만들면 되겠다. 테스트는 합판으로 했지만 원목을 사용할 예정이므로 한번 더 테스트가 필요하다.<p>&nbsp;<p><a href=\"/content/images/2017/10/qi-reciever.jpg\"><img class=\"alignnone size-full wp-image-5335\" src=\"/content/images/2017/10/qi-reciever.jpg\" alt=\"\" width=\"3291\" height=\"2231\" /></a>",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1508677759000,
                "created_by": 1,
                "updated_at": 1508677759000,
                "updated_by": 1,
                "published_at": 1508677759000,
                "published_by": 1
            },
            {
                "id": 5340,
                "title": "Portable Lamp #5 - LED 테스트",
                "slug": "portable-lamp-5-led-test",
                "markdown": "조명을 만들기 때문에 결국 LED를 켜야한다. 보통 회로에서 상태를 보여주는 용도로 많이 사용해봤지만 요즘 조명에서 사용하는 LED는 조금 달랐다. 스터디가 필요하다. 알고싶은 것들은 이런 것들이다.\n<ul>\n \t<li>사용할 배터리의 용량과 전체 회로에서 사용하는 전류를 측정해서 충전된 상태에서 몇 시간 사용할 수 있을지 계산</li>\n \t<li>3.7v 배터리로 켤 수 있는 LED</li>\n \t<li>LED와 같이 사용할 정확한 저항값 계산</li>\n \t<li>밝은 흰색</li>\n \t<li>밝기</li>\n \t<li>부품의 패키지는 SMD 형태로 조명에서 사용하는 LED 사용</li>\n</ul>\n<h3><strong>LED 관련 이론</strong></h3>\n<h4><strong>순방향 전압(Forward Voltage)</strong></h4>\nLED도 다이오드기 때문에 다이오드의 특성을 그대로 가지고 있다. 순방향 전압은 LED에 순방향으로 전류가 흐를때 강하되는 전압을 말한다. 반대로 최소한 순방향 강하전압 이상의 전압을 가해야만 전류가 흐를 수 있다. 즉, 순방향 전압 이상으로 전압을 걸어줘야 LED가 켜진다. Portable Lamp의 경우 3.7v를 사용할 것이기 때문에 LED를 선택할 때 순방향 전압이 3.7v 이상인 LED를 선택해야 한다.\n<h4><strong>순방향 허용 전류 (Forward Continuous Current)</strong></h4>\n순방향으로 전압을 걸었을 때 허용되는 최대 전류를 말한다.  이 값으로 저항값을 대략 계산할 수 있다.\n<h4><strong>LED 저항값 계산법</strong></h4>\n<blockquote>(입력전압 - LED전압) / LED전류=저항값</blockquote>\n<h4><strong>색온도 (Color temperature)</strong></h4>\n<a href=\"http://ilseokoh.com/content/images/2017/11/color-temp.png\"><img class=\"size-full wp-image-5342 aligncenter\" src=\"http://ilseokoh.com/content/images/2017/11/color-temp.png\" alt=\"\" width=\"700\" height=\"240\" /></a>\n\n<a href=\"https://ko.wikipedia.org/wiki/색온도\">색온도</a>는 색을 절대온도(K, 캘빈)를 사용해서 숫자로 표현한 것이다. 그림에서 보면 색온도에 따른 색을 볼 수 있다. Portable Lamp는 6000K 부근에서 선택을 해서 밝은 흰색이 전등갓에 은은하게 퍼지게 할 생각이다.\n\n실제 LED 스펙을 살펴보면 이제 이해가 좀 되기 시작한다.\n\n<a href=\"/content/images/2017/11/led-spec-sample.jpg\"><img class=\" wp-image-5344 aligncenter\" src=\"/content/images/2017/11/led-spec-sample.jpg\" alt=\"\" width=\"858\" height=\"348\" /></a>\n\n이 LED는 흰색을 표현하고 3.05v 만 걸어주면 켤 수 있다. 대략 60mA의 전류가 흐른다. 나는 3.7v를 사용할 것이다. (전원 - LED전원) / LED전류 = (3.7-3.05)/0.06=10.8333 10옴 정도의 저항을 사용하면 적당한 밝기로 켜진다.\n<h4>조명용 LED 사이즈</h4>\n조명 LED는 아래와 같은 종류가 있다. 숫자는 크기를 의미한다.\n\n<a href=\"/content/images/2017/11/led-size.jpg\"><img class=\"size-full wp-image-5345 aligncenter\" src=\"/content/images/2017/11/led-size.jpg\" alt=\"\" width=\"776\" height=\"279\" /></a>\n\nLED는 여러가지 모양이 있지만 요즘 조명에서 사용하는 LED를 보면 기반이나 줄에 납짝 붙어있고 밝은 빛을 낸다. 아무래도 조명용 LED를 사용하는 게 좋을 것 같아서 살펴봤더니 여러가지 모양과 패키지가 있다. 더불어서 방열판도 있고 렌즈가 붙어 있는 것도 있고 스트립 타입으로 잘라서 쓰는 것도 있고 구동 드라이버까지 LED 조명의 세계도 깊었다. 대걔 12V 어댑터를 사용해서 LED 스트립을 잘라서 이어 붙여서 쉽게 사용할 수 있도록 잘 모듈화 되어 있다.\n\n<a href=\"/content/images/2017/11/plcc6-5050-smd-led-schematics-dimensions-plcc-6_6.jpg\"><img class=\" wp-image-5346 aligncenter\" src=\"/content/images/2017/11/plcc6-5050-smd-led-schematics-dimensions-plcc-6_6.jpg\" alt=\"\" width=\"583\" height=\"583\" /></a>\n\nPortable Lamp의 경우 12V도 없고 잘 만들어진 스트립을 사용할 공간도 없어서 LED 만 사용하기로 했다. 세운상가 LED 가게에서 5050 LED 20개를 샘플로 구매해서 켜봤다. 다리가 총 6개고 구조는 3개의 LED가 별도로 들어있는 것 처럼 표현되어 있는데 다리 3개를 붙여서 하나의 LED 처럼 연결하니까 켜진다. 밝은 희색 빛이 표현되었다. 이걸 이제 PCB에 올려야 한다.\n\n<a href=\"/content/images/2017/11/IMG-0426.jpg\"><img class=\"aligncenter wp-image-5349\" src=\"/content/images/2017/11/IMG-0426.jpg\" alt=\"\" width=\"616\" height=\"533\" /></a>",
                "html": "조명을 만들기 때문에 결국 LED를 켜야한다. 보통 회로에서 상태를 보여주는 용도로 많이 사용해봤지만 요즘 조명에서 사용하는 LED는 조금 달랐다. 스터디가 필요하다. 알고싶은 것들은 이런 것들이다.\n<ul>\n \t<li>사용할 배터리의 용량과 전체 회로에서 사용하는 전류를 측정해서 충전된 상태에서 몇 시간 사용할 수 있을지 계산</li>\n \t<li>3.7v 배터리로 켤 수 있는 LED</li>\n \t<li>LED와 같이 사용할 정확한 저항값 계산</li>\n \t<li>밝은 흰색</li>\n \t<li>밝기</li>\n \t<li>부품의 패키지는 SMD 형태로 조명에서 사용하는 LED 사용</li>\n</ul>\n<h3><strong>LED 관련 이론</strong></h3>\n<h4><strong>순방향 전압(Forward Voltage)</strong></h4>\nLED도 다이오드기 때문에 다이오드의 특성을 그대로 가지고 있다. 순방향 전압은 LED에 순방향으로 전류가 흐를때 강하되는 전압을 말한다. 반대로 최소한 순방향 강하전압 이상의 전압을 가해야만 전류가 흐를 수 있다. 즉, 순방향 전압 이상으로 전압을 걸어줘야 LED가 켜진다. Portable Lamp의 경우 3.7v를 사용할 것이기 때문에 LED를 선택할 때 순방향 전압이 3.7v 이상인 LED를 선택해야 한다.\n<h4><strong>순방향 허용 전류 (Forward Continuous Current)</strong></h4>\n순방향으로 전압을 걸었을 때 허용되는 최대 전류를 말한다.  이 값으로 저항값을 대략 계산할 수 있다.\n<h4><strong>LED 저항값 계산법</strong></h4>\n<blockquote>(입력전압 - LED전압) / LED전류=저항값</blockquote>\n<h4><strong>색온도 (Color temperature)</strong></h4>\n<a href=\"http://ilseokoh.com/content/images/2017/11/color-temp.png\"><img class=\"size-full wp-image-5342 aligncenter\" src=\"http://ilseokoh.com/content/images/2017/11/color-temp.png\" alt=\"\" width=\"700\" height=\"240\" /></a><p><a href=\"https://ko.wikipedia.org/wiki/색온도\">색온도</a>는 색을 절대온도(K, 캘빈)를 사용해서 숫자로 표현한 것이다. 그림에서 보면 색온도에 따른 색을 볼 수 있다. Portable Lamp는 6000K 부근에서 선택을 해서 밝은 흰색이 전등갓에 은은하게 퍼지게 할 생각이다.<p>실제 LED 스펙을 살펴보면 이제 이해가 좀 되기 시작한다.<p><a href=\"/content/images/2017/11/led-spec-sample.jpg\"><img class=\" wp-image-5344 aligncenter\" src=\"/content/images/2017/11/led-spec-sample.jpg\" alt=\"\" width=\"858\" height=\"348\" /></a><p>이 LED는 흰색을 표현하고 3.05v 만 걸어주면 켤 수 있다. 대략 60mA의 전류가 흐른다. 나는 3.7v를 사용할 것이다. (전원 - LED전원) / LED전류 = (3.7-3.05)/0.06=10.8333 10옴 정도의 저항을 사용하면 적당한 밝기로 켜진다.\n<h4>조명용 LED 사이즈</h4>\n조명 LED는 아래와 같은 종류가 있다. 숫자는 크기를 의미한다.<p><a href=\"/content/images/2017/11/led-size.jpg\"><img class=\"size-full wp-image-5345 aligncenter\" src=\"/content/images/2017/11/led-size.jpg\" alt=\"\" width=\"776\" height=\"279\" /></a><p>LED는 여러가지 모양이 있지만 요즘 조명에서 사용하는 LED를 보면 기반이나 줄에 납짝 붙어있고 밝은 빛을 낸다. 아무래도 조명용 LED를 사용하는 게 좋을 것 같아서 살펴봤더니 여러가지 모양과 패키지가 있다. 더불어서 방열판도 있고 렌즈가 붙어 있는 것도 있고 스트립 타입으로 잘라서 쓰는 것도 있고 구동 드라이버까지 LED 조명의 세계도 깊었다. 대걔 12V 어댑터를 사용해서 LED 스트립을 잘라서 이어 붙여서 쉽게 사용할 수 있도록 잘 모듈화 되어 있다.<p><a href=\"/content/images/2017/11/plcc6-5050-smd-led-schematics-dimensions-plcc-6_6.jpg\"><img class=\" wp-image-5346 aligncenter\" src=\"/content/images/2017/11/plcc6-5050-smd-led-schematics-dimensions-plcc-6_6.jpg\" alt=\"\" width=\"583\" height=\"583\" /></a><p>Portable Lamp의 경우 12V도 없고 잘 만들어진 스트립을 사용할 공간도 없어서 LED 만 사용하기로 했다. 세운상가 LED 가게에서 5050 LED 20개를 샘플로 구매해서 켜봤다. 다리가 총 6개고 구조는 3개의 LED가 별도로 들어있는 것 처럼 표현되어 있는데 다리 3개를 붙여서 하나의 LED 처럼 연결하니까 켜진다. 밝은 희색 빛이 표현되었다. 이걸 이제 PCB에 올려야 한다.<p><a href=\"/content/images/2017/11/IMG-0426.jpg\"><img class=\"aligncenter wp-image-5349\" src=\"/content/images/2017/11/IMG-0426.jpg\" alt=\"\" width=\"616\" height=\"533\" /></a>",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1510108109000,
                "created_by": 1,
                "updated_at": 1510108109000,
                "updated_by": 1,
                "published_at": 1510108109000,
                "published_by": 1
            },
            {
                "id": 5339,
                "title": "Portable Lamp #8 - 3D 모델 상세 설계",
                "slug": "portable-lamp-detail-modeling",
                "markdown": "Fusion 360으로 모델링을 해서 렌더링까지 해보고 자를 들고 대략의 크기나 느낌을 머리속에서 생각하다 보니 어떤 느낌인지 도저히 감을 잡을 수 없다. 100mm 지름에 50mm높이의 원통은 실제 어떤 느낌일까? 우선 종이로 만들어봤다. 덩치가 좀 커보이긴 했지만 나쁘지 않았다.\n\n<a href=\"/content/images/2017/11/IMG_0465.jpg\"><img class=\"size-large wp-image-5370 aligncenter\" src=\"/content/images/2017/11/IMG_0465-1024x778.jpg\" alt=\"\" width=\"640\" height=\"486\" /></a>\n\n이제 컨셉 디자인에서 벗어나서 상세 제품 디자인을 해야겠다. 실제 일하시는 분들은 어떤 용어를 쓰는지 모르겠지만 내부에 부품들도 들어가야 하고 조립도 되어야 하니 상세한 크기를 정해서 내부 디자인과 외부 디자인을 모두 해야 제품이 나올 것 같다. 아무리 프로토타입이지만 그럴듯한 제품의 형태를 띄고 싶다. 대충 모양을 만드는 것과 제품 설계는 차원이 다른 일이었다. 치수 하나하나 적당한 간격을 줘야하고 내부 부품들의 위치와 크기를 총체적으로 고려해야 했다. 특히 제일 어려운 부분이 버튼 부분이었다. Fusion 360을 다시 펼쳤다.\n<h4>전체 구성</h4>\n손잡이와 전자 부품을 제외한 나머지 부분은 총 4 부품으로 구성된다. 가장 아래는 나무로 CNC 가공을 통해서 만들 예정이고 나머지는 3D 프린터로 구성할 예정이다.\n\n<a href=\"/content/images/2017/11/config.jpg\"><img class=\"size-large wp-image-5376 aligncenter\" src=\"/content/images/2017/11/config-1024x698.jpg\" alt=\"\" width=\"640\" height=\"436\" /></a>\n\n&nbsp;\n<h4>전등갓과 서포터의 연결</h4>\n윗부분과 아랫부분을 연결하는 방법이 필요하다. 서포터라는 부품에 전등갓을 끼우는 형식으로 설계하고 서포터에는 전자 부품들이 들어가도록 했다. 서포터와 나무는 작은 피스로 고정하는 방법이 적당할 것 같다.\n\n<a href=\"/content/images/2017/11/suporter-lampshape.jpg\"><img class=\"size-large wp-image-5373 aligncenter\" src=\"/content/images/2017/11/suporter-lampshape-1024x698.jpg\" alt=\"\" width=\"640\" height=\"436\" /></a>\n<h4>베이스와 서포터의 결합</h4>\n나무로 만들 베이스에 플라스틱 서포터가 쏙 들어가야 한다. 여유간격을 0.5mm로 잡았다.\n\n<a href=\"/content/images/2017/11/base-supporter.jpg\"><img class=\"size-large wp-image-5374 aligncenter\" src=\"/content/images/2017/11/base-supporter-1024x698.jpg\" alt=\"\" width=\"640\" height=\"436\" /></a>\n<h4>버튼</h4>\n버튼은 별도 부품을 빼고 푸시버튼 부품에 끼울 수 있도록 설계했다. 버튼 부품은 서포터와 베이스를 관통해서 약 1mm만 튀어나오도록 했고 0.5mm 간격을 줬다.\n\n<a href=\"/content/images/2017/11/button.jpg\"><img class=\"size-large wp-image-5375 aligncenter\" src=\"/content/images/2017/11/button-1024x698.jpg\" alt=\"\" width=\"640\" height=\"436\" /></a>\n<h4>Parameterized Design</h4>\n설계할 때 변수를 써서 치수를 만드는게 좋다고 배웠다. 한번에 디자인을 성공할 수는 없기 때문에 수정할 때 사용할 수 있도록 변수를 써서 디자인했다. 실제 적용해보니 시간도 많이 걸리고 생각도 많이 해야한다. 변수의 치수 하나를 변경하면 전체가 문제없이 수정되면 좋겠는데 그게 쉬운일은 아닌것 같다.\n\n<a href=\"/content/images/2017/11/parameterized.jpg\"><img class=\"size-large wp-image-5378 aligncenter\" src=\"/content/images/2017/11/parameterized-1024x715.jpg\" alt=\"\" width=\"640\" height=\"447\" /></a>",
                "html": "Fusion 360으로 모델링을 해서 렌더링까지 해보고 자를 들고 대략의 크기나 느낌을 머리속에서 생각하다 보니 어떤 느낌인지 도저히 감을 잡을 수 없다. 100mm 지름에 50mm높이의 원통은 실제 어떤 느낌일까? 우선 종이로 만들어봤다. 덩치가 좀 커보이긴 했지만 나쁘지 않았다.<p><a href=\"/content/images/2017/11/IMG_0465.jpg\"><img class=\"size-large wp-image-5370 aligncenter\" src=\"/content/images/2017/11/IMG_0465-1024x778.jpg\" alt=\"\" width=\"640\" height=\"486\" /></a><p>이제 컨셉 디자인에서 벗어나서 상세 제품 디자인을 해야겠다. 실제 일하시는 분들은 어떤 용어를 쓰는지 모르겠지만 내부에 부품들도 들어가야 하고 조립도 되어야 하니 상세한 크기를 정해서 내부 디자인과 외부 디자인을 모두 해야 제품이 나올 것 같다. 아무리 프로토타입이지만 그럴듯한 제품의 형태를 띄고 싶다. 대충 모양을 만드는 것과 제품 설계는 차원이 다른 일이었다. 치수 하나하나 적당한 간격을 줘야하고 내부 부품들의 위치와 크기를 총체적으로 고려해야 했다. 특히 제일 어려운 부분이 버튼 부분이었다. Fusion 360을 다시 펼쳤다.\n<h4>전체 구성</h4>\n손잡이와 전자 부품을 제외한 나머지 부분은 총 4 부품으로 구성된다. 가장 아래는 나무로 CNC 가공을 통해서 만들 예정이고 나머지는 3D 프린터로 구성할 예정이다.<p><a href=\"/content/images/2017/11/config.jpg\"><img class=\"size-large wp-image-5376 aligncenter\" src=\"/content/images/2017/11/config-1024x698.jpg\" alt=\"\" width=\"640\" height=\"436\" /></a><p>&nbsp;\n<h4>전등갓과 서포터의 연결</h4>\n윗부분과 아랫부분을 연결하는 방법이 필요하다. 서포터라는 부품에 전등갓을 끼우는 형식으로 설계하고 서포터에는 전자 부품들이 들어가도록 했다. 서포터와 나무는 작은 피스로 고정하는 방법이 적당할 것 같다.<p><a href=\"/content/images/2017/11/suporter-lampshape.jpg\"><img class=\"size-large wp-image-5373 aligncenter\" src=\"/content/images/2017/11/suporter-lampshape-1024x698.jpg\" alt=\"\" width=\"640\" height=\"436\" /></a>\n<h4>베이스와 서포터의 결합</h4>\n나무로 만들 베이스에 플라스틱 서포터가 쏙 들어가야 한다. 여유간격을 0.5mm로 잡았다.<p><a href=\"/content/images/2017/11/base-supporter.jpg\"><img class=\"size-large wp-image-5374 aligncenter\" src=\"/content/images/2017/11/base-supporter-1024x698.jpg\" alt=\"\" width=\"640\" height=\"436\" /></a>\n<h4>버튼</h4>\n버튼은 별도 부품을 빼고 푸시버튼 부품에 끼울 수 있도록 설계했다. 버튼 부품은 서포터와 베이스를 관통해서 약 1mm만 튀어나오도록 했고 0.5mm 간격을 줬다.<p><a href=\"/content/images/2017/11/button.jpg\"><img class=\"size-large wp-image-5375 aligncenter\" src=\"/content/images/2017/11/button-1024x698.jpg\" alt=\"\" width=\"640\" height=\"436\" /></a>\n<h4>Parameterized Design</h4>\n설계할 때 변수를 써서 치수를 만드는게 좋다고 배웠다. 한번에 디자인을 성공할 수는 없기 때문에 수정할 때 사용할 수 있도록 변수를 써서 디자인했다. 실제 적용해보니 시간도 많이 걸리고 생각도 많이 해야한다. 변수의 치수 하나를 변경하면 전체가 문제없이 수정되면 좋겠는데 그게 쉬운일은 아닌것 같다.<p><a href=\"/content/images/2017/11/parameterized.jpg\"><img class=\"size-large wp-image-5378 aligncenter\" src=\"/content/images/2017/11/parameterized-1024x715.jpg\" alt=\"\" width=\"640\" height=\"447\" /></a>",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1510483849000,
                "created_by": 1,
                "updated_at": 1510483849000,
                "updated_by": 1,
                "published_at": 1510483849000,
                "published_by": 1
            },
            {
                "id": 5352,
                "title": "Portable Lamp #6 - 외부전원 공급 회로",
                "slug": "portable-lamp-6-external-power-supply-circuit",
                "markdown": "Portable Lamp는 외부전원 2가지를 이용해서 충전을 하는 기능이 있다. Micro USB 포트(안드로이드 휴대폰 충전 단자)로 5V 입력을 받거나 <a href=\"http://shopping.naver.com/search/all.nhn?query=%EB%AC%B4%EC%84%A0%EC%B6%A9%EC%A0%84%EA%B8%B0&amp;cat_id=&amp;frm=NVSHATC\">무선충전기(Qi Charger)</a>를 통해서 5V를 입력 받아서 배터리를 충전하는 회로로 연결된다. 소스가 2개이기 때문에 스위칭을 해줘야 한다. 2개의 소스에서 동시에 전원이 공급될수도 있고 한쪽에서만 들어오기도 한다. 이런 경우가 많은지 'ORing' 이라는 용어가 있다.\n<blockquote>ORing 이란 두 개 이상의 전원을 이용해서 가용성을 높일 때 두 개 이상의 전원을 연결하는 방법</blockquote>\n검색을 해보니 다이오드를 이용하는 단순한 방법이 있기는 한데 전압 강하가 있거나 스위칭의 특성이 좋지 않은 것 같다. 좀 더 비싸고 좋은 방법을 찾다보니 <a href=\"http://cds.linear.com/docs/en/datasheet/4412fb.pdf\">LTC4412라는 \"Low loss PowerPath controller in ThinSOT\" </a>칩을 찾았다. <a href=\"http://cds.linear.com/docs/en/datasheet/4412fb.pdf\">데이터시트</a>를 보면 샘플 회로가 나와 있다. 기본 회로에는 쇼트키 다이오드와 P-Channel MOSFET이 필요하다. 데이터시트를 정독하면 아래 회로는 이렇게 해석된다.  LTC4412는 ideal diode이고 P-ch MOSFET을 제어한다. 6번핀 SENSE에 외부전원을 연결해 놓고 외부전원이 들어오면 5번핀 GATE가 pull-up 된다. 그러면 MOSFET의 gate에 0v 이상이 걸려서 MOSFET이 OFF 된다(S --&gt; D가 끊어진다) 따라서 배터리 전원이 차단된다.\n\n<a href=\"/content/images/2017/11/LTC4412-basic-circuit.jpg\"><img class=\"size-full wp-image-5355 aligncenter\" src=\"/content/images/2017/11/LTC4412-basic-circuit.jpg\" alt=\"\" width=\"639\" height=\"384\" /></a>\n\n이 기본회로 2개를 겹쳐써야겠다. 왜냐면 첫번째 LTC4412는 USB 5v와 무선충전기 5v 사이를 선택해주고 두번째는 배터리와 첫번째 선택된 소스 사이를 선택해준다. 이렇게 하면\n<ul>\n \t<li>외부전원 공급이 없을 때 배터리가 전원을 공급해준다.</li>\n \t<li>USB와 무선충전기가 동시에 공급되면 USB 우선으로 공급해준다.</li>\n \t<li>USB와 무선충전기 둘중 하나만 공급되면 그 전원이 공급된다.</li>\n \t<li>배터리 충전은 첫번째 LTC4412 회로의 출력에 물려주면 USB 또는 무선충전기로 충전이 된다.</li>\n</ul>\n<a href=\"/content/images/2017/11/LTC4412-double.jpg\"><img class=\"size-full wp-image-5356 aligncenter\" src=\"/content/images/2017/11/LTC4412-double.jpg\" alt=\"\" width=\"637\" height=\"547\" /></a>\n<h4>Autodesk Eagle로 그린 전원 공급 회로도</h4>\n<a href=\"/content/images/2017/11/LTC4412-circuit.jpg\"><img class=\"size-full wp-image-5357 aligncenter\" src=\"/content/images/2017/11/LTC4412-circuit.jpg\" alt=\"\" width=\"1383\" height=\"795\" /></a>\n\n&nbsp;",
                "html": "Portable Lamp는 외부전원 2가지를 이용해서 충전을 하는 기능이 있다. Micro USB 포트(안드로이드 휴대폰 충전 단자)로 5V 입력을 받거나 <a href=\"http://shopping.naver.com/search/all.nhn?query=%EB%AC%B4%EC%84%A0%EC%B6%A9%EC%A0%84%EA%B8%B0&amp;cat_id=&amp;frm=NVSHATC\">무선충전기(Qi Charger)</a>를 통해서 5V를 입력 받아서 배터리를 충전하는 회로로 연결된다. 소스가 2개이기 때문에 스위칭을 해줘야 한다. 2개의 소스에서 동시에 전원이 공급될수도 있고 한쪽에서만 들어오기도 한다. 이런 경우가 많은지 'ORing' 이라는 용어가 있다.\n<blockquote>ORing 이란 두 개 이상의 전원을 이용해서 가용성을 높일 때 두 개 이상의 전원을 연결하는 방법</blockquote>\n검색을 해보니 다이오드를 이용하는 단순한 방법이 있기는 한데 전압 강하가 있거나 스위칭의 특성이 좋지 않은 것 같다. 좀 더 비싸고 좋은 방법을 찾다보니 <a href=\"http://cds.linear.com/docs/en/datasheet/4412fb.pdf\">LTC4412라는 \"Low loss PowerPath controller in ThinSOT\" </a>칩을 찾았다. <a href=\"http://cds.linear.com/docs/en/datasheet/4412fb.pdf\">데이터시트</a>를 보면 샘플 회로가 나와 있다. 기본 회로에는 쇼트키 다이오드와 P-Channel MOSFET이 필요하다. 데이터시트를 정독하면 아래 회로는 이렇게 해석된다.  LTC4412는 ideal diode이고 P-ch MOSFET을 제어한다. 6번핀 SENSE에 외부전원을 연결해 놓고 외부전원이 들어오면 5번핀 GATE가 pull-up 된다. 그러면 MOSFET의 gate에 0v 이상이 걸려서 MOSFET이 OFF 된다(S --&gt; D가 끊어진다) 따라서 배터리 전원이 차단된다.<p><a href=\"/content/images/2017/11/LTC4412-basic-circuit.jpg\"><img class=\"size-full wp-image-5355 aligncenter\" src=\"/content/images/2017/11/LTC4412-basic-circuit.jpg\" alt=\"\" width=\"639\" height=\"384\" /></a><p>이 기본회로 2개를 겹쳐써야겠다. 왜냐면 첫번째 LTC4412는 USB 5v와 무선충전기 5v 사이를 선택해주고 두번째는 배터리와 첫번째 선택된 소스 사이를 선택해준다. 이렇게 하면\n<ul>\n \t<li>외부전원 공급이 없을 때 배터리가 전원을 공급해준다.</li>\n \t<li>USB와 무선충전기가 동시에 공급되면 USB 우선으로 공급해준다.</li>\n \t<li>USB와 무선충전기 둘중 하나만 공급되면 그 전원이 공급된다.</li>\n \t<li>배터리 충전은 첫번째 LTC4412 회로의 출력에 물려주면 USB 또는 무선충전기로 충전이 된다.</li>\n</ul>\n<a href=\"/content/images/2017/11/LTC4412-double.jpg\"><img class=\"size-full wp-image-5356 aligncenter\" src=\"/content/images/2017/11/LTC4412-double.jpg\" alt=\"\" width=\"637\" height=\"547\" /></a>\n<h4>Autodesk Eagle로 그린 전원 공급 회로도</h4>\n<a href=\"/content/images/2017/11/LTC4412-circuit.jpg\"><img class=\"size-full wp-image-5357 aligncenter\" src=\"/content/images/2017/11/LTC4412-circuit.jpg\" alt=\"\" width=\"1383\" height=\"795\" /></a><p>&nbsp;",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1510368013000,
                "created_by": 1,
                "updated_at": 1510368013000,
                "updated_by": 1,
                "published_at": 1510368013000,
                "published_by": 1
            },
            {
                "id": 5363,
                "title": "Portable Lamp #7 - 전체 회로 테스트",
                "slug": "portable-lamp-7-entire-circuit-test",
                "markdown": "<a href=\"http://ilseokoh.com/2017/11/11/portable-lamp-6-external-power-supply-circuit/\">외부전원 공급회로</a>에서 설계한 회로를 포함하여 <a href=\"http://ilseokoh.com/2017/11/08/portable-lamp-5-led-test/\">LED</a>, <a href=\"http://ilseokoh.com/2017/10/22/portable-lamp-4-circuit-test/\">전원 버튼 모듈, 충전회로 모듈</a>, 리튬이온 배터리를 모두 포함하여 전체 회로를 Bread Board를 이용하여 테스트 했다. 결과는 잘 작동했지만 한가지 예상하지 못한 문제도 찾아냈다. 이제 테스트 완료한 이 회로와 LED회로까지 포함하여 PCB 디자인을 해야한다.\n\n<a href=\"/content/images/2017/11/test-result.jpg\"><img class=\"size-full wp-image-5367 aligncenter\" src=\"/content/images/2017/11/test-result.jpg\" alt=\"\" width=\"852\" height=\"540\" /></a>\n<ul>\n \t<li>USB 대신 Power Supply를 사용하여 외부 전원 1번 입력</li>\n \t<li>무선충전기를 이용한 외부전원 2번</li>\n \t<li>LTC4412회로 2개를 이용한 전원 선택 회로</li>\n \t<li>배터리 충전기와 배터리</li>\n \t<li>Soft Latch 전원버튼</li>\n \t<li>조명용 LED</li>\n</ul>\n<h4>테스트 동영상</h4>\n&nbsp;\n\n[embed]https://youtu.be/pyJUUfS4rro[/embed]\n<h4>부품의 구입 - Digikey 칭찬</h4>\n국내 전자부품 사이트에서 부품들이 검색이 되지만 재고가 없고 리드타임이 길다. 결국 해외 배송이라는 얘기다. <a href=\"https://www.digikey.kr/\">Digikey</a>라는 사이트를 찾았다. 한국어 사이트도 있고 리드테크라는 업체가 한국 사이트를 관리하는 것 같다. 찾는 부품은 거의 다 있고 각 부품은 1개 살 때 가격과 대량 구입 가격이 명시되어 있다. 부품 수가 ㅠ엄청날 텐데 검색이 되고 관리가 되는 걸 보면 대단한 시스템을 가지고 있는게 분명하다. 검색해서 들어가면 데이터시트와 함께 충분한 데이터를 제공한다. 6만원 이상이면 배송비가 없다. 이하면 2만원이 붙는다. 배송은 3일만에 왔다. 심지어는 주소를 틀리게 썼는데 전화가 와서 정정해줬다. 포장은 예술이다. 부품의 특성을 충분히 반영한게 틀림 없다. 칩 LED는 재습제와 습도 측정카드와 함께 밀봉되어 있었다. 감동이다.\n\n세운상가가면 많은 업체들이 있고 각자 취급하는 물품들이 다르다. 발품을 팔아도 원하는 부품을 찾기는 애초에 불가능하다. 혹시나 찾아도 \"10개만 주세요\"하기가 죄송하기도 하다. 이 수많은 가게중에 분명히 부품이 있을텐데 ... 한국의 부품 사이트들도 잘 되어 있지만 잘 팔리는 부품위주로 구성되어 있다. 아쉽다.\n\n&nbsp;",
                "html": "<a href=\"http://ilseokoh.com/2017/11/11/portable-lamp-6-external-power-supply-circuit/\">외부전원 공급회로</a>에서 설계한 회로를 포함하여 <a href=\"http://ilseokoh.com/2017/11/08/portable-lamp-5-led-test/\">LED</a>, <a href=\"http://ilseokoh.com/2017/10/22/portable-lamp-4-circuit-test/\">전원 버튼 모듈, 충전회로 모듈</a>, 리튬이온 배터리를 모두 포함하여 전체 회로를 Bread Board를 이용하여 테스트 했다. 결과는 잘 작동했지만 한가지 예상하지 못한 문제도 찾아냈다. 이제 테스트 완료한 이 회로와 LED회로까지 포함하여 PCB 디자인을 해야한다.<p><a href=\"/content/images/2017/11/test-result.jpg\"><img class=\"size-full wp-image-5367 aligncenter\" src=\"/content/images/2017/11/test-result.jpg\" alt=\"\" width=\"852\" height=\"540\" /></a>\n<ul>\n \t<li>USB 대신 Power Supply를 사용하여 외부 전원 1번 입력</li>\n \t<li>무선충전기를 이용한 외부전원 2번</li>\n \t<li>LTC4412회로 2개를 이용한 전원 선택 회로</li>\n \t<li>배터리 충전기와 배터리</li>\n \t<li>Soft Latch 전원버튼</li>\n \t<li>조명용 LED</li>\n</ul>\n<h4>테스트 동영상</h4>\n&nbsp;<p>[embed]https://youtu.be/pyJUUfS4rro[/embed]\n<h4>부품의 구입 - Digikey 칭찬</h4>\n국내 전자부품 사이트에서 부품들이 검색이 되지만 재고가 없고 리드타임이 길다. 결국 해외 배송이라는 얘기다. <a href=\"https://www.digikey.kr/\">Digikey</a>라는 사이트를 찾았다. 한국어 사이트도 있고 리드테크라는 업체가 한국 사이트를 관리하는 것 같다. 찾는 부품은 거의 다 있고 각 부품은 1개 살 때 가격과 대량 구입 가격이 명시되어 있다. 부품 수가 ㅠ엄청날 텐데 검색이 되고 관리가 되는 걸 보면 대단한 시스템을 가지고 있는게 분명하다. 검색해서 들어가면 데이터시트와 함께 충분한 데이터를 제공한다. 6만원 이상이면 배송비가 없다. 이하면 2만원이 붙는다. 배송은 3일만에 왔다. 심지어는 주소를 틀리게 썼는데 전화가 와서 정정해줬다. 포장은 예술이다. 부품의 특성을 충분히 반영한게 틀림 없다. 칩 LED는 재습제와 습도 측정카드와 함께 밀봉되어 있었다. 감동이다.<p>세운상가가면 많은 업체들이 있고 각자 취급하는 물품들이 다르다. 발품을 팔아도 원하는 부품을 찾기는 애초에 불가능하다. 혹시나 찾아도 \"10개만 주세요\"하기가 죄송하기도 하다. 이 수많은 가게중에 분명히 부품이 있을텐데 ... 한국의 부품 사이트들도 잘 되어 있지만 잘 팔리는 부품위주로 구성되어 있다. 아쉽다.<p>&nbsp;",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1510469161000,
                "created_by": 1,
                "updated_at": 1510469161000,
                "updated_by": 1,
                "published_at": 1510469161000,
                "published_by": 1
            },
            {
                "id": 5380,
                "title": "Portable Lamp #9 - 3D 프린팅",
                "slug": "portable-lamp-9-3d-printing",
                "markdown": "모델을 완성했으니 3D 프린터로 출력을 해보자. 이번 출력으로 실물을 보고 조립을 해보고 다시 수정을 해야한다. 경험이 없기 때문에 몇 번을 더 해야 좋은 설계가 나오지 않을까 생각한다. Fusion 360에서 4개의 STL파일을 가져왔고 Cura에 넣었다. 프린터는 팹랩 서울에 있는 Creative 3D를 활용하기로 했다. 아래 그림처럼 출력의 상세 설정을 했다.\n\n슬라이싱 프로그램인 Cura에서 서포터도 만들어줬는데 생각보다 많은 양의 서포터가 만들어졌다. 아래 그림에서 하늘색이 서포터인데 서포터가 많다 보니 출력시간이 길어졌다.\n\n<a href=\"/content/images/2017/11/cura.jpg\"><img class=\"size-large wp-image-5382 aligncenter\" src=\"/content/images/2017/11/cura-1024x552.jpg\" alt=\"\" width=\"640\" height=\"345\" /></a>\n<p style=\"text-align: center;\">(크게보기 클릭)</p>\n&nbsp;\n<h4>출력시작</h4>\n엄청난 출력 시간이 걸렸다. 24시간이 훌쩍 넘은 것 같다. 한번 출력에 신중한 모델링이 필요하다.\n\n<a href=\"/content/images/2017/11/printing.jpg\"><img class=\"alignnone size-full wp-image-5384\" src=\"/content/images/2017/11/printing.jpg\" alt=\"\" width=\"1280\" height=\"720\" /></a>\n<h4>출력 결과 - 서포터를 제거하고 완료된 출력물</h4>\n<img class=\"size-large wp-image-5387 aligncenter\" src=\"/content/images/2017/11/IMG_0412-e1510485328182-1024x768.jpg\" alt=\"\" width=\"640\" height=\"480\" />\n<h4>조립</h4>\n다행히 조립은 되었다.\n\n<img class=\"size-large wp-image-5389 aligncenter\" src=\"/content/images/2017/11/combine-977x1024.jpg\" alt=\"\" width=\"640\" height=\"671\" />\n<h4>수정이 필요한 부분</h4>\n<ol>\n \t<li>\n<h5>조립했을때 여유간격이 부족해서 살짝 휘어있다.</h5>\n</li>\n</ol>\n<img class=\"size-large wp-image-5390 aligncenter\" src=\"/content/images/2017/11/defect1-1024x766.jpg\" alt=\"\" width=\"640\" height=\"479\" />\n<h5>2. 실제 버튼 부품과 결합하면 조립되지 않는다.</h5>\n<img class=\"size-large wp-image-5391 aligncenter\" src=\"/content/images/2017/11/defect2-1024x761.png\" alt=\"\" width=\"640\" height=\"476\" />\n<h5>3. 배터리 부품을 넣으면 전선이 접히면서 결합이 되지 않는다.</h5>\n<img class=\"size-large wp-image-5392 aligncenter\" src=\"/content/images/2017/11/defect3-1024x850.jpg\" alt=\"\" width=\"640\" height=\"531\" />\n<h5>4. 버튼 부품의 간격이 작아서 뻑뻑하다.</h5>\n<img class=\"size-large wp-image-5393 aligncenter\" src=\"/content/images/2017/11/defect4-1024x677.png\" alt=\"\" width=\"640\" height=\"423\" />\n<h5>5. 벽이 너무 두꺼워서 빛이 너무 적게 투과한다.</h5>\n<img class=\"size-large wp-image-5394 aligncenter\" src=\"/content/images/2017/11/defect5-880x1024.jpg\" alt=\"\" width=\"640\" height=\"745\" />",
                "html": "모델을 완성했으니 3D 프린터로 출력을 해보자. 이번 출력으로 실물을 보고 조립을 해보고 다시 수정을 해야한다. 경험이 없기 때문에 몇 번을 더 해야 좋은 설계가 나오지 않을까 생각한다. Fusion 360에서 4개의 STL파일을 가져왔고 Cura에 넣었다. 프린터는 팹랩 서울에 있는 Creative 3D를 활용하기로 했다. 아래 그림처럼 출력의 상세 설정을 했다.<p>슬라이싱 프로그램인 Cura에서 서포터도 만들어줬는데 생각보다 많은 양의 서포터가 만들어졌다. 아래 그림에서 하늘색이 서포터인데 서포터가 많다 보니 출력시간이 길어졌다.<p><a href=\"/content/images/2017/11/cura.jpg\"><img class=\"size-large wp-image-5382 aligncenter\" src=\"/content/images/2017/11/cura-1024x552.jpg\" alt=\"\" width=\"640\" height=\"345\" /></a>\n<p style=\"text-align: center;\">(크게보기 클릭)</p>\n&nbsp;\n<h4>출력시작</h4>\n엄청난 출력 시간이 걸렸다. 24시간이 훌쩍 넘은 것 같다. 한번 출력에 신중한 모델링이 필요하다.<p><a href=\"/content/images/2017/11/printing.jpg\"><img class=\"alignnone size-full wp-image-5384\" src=\"/content/images/2017/11/printing.jpg\" alt=\"\" width=\"1280\" height=\"720\" /></a>\n<h4>출력 결과 - 서포터를 제거하고 완료된 출력물</h4>\n<img class=\"size-large wp-image-5387 aligncenter\" src=\"/content/images/2017/11/IMG_0412-e1510485328182-1024x768.jpg\" alt=\"\" width=\"640\" height=\"480\" />\n<h4>조립</h4>\n다행히 조립은 되었다.<p><img class=\"size-large wp-image-5389 aligncenter\" src=\"/content/images/2017/11/combine-977x1024.jpg\" alt=\"\" width=\"640\" height=\"671\" />\n<h4>수정이 필요한 부분</h4>\n<ol>\n \t<li>\n<h5>조립했을때 여유간격이 부족해서 살짝 휘어있다.</h5>\n</li>\n</ol>\n<img class=\"size-large wp-image-5390 aligncenter\" src=\"/content/images/2017/11/defect1-1024x766.jpg\" alt=\"\" width=\"640\" height=\"479\" />\n<h5>2. 실제 버튼 부품과 결합하면 조립되지 않는다.</h5>\n<img class=\"size-large wp-image-5391 aligncenter\" src=\"/content/images/2017/11/defect2-1024x761.png\" alt=\"\" width=\"640\" height=\"476\" />\n<h5>3. 배터리 부품을 넣으면 전선이 접히면서 결합이 되지 않는다.</h5>\n<img class=\"size-large wp-image-5392 aligncenter\" src=\"/content/images/2017/11/defect3-1024x850.jpg\" alt=\"\" width=\"640\" height=\"531\" />\n<h5>4. 버튼 부품의 간격이 작아서 뻑뻑하다.</h5>\n<img class=\"size-large wp-image-5393 aligncenter\" src=\"/content/images/2017/11/defect4-1024x677.png\" alt=\"\" width=\"640\" height=\"423\" />\n<h5>5. 벽이 너무 두꺼워서 빛이 너무 적게 투과한다.</h5>\n<img class=\"size-large wp-image-5394 aligncenter\" src=\"/content/images/2017/11/defect5-880x1024.jpg\" alt=\"\" width=\"640\" height=\"745\" />",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1510486414000,
                "created_by": 1,
                "updated_at": 1510486414000,
                "updated_by": 1,
                "published_at": 1510486414000,
                "published_by": 1
            },
            {
                "id": 5400,
                "title": "Azure Container Service (Kubernetes)와 DevOps 구현 사례 #1",
                "slug": "azure-container-service-kubernetes-devops-case-1",
                "markdown": "온프레미스에 배포하던 Multi-factor Authentication 솔루션을 클라우드로 전환하면서 SaaS 서비스를 준비하고 있는 <a href=\"http://www.aircuve.com/wp/\">에어큐브(주)</a>와 함께 해커톤을 이틀간 진행했었다. 에어큐브는 SaaS를 준비하면서 기존 아키텍쳐를 마이크로서비스 아키텍쳐로 변환했다. 총9개의 서비스가 관리 운영되어야 하는데 서비스가 많아지다 보니 관리, 운영, 배포가 문제가 되었다. 이를 컨테이너 서비스로 해결을 하려고 고민했고 이틀간의 해커톤으로 그 문제를 해결했던 사례를 공유한다. 설명할 내용을 요약하면 아래와 같다.\n<blockquote>Azure Container Service로 Kubernetes 클러스터와 Private Registry인 Azure Container Registry를 사용하여 서비스를 운영할 인프라를 만들었다. 개발자들은 자신의 로컬 개발환경에서 Docker를 이용하여 컨테이너 이미지를 만들고 Docker-Compose를 이용하여 여러개의 서비스를 한꺼번에 실행하여 테스트를 한다. 개발자들이 테스트 완료된 소스코드를 소스코드 리파지토리에 커밋하면 <a href=\"https://www.visualstudio.com/team-services/\">Visual Studio Team Service</a>에서 자동으로 빌드하고 자동으로 배포해서 새로운 버전의 컨테이너 애플리케이션을 Kubernetes 클러스터에 Rolling Update 한다.</blockquote>\n총 3개의 포스팅이 연결되어 있다.\n\n<a href=\"http://ilseokoh.com/2017/11/22/azure-container-service-kubernetes-devops-case-1-local-dev-environment/\">Azure Container Service (Kubernetes)와 DevOps 구현 사례 #2 – 로컬 개발환경</a>\n\n<a href=\"http://ilseokoh.com/2017/11/22/azure-container-service-kubernetes-devops-case-3-devops/\">Azure Container Service (Kubernetes)와 DevOps 구현 사례 #3 – DevOps</a>\n<h4>Azure Container Service (Kubernetes)</h4>\nAzure에서 컨테이너로 만든 애플리케이션을 운영하는 가장 좋은 방법은 Azure Container Service (ACS)를 이용하는 것이다. 우리가 Kubernetes 클러스터를 만들기 위해서 관련 내용을 찾아 공부하고 Azure 환경에 최적으로 만들어 내려면 아마도 많은 시간이 걸릴 것이다. Azure Container Services는 인프라에 대한 고민을 하지 않도록 도와준다. Azure Portal에서 마스터노드의 개수, 에이전트 노드의 개수 등 몇 가지만 정해주면 약 5분안에 우리가 원하는 Kubernetes 클러스터를 만들어준다. 우리는 Kubernetes의 사용법을 공부해서 즉시 배포하고 운영에 들어가면 된다. 이런게 Managed Service의 장점이다. Azure Container Services는 Kubernetes, DC/OS, Docker Swamp 이렇게 3가지 Ochestration을 지원한다. 이 중에서 Kubernetes를 선택하면 아래 그림과 같이 Azure의 인프라스트럭쳐와 가상머신을 이용하여 클러스터를 만들어준다.<a href=\"/content/images/2017/11/acs-detail.jpg\"><img class=\"size-full wp-image-5403 aligncenter\" src=\"/content/images/2017/11/acs-detail.jpg\" alt=\"\" width=\"918\" height=\"360\" /></a>\n<h4>Azure Portal에서 Kubernetes 클러스터 만들기</h4>\n<a href=\"https://docs.microsoft.com/ko-kr/azure/container-service/kubernetes/container-service-kubernetes-walkthrough\">Azure CLI로 ACS를 만드는 방법</a>은 문서에 잘 설명되어 있다. Azure Portal에서도 쉽게 만들 수 있다. 아래 화면캡쳐처럼 Azure Container Service를 선택하고 몇 가지 주요 설정을 해주면 된다. 몇 가지만 살펴보자.\n<ul>\n \t<li><strong>위치</strong>: 한국 데이터센터에서도 사용 가능함 (2018년 1월 12일 확인 및 수정) <del>2017-11-22 현재 한국 데이터센터에는 ACS를 만들 수 없다. 로드맵에 이미 들어가 있고 몇 달 안에 들어올 것으로 예상된다. 여기서는 일본서부에서 만들었다.</del></li>\n \t<li><strong>Orchestration</strong>: Kubernetes, DC/OS, Docker Swamp 중에 선택한다. 여기서는 Kubernetes를 선택한다.</li>\n \t<li><strong>DNS name prefix:</strong> DNS 호스트이름 앞부분에 쓰인다. 만약 opencloud라서 설정하면 opencloudmgmt.japanwest.cloudapp.azure.com 도메인이 생성된다.</li>\n \t<li><strong>Master Count:</strong> 설정한 수 만큼 Master Node VM을 생성한다. Master Node는 홀수로 만들어야 하기 때문에 1,3,5를 선택하게 되어있다.</li>\n \t<li><strong>Master Credential</strong> : Linux VM에 SSH를 접속하는 용도</li>\n \t<li><strong>Service Principle</strong>: ACS를 만들면 Azure 인프라의 여러 리소스를 API를 통해서 생성하게 되는데 이때 인증 방법이 필요하다. Azure Service Principle를 만들고 Application ID와 Secret를 적어준다. <a href=\"https://docs.microsoft.com/ko-kr/azure/azure-resource-manager/resource-group-create-service-principal-portal\">Azure Service Principle을 만드는 방법은 문서를 참조</a>하면 된다.</li>\n \t<li><strong>Agent Count</strong>: Agent Node의 개수를 정해주면 그 수 많큼 VM을 생성해준다.</li>\n \t<li><strong>Operating System</strong>: Linux로 선택한다. Windows는 현재 Preview.</li>\n</ul>\n<a href=\"/content/images/2017/11/acs-create.jpg\"><img class=\"size-full wp-image-5405 aligncenter\" src=\"/content/images/2017/11/acs-create.jpg\" alt=\"\" width=\"1585\" height=\"975\" /></a>\n\nNode 개수에 따라 다르지만 약 5분정도 걸리고 아래 그림처럼 Azure의 네트워크, 가상머신 등을 사용한 건 볼 수 있다. ACS 자체는 무료다. 대신 사용한 VM에 대한 과금을 한다. 즉 Node를 많이 만들면 VM수가 많아 지기 때문에 VM크기와 갯수에 따른 비용이 발생한다.\n\n<a href=\"/content/images/2017/11/acs-create-result.jpg\"><img class=\"size-full wp-image-5406 aligncenter\" src=\"/content/images/2017/11/acs-create-result.jpg\" alt=\"\" width=\"1730\" height=\"1075\" /></a>\n<h4>kubectl 로 Kubernetes 관리</h4>\nKubernetes 클러스터를 만들었으니 접속해보자. <a href=\"https://docs.microsoft.com/ko-kr/azure/container-service/kubernetes/container-service-kubernetes-walkthrough\">빠른 시작 문서</a>에 설명되어 있는데 Azure CLI를 통해서 kubectl 툴을 설치하고 Kubernetes 접속을 위한 config를 얻어 올 수 있다.\n<pre class=\"prettyprint\"># kubectl 설치\n$  az acs kubernetes install-cli\n\n# 자격증명 다운로드 \naz acs kubernetes get-credentials --resource-group=OpenCloudDemo --name=OpenCloudACS</pre>\n자격증명은 ~/.kube/config 파일에 저장된다. 공동 개발자나 관리자에게 공유해서 협업을 할 수 있다. kubectl은 다른 방법을 설치해도 좋다. 즉, 기존 사용하던 오픈소스 툴을 그대로 사용하면 된다. kubectl로 Azure 에 생성된 내용과 데모를 위해 배포된 서비스들을 살펴볼 수 있다.\n<pre class=\"prettyprint\">KevinMac:~ Kevin$ kubectl get nodes\nNAME                    STATUS    ROLES     AGE       VERSION\nk8s-agent-4491db0a-0    Ready     agent     6d        v1.7.7\nk8s-agent-4491db0a-1    Ready     agent     6d        v1.7.7\nk8s-agent-4491db0a-2    Ready     agent     22h       v1.7.7\nk8s-master-4491db0a-0   Ready     master    6d        v1.7.7\n\n$ kubectl get pods\nNAME                         READY     STATUS    RESTARTS   AGE\napi-demo-1039156325-fmt1w    1/1       Running   0          4d\nview-demo-2794589291-g6rsj   1/1       Running   0          10h\n\n$ kubectl get deployments\nNAME        DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE\napi-demo    1         1         1            1           4d\nview-demo   1         1         1            1           4d\n\n$ kubectl get services\nNAME         TYPE           CLUSTER-IP     EXTERNAL-IP     PORT(S)         AGE\napi-demo     ClusterIP      10.0.219.24    &lt;none&gt;          8080/TCP        4d\nkubernetes   ClusterIP      10.0.0.1       &lt;none&gt;          443/TCP         6d\nview-demo    LoadBalancer   10.0.253.107   104.215.31.15   443:31586/TCP   4d</pre>\n<a href=\"https://kubernetes.io/docs/user-guide/kubectl-overview/\">kubectl의 상세한 사용법은 Kubernetes Documentation</a>을 참조하면 된다. kubectl이 좋은 툴이지만 웹 기반의 관리툴이 더 편하다. ACS가 이미 셋업을 해놨다. proxy명령으로 proxy를 설정하고 localhost로 접속할 수 있다.\n<pre class=\"prettyprint\">$ kubectl proxy\nStarting to serve on 127.0.0.1:8001</pre>\n접속주소는 http://127.0.0.1:8001/ui 이고 접속하면 http://127.0.0.1:8001/api/v1/namespaces/kube-system/services/kubernetes-dashboard/proxy 로 리다이렉션되는데 <strong>Kubernetes 1.7.7의 버그인지 리다이렉션 주소에 슬래시(/)를 하나 더 붙여줘야 접속된다</strong>. Kubernetes 포탈을 이용해서 전체 클러스터에 대한 관리나 서비스, 애플리케이션의 관리가 가능하다.\n\n<a href=\"/content/images/2017/11/kubernetes-portal.jpg\"><img class=\"size-full wp-image-5410 aligncenter\" src=\"/content/images/2017/11/kubernetes-portal.jpg\" alt=\"\" width=\"1730\" height=\"1075\" /></a>\n<h4>Azure Container Registry 만들기</h4>\nDocker Hub 같은 공개된 Container Registry를 사용할 수 없는 경우 Private Registry를 사용하면 된다. 물론 내 로컬 서버에 설치할 수 도 있고 Azure VM을 만들어서 설치하거나 Container 이미지를 Kubernete에 배포해서 운영해도 되겠지만 Azure Container Registry는 사용할 수 있다. Azure Portal에서 이름 정도만 정해주면 만들 수 있다. Standard 를 선택하면 100GB의 저장공간을 제공한다. 2017년 11월 22일 현재 Korea DC에 만들 수 없고 아직 언제 가능하지 모르지만 가까운 일본 DC에 만들어도 운영에 문제가 되지는 않는다.\n\n<a href=\"/content/images/2017/11/azure-container-registry.jpg\"><img class=\"size-full wp-image-5411 aligncenter\" src=\"/content/images/2017/11/azure-container-registry.jpg\" alt=\"\" width=\"1730\" height=\"1075\" /></a>\n\n여기까지 Azure에 컨테이너 애플리케이션을 배포해서 운영할 수 있는 환경을 Azure Container Service와 Kubernetes를 이용해서 만들었다. <a href=\"http://ilseokoh.com/2017/11/22/azure-container-service-kubernetes-devops-case-1-local-dev-environment/\">다음은 개발자들의 로컬 개발환경 설정에 대한 내용</a>이다.",
                "html": "온프레미스에 배포하던 Multi-factor Authentication 솔루션을 클라우드로 전환하면서 SaaS 서비스를 준비하고 있는 <a href=\"http://www.aircuve.com/wp/\">에어큐브(주)</a>와 함께 해커톤을 이틀간 진행했었다. 에어큐브는 SaaS를 준비하면서 기존 아키텍쳐를 마이크로서비스 아키텍쳐로 변환했다. 총9개의 서비스가 관리 운영되어야 하는데 서비스가 많아지다 보니 관리, 운영, 배포가 문제가 되었다. 이를 컨테이너 서비스로 해결을 하려고 고민했고 이틀간의 해커톤으로 그 문제를 해결했던 사례를 공유한다. 설명할 내용을 요약하면 아래와 같다.\n<blockquote>Azure Container Service로 Kubernetes 클러스터와 Private Registry인 Azure Container Registry를 사용하여 서비스를 운영할 인프라를 만들었다. 개발자들은 자신의 로컬 개발환경에서 Docker를 이용하여 컨테이너 이미지를 만들고 Docker-Compose를 이용하여 여러개의 서비스를 한꺼번에 실행하여 테스트를 한다. 개발자들이 테스트 완료된 소스코드를 소스코드 리파지토리에 커밋하면 <a href=\"https://www.visualstudio.com/team-services/\">Visual Studio Team Service</a>에서 자동으로 빌드하고 자동으로 배포해서 새로운 버전의 컨테이너 애플리케이션을 Kubernetes 클러스터에 Rolling Update 한다.</blockquote>\n총 3개의 포스팅이 연결되어 있다.<p><a href=\"http://ilseokoh.com/2017/11/22/azure-container-service-kubernetes-devops-case-1-local-dev-environment/\">Azure Container Service (Kubernetes)와 DevOps 구현 사례 #2 – 로컬 개발환경</a><p><a href=\"http://ilseokoh.com/2017/11/22/azure-container-service-kubernetes-devops-case-3-devops/\">Azure Container Service (Kubernetes)와 DevOps 구현 사례 #3 – DevOps</a>\n<h4>Azure Container Service (Kubernetes)</h4>\nAzure에서 컨테이너로 만든 애플리케이션을 운영하는 가장 좋은 방법은 Azure Container Service (ACS)를 이용하는 것이다. 우리가 Kubernetes 클러스터를 만들기 위해서 관련 내용을 찾아 공부하고 Azure 환경에 최적으로 만들어 내려면 아마도 많은 시간이 걸릴 것이다. Azure Container Services는 인프라에 대한 고민을 하지 않도록 도와준다. Azure Portal에서 마스터노드의 개수, 에이전트 노드의 개수 등 몇 가지만 정해주면 약 5분안에 우리가 원하는 Kubernetes 클러스터를 만들어준다. 우리는 Kubernetes의 사용법을 공부해서 즉시 배포하고 운영에 들어가면 된다. 이런게 Managed Service의 장점이다. Azure Container Services는 Kubernetes, DC/OS, Docker Swamp 이렇게 3가지 Ochestration을 지원한다. 이 중에서 Kubernetes를 선택하면 아래 그림과 같이 Azure의 인프라스트럭쳐와 가상머신을 이용하여 클러스터를 만들어준다.<a href=\"/content/images/2017/11/acs-detail.jpg\"><img class=\"size-full wp-image-5403 aligncenter\" src=\"/content/images/2017/11/acs-detail.jpg\" alt=\"\" width=\"918\" height=\"360\" /></a>\n<h4>Azure Portal에서 Kubernetes 클러스터 만들기</h4>\n<a href=\"https://docs.microsoft.com/ko-kr/azure/container-service/kubernetes/container-service-kubernetes-walkthrough\">Azure CLI로 ACS를 만드는 방법</a>은 문서에 잘 설명되어 있다. Azure Portal에서도 쉽게 만들 수 있다. 아래 화면캡쳐처럼 Azure Container Service를 선택하고 몇 가지 주요 설정을 해주면 된다. 몇 가지만 살펴보자.\n<ul>\n \t<li><strong>위치</strong>: 한국 데이터센터에서도 사용 가능함 (2018년 1월 12일 확인 및 수정) <del>2017-11-22 현재 한국 데이터센터에는 ACS를 만들 수 없다. 로드맵에 이미 들어가 있고 몇 달 안에 들어올 것으로 예상된다. 여기서는 일본서부에서 만들었다.</del></li>\n \t<li><strong>Orchestration</strong>: Kubernetes, DC/OS, Docker Swamp 중에 선택한다. 여기서는 Kubernetes를 선택한다.</li>\n \t<li><strong>DNS name prefix:</strong> DNS 호스트이름 앞부분에 쓰인다. 만약 opencloud라서 설정하면 opencloudmgmt.japanwest.cloudapp.azure.com 도메인이 생성된다.</li>\n \t<li><strong>Master Count:</strong> 설정한 수 만큼 Master Node VM을 생성한다. Master Node는 홀수로 만들어야 하기 때문에 1,3,5를 선택하게 되어있다.</li>\n \t<li><strong>Master Credential</strong> : Linux VM에 SSH를 접속하는 용도</li>\n \t<li><strong>Service Principle</strong>: ACS를 만들면 Azure 인프라의 여러 리소스를 API를 통해서 생성하게 되는데 이때 인증 방법이 필요하다. Azure Service Principle를 만들고 Application ID와 Secret를 적어준다. <a href=\"https://docs.microsoft.com/ko-kr/azure/azure-resource-manager/resource-group-create-service-principal-portal\">Azure Service Principle을 만드는 방법은 문서를 참조</a>하면 된다.</li>\n \t<li><strong>Agent Count</strong>: Agent Node의 개수를 정해주면 그 수 많큼 VM을 생성해준다.</li>\n \t<li><strong>Operating System</strong>: Linux로 선택한다. Windows는 현재 Preview.</li>\n</ul>\n<a href=\"/content/images/2017/11/acs-create.jpg\"><img class=\"size-full wp-image-5405 aligncenter\" src=\"/content/images/2017/11/acs-create.jpg\" alt=\"\" width=\"1585\" height=\"975\" /></a><p>Node 개수에 따라 다르지만 약 5분정도 걸리고 아래 그림처럼 Azure의 네트워크, 가상머신 등을 사용한 건 볼 수 있다. ACS 자체는 무료다. 대신 사용한 VM에 대한 과금을 한다. 즉 Node를 많이 만들면 VM수가 많아 지기 때문에 VM크기와 갯수에 따른 비용이 발생한다.<p><a href=\"/content/images/2017/11/acs-create-result.jpg\"><img class=\"size-full wp-image-5406 aligncenter\" src=\"/content/images/2017/11/acs-create-result.jpg\" alt=\"\" width=\"1730\" height=\"1075\" /></a>\n<h4>kubectl 로 Kubernetes 관리</h4>\nKubernetes 클러스터를 만들었으니 접속해보자. <a href=\"https://docs.microsoft.com/ko-kr/azure/container-service/kubernetes/container-service-kubernetes-walkthrough\">빠른 시작 문서</a>에 설명되어 있는데 Azure CLI를 통해서 kubectl 툴을 설치하고 Kubernetes 접속을 위한 config를 얻어 올 수 있다.\n<pre class=\"prettyprint\"># kubectl 설치\n$  az acs kubernetes install-cli<p># 자격증명 다운로드 \naz acs kubernetes get-credentials --resource-group=OpenCloudDemo --name=OpenCloudACS</pre>\n자격증명은 ~/.kube/config 파일에 저장된다. 공동 개발자나 관리자에게 공유해서 협업을 할 수 있다. kubectl은 다른 방법을 설치해도 좋다. 즉, 기존 사용하던 오픈소스 툴을 그대로 사용하면 된다. kubectl로 Azure 에 생성된 내용과 데모를 위해 배포된 서비스들을 살펴볼 수 있다.\n<pre class=\"prettyprint\">KevinMac:~ Kevin$ kubectl get nodes\nNAME                    STATUS    ROLES     AGE       VERSION\nk8s-agent-4491db0a-0    Ready     agent     6d        v1.7.7\nk8s-agent-4491db0a-1    Ready     agent     6d        v1.7.7\nk8s-agent-4491db0a-2    Ready     agent     22h       v1.7.7\nk8s-master-4491db0a-0   Ready     master    6d        v1.7.7<p>$ kubectl get pods\nNAME                         READY     STATUS    RESTARTS   AGE\napi-demo-1039156325-fmt1w    1/1       Running   0          4d\nview-demo-2794589291-g6rsj   1/1       Running   0          10h<p>$ kubectl get deployments\nNAME        DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE\napi-demo    1         1         1            1           4d\nview-demo   1         1         1            1           4d<p>$ kubectl get services\nNAME         TYPE           CLUSTER-IP     EXTERNAL-IP     PORT(S)         AGE\napi-demo     ClusterIP      10.0.219.24    &lt;none&gt;          8080/TCP        4d\nkubernetes   ClusterIP      10.0.0.1       &lt;none&gt;          443/TCP         6d\nview-demo    LoadBalancer   10.0.253.107   104.215.31.15   443:31586/TCP   4d</pre>\n<a href=\"https://kubernetes.io/docs/user-guide/kubectl-overview/\">kubectl의 상세한 사용법은 Kubernetes Documentation</a>을 참조하면 된다. kubectl이 좋은 툴이지만 웹 기반의 관리툴이 더 편하다. ACS가 이미 셋업을 해놨다. proxy명령으로 proxy를 설정하고 localhost로 접속할 수 있다.\n<pre class=\"prettyprint\">$ kubectl proxy\nStarting to serve on 127.0.0.1:8001</pre>\n접속주소는 http://127.0.0.1:8001/ui 이고 접속하면 http://127.0.0.1:8001/api/v1/namespaces/kube-system/services/kubernetes-dashboard/proxy 로 리다이렉션되는데 <strong>Kubernetes 1.7.7의 버그인지 리다이렉션 주소에 슬래시(/)를 하나 더 붙여줘야 접속된다</strong>. Kubernetes 포탈을 이용해서 전체 클러스터에 대한 관리나 서비스, 애플리케이션의 관리가 가능하다.<p><a href=\"/content/images/2017/11/kubernetes-portal.jpg\"><img class=\"size-full wp-image-5410 aligncenter\" src=\"/content/images/2017/11/kubernetes-portal.jpg\" alt=\"\" width=\"1730\" height=\"1075\" /></a>\n<h4>Azure Container Registry 만들기</h4>\nDocker Hub 같은 공개된 Container Registry를 사용할 수 없는 경우 Private Registry를 사용하면 된다. 물론 내 로컬 서버에 설치할 수 도 있고 Azure VM을 만들어서 설치하거나 Container 이미지를 Kubernete에 배포해서 운영해도 되겠지만 Azure Container Registry는 사용할 수 있다. Azure Portal에서 이름 정도만 정해주면 만들 수 있다. Standard 를 선택하면 100GB의 저장공간을 제공한다. 2017년 11월 22일 현재 Korea DC에 만들 수 없고 아직 언제 가능하지 모르지만 가까운 일본 DC에 만들어도 운영에 문제가 되지는 않는다.<p><a href=\"/content/images/2017/11/azure-container-registry.jpg\"><img class=\"size-full wp-image-5411 aligncenter\" src=\"/content/images/2017/11/azure-container-registry.jpg\" alt=\"\" width=\"1730\" height=\"1075\" /></a><p>여기까지 Azure에 컨테이너 애플리케이션을 배포해서 운영할 수 있는 환경을 Azure Container Service와 Kubernetes를 이용해서 만들었다. <a href=\"http://ilseokoh.com/2017/11/22/azure-container-service-kubernetes-devops-case-1-local-dev-environment/\">다음은 개발자들의 로컬 개발환경 설정에 대한 내용</a>이다.",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1511296884000,
                "created_by": 1,
                "updated_at": 1511296884000,
                "updated_by": 1,
                "published_at": 1511296884000,
                "published_by": 1
            },
            {
                "id": 5422,
                "title": "Azure Container Service (Kubernetes)와 DevOps 구현 사례 #2 - 로컬 개발환경",
                "slug": "azure-container-service-kubernetes-devops-case-1-local-dev-environment",
                "markdown": "<a href=\"http://ilseokoh.com/2017/11/22/azure-container-service-kubernetes-devops-case-1/\">Azure Container Service (Kubernetes)와 DevOps 구현 사례 #1</a> 에서는 Kubernetes 운영환경을 만들었다. 여기서는 개발자들이 로컬 개발환경에서 소스를 수정 후에 빌드를 하고 Docker 이미지를 만드는 과정을 알아보자. 여러 개의 서비스로 구성된 마이크로서비스 아키텍쳐라면 서비스들이 한꺼번에 실행되어야 테스트를 할 수 있는데 Docker Compose로 테스트 하는 방법도 알아보자.\n<h4>Docker 설치</h4>\n먼저 Docker 가 로컬 개발환경에 설치되어 있어야 한다. <a href=\"https://docs.docker.com/docker-for-mac/install/\">Docker 설치 방법</a>은 웹에 문서가 많다. 검색해서 참조해서 설치하면 된다. 맥의 경우 dmg 이미지로 쉽게 설치할 수 있다.\n<h4>개발환경</h4>\nJava + Spring boot 로 개발이 되어있고 이클립스를 사용했다. <a href=\"http://maven.apache.org/\">메이븐(maven)</a>을 사용하여 빌드를 관리한다. 설명에 사용한 소스코드는 github에<a href=\"https://github.com/bang0124/api-demo\"> api-demo</a>, <a href=\"https://github.com/bang0124/view-demo\">view-demo</a> 라는 프로젝트로 공개되어 있다. 소스코드에서 Dockerfile, pom.xml, docker-compose.yml 파일을 참고 바란다.\n<h4><a href=\"https://github.com/bang0124/view-demo/blob/master/pom.xml\">pom.xml</a></h4>\nMaven을 사용하면 빌드와 도커 이미지 생성을 동시에 할 수 있다. spotify 에서 만든 Maven Plugin인 <a href=\"https://docs.spring.io/spring-boot/docs/current/maven-plugin/usage.html\">spring-boot-maven-plugin</a>을 사용하면 쉽게 설정 할 수 있다. pom.xml 에 plugin 설정을 보면 Maven의 Goal은 package로 설정되어 있고 $ mvn package 명령하나로 소스빌드와 도커이미지 설정이 한번에 수행된다. repository 을 보면 이미지의 이름과 태그가 opencloudregistry.azurecr.io/clouddemo/view-demo:1 으로 설정되어 있는 걸 볼 수 있다.\n\n이클립스에서 Maven Build를 실행하거나 터미널에서 $ mvn package 명령으로 실행할 수 있다. pom.xml에 기술되어 있는 것처럼 소스를 빌드하고 war 패키지를 만들고 마지막으로 도커 이미지를 만든다.\n<pre class=\"prettyprint\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n\t&lt;groupId&gt;com.aircuve&lt;/groupId&gt;\n\t&lt;artifactId&gt;view-demo&lt;/artifactId&gt;\n\t&lt;version&gt;0.0.1&lt;/version&gt;\n\t&lt;packaging&gt;war&lt;/packaging&gt;\n\n\t&lt;name&gt;view-demo&lt;/name&gt;\n\t&lt;description&gt;Saas view demo for Spring Boot&lt;/description&gt;\n\n\t&lt;parent&gt;\n\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n\t\t&lt;version&gt;1.4.7.RELEASE&lt;/version&gt;\n\t\t&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n\t&lt;/parent&gt;\n\n\t&lt;properties&gt;\n\t\t&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n\t\t&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n\t\t&lt;java.version&gt;1.8&lt;/java.version&gt;\n\t&lt;/properties&gt;\n\n\t&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t(중간생략)\t...\n\n\t&lt;/dependencies&gt;\n\n\t&lt;build&gt;\n\t\t&lt;plugins&gt;\n\t\t\t&lt;plugin&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n\t\t\t&lt;/plugin&gt;\n\t\t\t&lt;plugin&gt;\n\t            &lt;groupId&gt;com.spotify&lt;/groupId&gt;\n\t            &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;\n\t            &lt;version&gt;1.3.4&lt;/version&gt;\n\t\t\t\t&lt;executions&gt;\n\t\t\t\t    &lt;execution&gt;\n                        &lt;id&gt;build-image&lt;/id&gt;\n                        &lt;phase&gt;package&lt;/phase&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;build&lt;/goal&gt;\n                        &lt;/goals&gt;\n                    &lt;/execution&gt;      \n\t\t\t\t  &lt;/executions&gt;\n\t\t\t\t  \n\t            &lt;configuration&gt;\n\t           \t &lt;repository&gt;opencloudregistry.azurecr.io/clouddemo/view-demo&lt;/repository&gt;\n    \t\t\t\t &lt;tag&gt;1&lt;/tag&gt;\n    \t\t\t\t&lt;googleContainerRegistryEnabled&gt;false&lt;/googleContainerRegistryEnabled&gt;\n\t            &lt;/configuration&gt;\n        \t&lt;/plugin&gt;\n\t\t&lt;/plugins&gt;\n\t&lt;/build&gt;\n&lt;/project&gt;</pre>\n<h4><a href=\"https://github.com/bang0124/view-demo/blob/master/Dockerfile\">Dockerfile</a></h4>\n<pre class=\"prettyprint\">FROM java:8\nVOLUME /tmp\nADD target/view-demo-0.0.1.war app.war\nENV JAVA_OPTS=\"\"\nRUN bash -c 'touch /app.war'\nENTRYPOINT [\"java\",\"-Djava.security.egd=file:/dev/./urandom\",\"-jar\",\"/app.war\"]\n</pre>\nMaven이 도커 이미지를 만들기 위해서는 Dockerfile이 필요하다. Dockerfile에 어떻게 도커 이미지를 만들것인지에 대한 명령이 들어있다. 여기서는 Base 이미지를 java:8을 사용했다. Docker Hub에서 이미지를 다운받아서 빌드할 때 만들어 놓은 war 파일을 복사한다. 마지막으로 도커 이미지가 로드되서 실행할 애플리케이션을 지정했다.\n<h4>메이븐 빌드 로그</h4>\n이클립스에서 빌드한 결과 로그를 보면 어떻게 최종 빌드 이미지를 만드는지 볼 수 있다.\n<pre class=\"prettyprint\">[INFO] Scanning for projects...\n[INFO]                                                                         \n[INFO] ------------------------------------------------------------------------\n[INFO] Building view-demo 0.0.1\n[INFO] ------------------------------------------------------------------------\n[INFO] \n[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ view-demo ---\n[INFO] Using 'UTF-8' encoding to copy filtered resources.\n[INFO] Copying 1 resource\n[INFO] Copying 120 resources\n[INFO] \n[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ view-demo ---\n[INFO] Nothing to compile - all classes are up to date\n[INFO] \n[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ view-demo ---\n[INFO] Using 'UTF-8' encoding to copy filtered resources.\n[INFO] skip non existing resourceDirectory /Users/Kevin/source/opencloud/view-demo/src/test/resources\n[INFO] \n[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ view-demo ---\n[INFO] Nothing to compile - all classes are up to date\n[INFO] \n[INFO] --- maven-surefire-plugin:2.18.1:test (default-test) @ view-demo ---\n[INFO] Surefire report directory: /Users/Kevin/source/opencloud/view-demo/target/surefire-reports\n\n-------------------------------------------------------\n T E S T S\n-------------------------------------------------------\n2017-11-22 15:52:30.555  INFO   --- [           main] .b.t.c.SpringBootTestContextBootstrapper : Neither @ContextConfiguration nor @ContextHierarchy found for test class [com.aircuve.view.ViewPackageApplicationTests], using SpringBootContextLoader\n2017-11-22 15:52:30.575  INFO   --- [           main] o.s.t.c.support.AbstractContextLoader    : Could not detect default resource locations for test class [com.aircuve.view.ViewPackageApplicationTests]: no resource found for suffixes {-context.xml, Context.groovy}.\n\n(중간생략 ...)\n\norg.springframework.boot.test.autoconfigure.web.client.MockRestServiceServerResetTestExecutionListener@5ae50ce6]\n\n  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v1.4.7.RELEASE)\n\n2017-11-22 15:52:31.290  INFO 8060 --- [           main] c.a.view.ViewPackageApplicationTests     : Starting ViewPackageApplicationTests on KevinMac.local with PID 8060 (started by Kevin in /Users/Kevin/source/opencloud/view-demo)\n\n(중간생략 ...)\n\nTests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.84 sec - in com.aircuve.view.ViewPackageApplicationTests\n2017-11-22 15:52:33.576  INFO 8060 --- [       Thread-2] o.s.w.c.s.GenericWebApplicationContext   : Closing org.springframework.web.context.support.GenericWebApplicationContext@6853425f: startup date [Wed Nov 22 15:52:31 KST 2017]; root of context hierarchy\n\nResults :\n\nTests run: 1, Failures: 0, Errors: 0, Skipped: 0\n\n[INFO] \n[INFO] --- maven-war-plugin:2.6:war (default-war) @ view-demo ---\n[INFO] Packaging webapp\n[INFO] Assembling webapp [view-demo] in [/Users/Kevin/source/opencloud/view-demo/target/view-demo-0.0.1]\n[INFO] Processing war project\n[INFO] Copying webapp resources [/Users/Kevin/source/opencloud/view-demo/src/main/webapp]\n[INFO] Webapp assembled in [361 msecs]\n[INFO] Building war: /Users/Kevin/source/opencloud/view-demo/target/view-demo-0.0.1.war\n[INFO] \n[INFO] --- spring-boot-maven-plugin:1.4.7.RELEASE:repackage (default) @ view-demo ---\n[INFO] \n[INFO] --- dockerfile-maven-plugin:1.3.4:build (build-image) @ view-demo ---\n[INFO] Google Container Registry support is disabled\n[INFO] Building Docker context /Users/Kevin/source/opencloud/view-demo\n[INFO] \n[INFO] Image will be built as opencloudregistry.azurecr.io/clouddemo/view-demo:2\n[INFO] \n[INFO] Step 1/6 : FROM java:8\n[INFO] Pulling from library/java\n[INFO] Digest: sha256:c1ff613e8ba25833d2e1940da0940c3824f03f802c449f3d1815a66b7f8c0e9d\n[INFO] Status: Image is up to date for java:8\n[INFO]  ---&gt; d23bdf5b1b1b\n[INFO] Step 2/6 : VOLUME /tmp\n[INFO]  ---&gt; Using cache\n[INFO]  ---&gt; d7662a1cee77\n[INFO] Step 3/6 : ADD target/view-demo-0.0.1.war app.war\n[INFO]  ---&gt; fb5ba0dda896\n[INFO] Step 4/6 : ENV JAVA_OPTS \"\"\n[INFO]  ---&gt; Running in 29ff6523682b\n[INFO]  ---&gt; 7ff1eed623c5\n[INFO] Removing intermediate container 29ff6523682b\n[INFO] Step 5/6 : RUN bash -c 'touch /app.war'\n[INFO]  ---&gt; Running in 1d0725dc2a29\n[INFO]  ---&gt; 229230cd53ba\n[INFO] Removing intermediate container 1d0725dc2a29\n[INFO] Step 6/6 : ENTRYPOINT java -Djava.security.egd=file:/dev/./urandom -jar /app.war\n[INFO]  ---&gt; Running in dbff4c32c614\n[INFO]  ---&gt; dbdf6c3ac7fc\n[INFO] Removing intermediate container dbff4c32c614\n[INFO] Successfully built dbdf6c3ac7fc\n[INFO] Successfully tagged opencloudregistry.azurecr.io/clouddemo/view-demo:2\n[INFO] \n[INFO] Detected build of image with id dbdf6c3ac7fc\n[INFO] Building jar: /Users/Kevin/source/opencloud/view-demo/target/view-demo-0.0.1-docker-info.jar\n[INFO] Successfully built opencloudregistry.azurecr.io/clouddemo/view-demo:2\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 25.745 s\n[INFO] Finished at: 2017-11-22T15:52:53+09:00\n[INFO] Final Memory: 33M/384M\n[INFO] ------------------------------------------------------------------------\n</pre>\n<h4><a href=\"https://github.com/bang0124/view-demo/blob/master/docker-compose.yml\">Docker Compose</a></h4>\n마이크로서비스 아키텍쳐의 경우 테스트를 하려면 관련된 서비스가 모두 실행이 되어야 한다. 즉 연관된 도커 이미지가 한번에 실행되어야 내가 수정한 소스코드가 정상적으로 작동하는지 알 수 있다. docker 명령으로 하나씩 올려서 테스트 할 수 도 있지만 Docker Compose를 이용하면 쉽게 테스트 환경을 만들 수 있다. 여기에서는 view-demo 와 api-demo 두 개의 서비스를 한번에 올려서 테스트 하도록 Docker Compose를 구성했다. <a href=\"https://github.com/bang0124/view-demo/blob/master/docker-compose.yml\">docker-compose.yml</a> 파일의 내용은 아래와 같다.\n<pre class=\"prettyprint\">version: \"3.3\"\nservices:\n    view-demo:\n      image: opencloudregistry.azurecr.io/clouddemo/view-demo:1\n      container_name: view-demo\n      ports:\n        - \"443:8443\"\n    api-demo:\n      image: opencloudregistry.azurecr.io/clouddemo/api-demo:1\n      container_name: api-demo</pre>\n$ docker-compose up 명령을 실행해서 https://localost로 접속해서 테스트 할 수 있다.\n<pre class=\"prettyprint\">$ docker-compose up\nStarting view-demo ... \nStarting api-demo ... \nStarting api-demo\nStarting api-demo ... done\nAttaching to view-demo, api-demo\napi-demo     | \napi-demo     |   .   ____          _            __ _ _\napi-demo     |  /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\napi-demo     | ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\napi-demo     |  \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\napi-demo     |   '  |____| .__|_| |_|_| |_\\__, | / / / /\napi-demo     |  =========|_|==============|___/=/_/_/_/\napi-demo     |  :: Spring Boot ::        (v1.4.7.RELEASE)\napi-demo     | \nview-demo    | \nview-demo    |   .   ____          _            __ _ _\nview-demo    |  /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\nview-demo    | ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\nview-demo    |  \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\nview-demo    |   '  |____| .__|_| |_|_| |_\\__, | / / / /\nview-demo    |  =========|_|==============|___/=/_/_/_/\nview-demo    |  :: Spring Boot ::        (v1.4.7.RELEASE)\nview-demo    | \nview-demo    | 2017-11-22 07:00:07.288  INFO 1 --- [           main] com.aircuve.ViewPackageApplication       : Starting ViewPackageApplication v0.0.1 on a7a23f97ce7c with PID 1 (/app.war started by root in /)\nview-demo    | 2017-11-22 07:00:07.309 DEBUG 1 --- [           main] com.aircuve.ViewPackageApplication       : Running with Spring Boot v1.4.7.RELEASE, Spring v4.3.9.RELEASE\nview-demo    | 2017-11-22 07:00:07.310  INFO 1 --- [           main] com.aircuve.ViewPackageApplication       : No active profile set, falling back to default profiles: default\napi-demo     | 2017-11-22 07:00:07.357  INFO 1 --- [           main] com.aircuve.ApiPackageApplication        : Starting ApiPackageApplication v0.0.1 on 16b394d7ca29 with PID 1 (/app.war started by root in /)\napi-demo     | 2017-11-22 07:00:07.396  INFO 1 --- [           main] com.aircuve.ApiPackageApplication        : No active profile set, falling back to default profiles: default\nview-demo    | 2017-11-22 07:00:07.424  INFO 1 --- [           main] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@14899482: startup date [Wed Nov 22 07:00:07 UTC 2017]; root of context hierarchy\n\n(중간생략 ...)\n\nview-demo    | 2017-11-22 07:00:14.622  INFO 1 --- [           main] com.aircuve.ViewPackageApplication       : Started ViewPackageApplication in 8.298 seconds (JVM running for 9.362)\napi-demo     | 2017-11-22 07:00:14.713  INFO 1 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup\napi-demo     | 2017-11-22 07:00:14.842  INFO 1 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)\napi-demo     | 2017-11-22 07:00:14.850  INFO 1 --- [           main] com.aircuve.ApiPackageApplication        : Started ApiPackageApplication in 8.51 seconds (JVM running for 9.59)</pre>\n&nbsp;\n\n<img class=\"size-large wp-image-5427 aligncenter\" src=\"/content/images/2017/11/docker-compose-test-1024x649.jpg\" alt=\"\" width=\"640\" height=\"406\" />",
                "html": "<a href=\"http://ilseokoh.com/2017/11/22/azure-container-service-kubernetes-devops-case-1/\">Azure Container Service (Kubernetes)와 DevOps 구현 사례 #1</a> 에서는 Kubernetes 운영환경을 만들었다. 여기서는 개발자들이 로컬 개발환경에서 소스를 수정 후에 빌드를 하고 Docker 이미지를 만드는 과정을 알아보자. 여러 개의 서비스로 구성된 마이크로서비스 아키텍쳐라면 서비스들이 한꺼번에 실행되어야 테스트를 할 수 있는데 Docker Compose로 테스트 하는 방법도 알아보자.\n<h4>Docker 설치</h4>\n먼저 Docker 가 로컬 개발환경에 설치되어 있어야 한다. <a href=\"https://docs.docker.com/docker-for-mac/install/\">Docker 설치 방법</a>은 웹에 문서가 많다. 검색해서 참조해서 설치하면 된다. 맥의 경우 dmg 이미지로 쉽게 설치할 수 있다.\n<h4>개발환경</h4>\nJava + Spring boot 로 개발이 되어있고 이클립스를 사용했다. <a href=\"http://maven.apache.org/\">메이븐(maven)</a>을 사용하여 빌드를 관리한다. 설명에 사용한 소스코드는 github에<a href=\"https://github.com/bang0124/api-demo\"> api-demo</a>, <a href=\"https://github.com/bang0124/view-demo\">view-demo</a> 라는 프로젝트로 공개되어 있다. 소스코드에서 Dockerfile, pom.xml, docker-compose.yml 파일을 참고 바란다.\n<h4><a href=\"https://github.com/bang0124/view-demo/blob/master/pom.xml\">pom.xml</a></h4>\nMaven을 사용하면 빌드와 도커 이미지 생성을 동시에 할 수 있다. spotify 에서 만든 Maven Plugin인 <a href=\"https://docs.spring.io/spring-boot/docs/current/maven-plugin/usage.html\">spring-boot-maven-plugin</a>을 사용하면 쉽게 설정 할 수 있다. pom.xml 에 plugin 설정을 보면 Maven의 Goal은 package로 설정되어 있고 $ mvn package 명령하나로 소스빌드와 도커이미지 설정이 한번에 수행된다. repository 을 보면 이미지의 이름과 태그가 opencloudregistry.azurecr.io/clouddemo/view-demo:1 으로 설정되어 있는 걸 볼 수 있다.<p>이클립스에서 Maven Build를 실행하거나 터미널에서 $ mvn package 명령으로 실행할 수 있다. pom.xml에 기술되어 있는 것처럼 소스를 빌드하고 war 패키지를 만들고 마지막으로 도커 이미지를 만든다.\n<pre class=\"prettyprint\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<p>\t&lt;groupId&gt;com.aircuve&lt;/groupId&gt;\n\t&lt;artifactId&gt;view-demo&lt;/artifactId&gt;\n\t&lt;version&gt;0.0.1&lt;/version&gt;\n\t&lt;packaging&gt;war&lt;/packaging&gt;<p>\t&lt;name&gt;view-demo&lt;/name&gt;\n\t&lt;description&gt;Saas view demo for Spring Boot&lt;/description&gt;<p>\t&lt;parent&gt;\n\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n\t\t&lt;version&gt;1.4.7.RELEASE&lt;/version&gt;\n\t\t&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n\t&lt;/parent&gt;<p>\t&lt;properties&gt;\n\t\t&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n\t\t&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n\t\t&lt;java.version&gt;1.8&lt;/java.version&gt;\n\t&lt;/properties&gt;<p>\t&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;<p>\t(중간생략)\t...<p>\t&lt;/dependencies&gt;<p>\t&lt;build&gt;\n\t\t&lt;plugins&gt;\n\t\t\t&lt;plugin&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n\t\t\t&lt;/plugin&gt;\n\t\t\t&lt;plugin&gt;\n\t            &lt;groupId&gt;com.spotify&lt;/groupId&gt;\n\t            &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;\n\t            &lt;version&gt;1.3.4&lt;/version&gt;\n\t\t\t\t&lt;executions&gt;\n\t\t\t\t    &lt;execution&gt;\n                        &lt;id&gt;build-image&lt;/id&gt;\n                        &lt;phase&gt;package&lt;/phase&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;build&lt;/goal&gt;\n                        &lt;/goals&gt;\n                    &lt;/execution&gt;      \n\t\t\t\t  &lt;/executions&gt;\n\t\t\t\t  \n\t            &lt;configuration&gt;\n\t           \t &lt;repository&gt;opencloudregistry.azurecr.io/clouddemo/view-demo&lt;/repository&gt;\n    \t\t\t\t &lt;tag&gt;1&lt;/tag&gt;\n    \t\t\t\t&lt;googleContainerRegistryEnabled&gt;false&lt;/googleContainerRegistryEnabled&gt;\n\t            &lt;/configuration&gt;\n        \t&lt;/plugin&gt;\n\t\t&lt;/plugins&gt;\n\t&lt;/build&gt;\n&lt;/project&gt;</pre>\n<h4><a href=\"https://github.com/bang0124/view-demo/blob/master/Dockerfile\">Dockerfile</a></h4>\n<pre class=\"prettyprint\">FROM java:8\nVOLUME /tmp\nADD target/view-demo-0.0.1.war app.war\nENV JAVA_OPTS=\"\"\nRUN bash -c 'touch /app.war'\nENTRYPOINT [\"java\",\"-Djava.security.egd=file:/dev/./urandom\",\"-jar\",\"/app.war\"]\n</pre>\nMaven이 도커 이미지를 만들기 위해서는 Dockerfile이 필요하다. Dockerfile에 어떻게 도커 이미지를 만들것인지에 대한 명령이 들어있다. 여기서는 Base 이미지를 java:8을 사용했다. Docker Hub에서 이미지를 다운받아서 빌드할 때 만들어 놓은 war 파일을 복사한다. 마지막으로 도커 이미지가 로드되서 실행할 애플리케이션을 지정했다.\n<h4>메이븐 빌드 로그</h4>\n이클립스에서 빌드한 결과 로그를 보면 어떻게 최종 빌드 이미지를 만드는지 볼 수 있다.\n<pre class=\"prettyprint\">[INFO] Scanning for projects...\n[INFO]                                                                         \n[INFO] ------------------------------------------------------------------------\n[INFO] Building view-demo 0.0.1\n[INFO] ------------------------------------------------------------------------\n[INFO] \n[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ view-demo ---\n[INFO] Using 'UTF-8' encoding to copy filtered resources.\n[INFO] Copying 1 resource\n[INFO] Copying 120 resources\n[INFO] \n[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ view-demo ---\n[INFO] Nothing to compile - all classes are up to date\n[INFO] \n[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ view-demo ---\n[INFO] Using 'UTF-8' encoding to copy filtered resources.\n[INFO] skip non existing resourceDirectory /Users/Kevin/source/opencloud/view-demo/src/test/resources\n[INFO] \n[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ view-demo ---\n[INFO] Nothing to compile - all classes are up to date\n[INFO] \n[INFO] --- maven-surefire-plugin:2.18.1:test (default-test) @ view-demo ---\n[INFO] Surefire report directory: /Users/Kevin/source/opencloud/view-demo/target/surefire-reports<p>-------------------------------------------------------\n T E S T S\n-------------------------------------------------------\n2017-11-22 15:52:30.555  INFO   --- [           main] .b.t.c.SpringBootTestContextBootstrapper : Neither @ContextConfiguration nor @ContextHierarchy found for test class [com.aircuve.view.ViewPackageApplicationTests], using SpringBootContextLoader\n2017-11-22 15:52:30.575  INFO   --- [           main] o.s.t.c.support.AbstractContextLoader    : Could not detect default resource locations for test class [com.aircuve.view.ViewPackageApplicationTests]: no resource found for suffixes {-context.xml, Context.groovy}.<p>(중간생략 ...)<p>org.springframework.boot.test.autoconfigure.web.client.MockRestServiceServerResetTestExecutionListener@5ae50ce6]<p>  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v1.4.7.RELEASE)<p>2017-11-22 15:52:31.290  INFO 8060 --- [           main] c.a.view.ViewPackageApplicationTests     : Starting ViewPackageApplicationTests on KevinMac.local with PID 8060 (started by Kevin in /Users/Kevin/source/opencloud/view-demo)<p>(중간생략 ...)<p>Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.84 sec - in com.aircuve.view.ViewPackageApplicationTests\n2017-11-22 15:52:33.576  INFO 8060 --- [       Thread-2] o.s.w.c.s.GenericWebApplicationContext   : Closing org.springframework.web.context.support.GenericWebApplicationContext@6853425f: startup date [Wed Nov 22 15:52:31 KST 2017]; root of context hierarchy<p>Results :<p>Tests run: 1, Failures: 0, Errors: 0, Skipped: 0<p>[INFO] \n[INFO] --- maven-war-plugin:2.6:war (default-war) @ view-demo ---\n[INFO] Packaging webapp\n[INFO] Assembling webapp [view-demo] in [/Users/Kevin/source/opencloud/view-demo/target/view-demo-0.0.1]\n[INFO] Processing war project\n[INFO] Copying webapp resources [/Users/Kevin/source/opencloud/view-demo/src/main/webapp]\n[INFO] Webapp assembled in [361 msecs]\n[INFO] Building war: /Users/Kevin/source/opencloud/view-demo/target/view-demo-0.0.1.war\n[INFO] \n[INFO] --- spring-boot-maven-plugin:1.4.7.RELEASE:repackage (default) @ view-demo ---\n[INFO] \n[INFO] --- dockerfile-maven-plugin:1.3.4:build (build-image) @ view-demo ---\n[INFO] Google Container Registry support is disabled\n[INFO] Building Docker context /Users/Kevin/source/opencloud/view-demo\n[INFO] \n[INFO] Image will be built as opencloudregistry.azurecr.io/clouddemo/view-demo:2\n[INFO] \n[INFO] Step 1/6 : FROM java:8\n[INFO] Pulling from library/java\n[INFO] Digest: sha256:c1ff613e8ba25833d2e1940da0940c3824f03f802c449f3d1815a66b7f8c0e9d\n[INFO] Status: Image is up to date for java:8\n[INFO]  ---&gt; d23bdf5b1b1b\n[INFO] Step 2/6 : VOLUME /tmp\n[INFO]  ---&gt; Using cache\n[INFO]  ---&gt; d7662a1cee77\n[INFO] Step 3/6 : ADD target/view-demo-0.0.1.war app.war\n[INFO]  ---&gt; fb5ba0dda896\n[INFO] Step 4/6 : ENV JAVA_OPTS \"\"\n[INFO]  ---&gt; Running in 29ff6523682b\n[INFO]  ---&gt; 7ff1eed623c5\n[INFO] Removing intermediate container 29ff6523682b\n[INFO] Step 5/6 : RUN bash -c 'touch /app.war'\n[INFO]  ---&gt; Running in 1d0725dc2a29\n[INFO]  ---&gt; 229230cd53ba\n[INFO] Removing intermediate container 1d0725dc2a29\n[INFO] Step 6/6 : ENTRYPOINT java -Djava.security.egd=file:/dev/./urandom -jar /app.war\n[INFO]  ---&gt; Running in dbff4c32c614\n[INFO]  ---&gt; dbdf6c3ac7fc\n[INFO] Removing intermediate container dbff4c32c614\n[INFO] Successfully built dbdf6c3ac7fc\n[INFO] Successfully tagged opencloudregistry.azurecr.io/clouddemo/view-demo:2\n[INFO] \n[INFO] Detected build of image with id dbdf6c3ac7fc\n[INFO] Building jar: /Users/Kevin/source/opencloud/view-demo/target/view-demo-0.0.1-docker-info.jar\n[INFO] Successfully built opencloudregistry.azurecr.io/clouddemo/view-demo:2\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 25.745 s\n[INFO] Finished at: 2017-11-22T15:52:53+09:00\n[INFO] Final Memory: 33M/384M\n[INFO] ------------------------------------------------------------------------\n</pre>\n<h4><a href=\"https://github.com/bang0124/view-demo/blob/master/docker-compose.yml\">Docker Compose</a></h4>\n마이크로서비스 아키텍쳐의 경우 테스트를 하려면 관련된 서비스가 모두 실행이 되어야 한다. 즉 연관된 도커 이미지가 한번에 실행되어야 내가 수정한 소스코드가 정상적으로 작동하는지 알 수 있다. docker 명령으로 하나씩 올려서 테스트 할 수 도 있지만 Docker Compose를 이용하면 쉽게 테스트 환경을 만들 수 있다. 여기에서는 view-demo 와 api-demo 두 개의 서비스를 한번에 올려서 테스트 하도록 Docker Compose를 구성했다. <a href=\"https://github.com/bang0124/view-demo/blob/master/docker-compose.yml\">docker-compose.yml</a> 파일의 내용은 아래와 같다.\n<pre class=\"prettyprint\">version: \"3.3\"\nservices:\n    view-demo:\n      image: opencloudregistry.azurecr.io/clouddemo/view-demo:1\n      container_name: view-demo\n      ports:\n        - \"443:8443\"\n    api-demo:\n      image: opencloudregistry.azurecr.io/clouddemo/api-demo:1\n      container_name: api-demo</pre>\n$ docker-compose up 명령을 실행해서 https://localost로 접속해서 테스트 할 수 있다.\n<pre class=\"prettyprint\">$ docker-compose up\nStarting view-demo ... \nStarting api-demo ... \nStarting api-demo\nStarting api-demo ... done\nAttaching to view-demo, api-demo\napi-demo     | \napi-demo     |   .   ____          _            __ _ _\napi-demo     |  /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\napi-demo     | ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\napi-demo     |  \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\napi-demo     |   '  |____| .__|_| |_|_| |_\\__, | / / / /\napi-demo     |  =========|_|==============|___/=/_/_/_/\napi-demo     |  :: Spring Boot ::        (v1.4.7.RELEASE)\napi-demo     | \nview-demo    | \nview-demo    |   .   ____          _            __ _ _\nview-demo    |  /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\nview-demo    | ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\nview-demo    |  \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\nview-demo    |   '  |____| .__|_| |_|_| |_\\__, | / / / /\nview-demo    |  =========|_|==============|___/=/_/_/_/\nview-demo    |  :: Spring Boot ::        (v1.4.7.RELEASE)\nview-demo    | \nview-demo    | 2017-11-22 07:00:07.288  INFO 1 --- [           main] com.aircuve.ViewPackageApplication       : Starting ViewPackageApplication v0.0.1 on a7a23f97ce7c with PID 1 (/app.war started by root in /)\nview-demo    | 2017-11-22 07:00:07.309 DEBUG 1 --- [           main] com.aircuve.ViewPackageApplication       : Running with Spring Boot v1.4.7.RELEASE, Spring v4.3.9.RELEASE\nview-demo    | 2017-11-22 07:00:07.310  INFO 1 --- [           main] com.aircuve.ViewPackageApplication       : No active profile set, falling back to default profiles: default\napi-demo     | 2017-11-22 07:00:07.357  INFO 1 --- [           main] com.aircuve.ApiPackageApplication        : Starting ApiPackageApplication v0.0.1 on 16b394d7ca29 with PID 1 (/app.war started by root in /)\napi-demo     | 2017-11-22 07:00:07.396  INFO 1 --- [           main] com.aircuve.ApiPackageApplication        : No active profile set, falling back to default profiles: default\nview-demo    | 2017-11-22 07:00:07.424  INFO 1 --- [           main] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@14899482: startup date [Wed Nov 22 07:00:07 UTC 2017]; root of context hierarchy<p>(중간생략 ...)<p>view-demo    | 2017-11-22 07:00:14.622  INFO 1 --- [           main] com.aircuve.ViewPackageApplication       : Started ViewPackageApplication in 8.298 seconds (JVM running for 9.362)\napi-demo     | 2017-11-22 07:00:14.713  INFO 1 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup\napi-demo     | 2017-11-22 07:00:14.842  INFO 1 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)\napi-demo     | 2017-11-22 07:00:14.850  INFO 1 --- [           main] com.aircuve.ApiPackageApplication        : Started ApiPackageApplication in 8.51 seconds (JVM running for 9.59)</pre>\n&nbsp;<p><img class=\"size-large wp-image-5427 aligncenter\" src=\"/content/images/2017/11/docker-compose-test-1024x649.jpg\" alt=\"\" width=\"640\" height=\"406\" />",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1511334838000,
                "created_by": 1,
                "updated_at": 1511334838000,
                "updated_by": 1,
                "published_at": 1511334838000,
                "published_by": 1
            },
            {
                "id": 5441,
                "title": "Azure Container Service (Kubernetes)와 DevOps 구현 사례 #3 - DevOps",
                "slug": "azure-container-service-kubernetes-devops-case-3-devops",
                "markdown": "마이크로소프트 아키텍쳐로 만들어진 애플리케이션을 개발하거나 SaaS 애플리케이션을 개발한다면 DevOps는 어쩌면 필수다. 개발자가 최신 소스를 소스 저장소에 올리면 자동으로 빌드를 하고 Unit 테스트 등 기본 테스트를 자동으로 진행하는 CI(Continuous Integration), 빌드가 성공하면 테스트 환경에 자동으로 배포가 되는 CD(Continuous Deployment) 가 없으면 실수가 많아지고 개발자가 코드에 집중하지 못하는 등 어려움이 많아진다.\n<h4>Visual Studio Team Services</h4>\n<a href=\"https://www.visualstudio.com/\">Visual Studio</a> 패밀리 중에 <a href=\"https://www.visualstudio.com/team-services/\">Visual Studio Team Services (VSTS)</a>가 있다. 기존 TFS (Team Foundation Server)의 클라우드 버전이고 가입하면 바로 쓸 수 있는 SaaS 서비스이다. 처음 5명에 대해서는 무료 사용이 가능하다. 가입을 하면 사이트가 하나 생기기 프로젝트를 만들수 있다. 사실 VSTS에는 소프트웨어 라이프사이클 전체를 관리할 수 있는 모든 기능이 있지만 여기서는 Build와 Release에 집중하겠다.\n<h4>Build 설정</h4>\n빌드는 개발자가 Github 마스터 브랜치에 소스를 커밋하면 시작하도록 설정할 수 있다. 즉 트리거링을 소스코드 커밋으로 할 수 있다. 빌드가 시작되면 3가지 작업을 수행하도록 설정해 놨다.\n<ol>\n \t<li><strong>Maven pom.xml</strong> : 로컬 개발할 때와 마찬가지로 maven 으로 빌드를 실행하고 이미지를 만든다.</li>\n \t<li><strong>Push an image</strong>: Private registry에 만든 이미지를 push (업로드) 한다.</li>\n \t<li><strong>Publish Artifact</strong>: kubcofig : Kubernetes 배포에 사용하는 <a href=\"https://github.com/bang0124/view-demo/blob/master/view-demo.yml\">view-demo.yaml</a> 파일을 VSTS에 업로드 해둔다.</li>\n</ol>\nVSTS의 특징이라면 UI를 통해서 설정을 직관적으로 할 수 있는 것이다. 필요한 작업을 하나 끌어다 한 단계씩 설정을 해나가면 실제 빌드 될 때 그대로 실행된다.\n\n<a href=\"/content/images/2017/11/vsts-build.jpg\"><img class=\"size-full wp-image-5444 aligncenter\" src=\"/content/images/2017/11/vsts-build.jpg\" alt=\"\" width=\"2444\" height=\"1616\" /></a>\n\n<a href=\"/content/images/2017/11/vsts-build-2.jpg\"><img class=\"alignnone size-full wp-image-5445\" src=\"/content/images/2017/11/vsts-build-2.jpg\" alt=\"\" width=\"2444\" height=\"1616\" /></a>\n\n<a href=\"/content/images/2017/11/vsts-build-3.jpg\"><img class=\"alignnone size-full wp-image-5446\" src=\"/content/images/2017/11/vsts-build-3.jpg\" alt=\"\" width=\"2444\" height=\"1616\" /></a>\n<h4>빌드 실행</h4>\n소스코드를 commit 하면 시작되도록 trigger를 설정해 놓았다. VSTS에서는 로그를 보면서 실행되는 내용을 확인 할 수 있다. 빌드는 Hosted Agent라는 빌드 머신에서 수행이 되는데 Hosted Agent는 VSTS가 제공하는 클라우드에 있는 빌드 머신이다. 여기에는 기본적인 개발환경이 설치되어 있지만 그 외에는 빈통이다. 따라서 제일 처음에 소스 저장소에서 소스를 가져온 후에 우리가 만들어 놓은 빌드 태스크를 하나씩 실행한다.\n\n빌드 결과 화면은 아래와 같다.\n\n<a href=\"/content/images/2017/11/vsts-build-result.jpg\"><img class=\"alignnone size-full wp-image-5447\" src=\"/content/images/2017/11/vsts-build-result.jpg\" alt=\"\" width=\"2444\" height=\"1616\" /></a>\n<h4>Release 설정</h4>\n빌드가 성공하면 개발/테스트 서버 환경에 배포를 자동으로 수행 할 수 있다. 릴리즈 작업은 하나만 설정해놨다. view-demo.yml 파일의 설정 그대로 Kubernetes 클러스터에 배포를 하는 작업이다.\n\n<a href=\"/content/images/2017/11/vsts-release.jpg\"><img class=\"size-full wp-image-5450 aligncenter\" src=\"/content/images/2017/11/vsts-release.jpg\" alt=\"\" width=\"2454\" height=\"1874\" /></a>\n\n릴리즈 실행 결과 로그파일을 볼 수 있다.\n\n<a href=\"/content/images/2017/11/vsts-release-result.jpg\"><img class=\"alignnone size-full wp-image-5451\" src=\"/content/images/2017/11/vsts-release-result.jpg\" alt=\"\" width=\"2812\" height=\"1850\" /></a>\n<h4><a href=\"https://github.com/bang0124/view-demo/blob/master/view-demo.yml\">view-demo.yml </a></h4>\n<pre class=\"prettyprint\">apiVersion: apps/v1beta1\nkind: Deployment\nmetadata:\n  name: view-demo\nspec:\n  replicas: 1\n  minReadySeconds: 30\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable:\n      maxSurge: 1\n  template:\n    metadata:\n      labels:\n        app: view-demo\n    spec:\n      #imagePullSecrets:\n      #  - name: \n      containers:\n      - name: view-demo\n        image: opencloudregistry.azurecr.io/clouddemo/view-demo:2\n        ports:\n        - containerPort: 8443\n        name : view-demo</pre>\nKubernetes 배포에 사용할 yaml 파일이다. replicas 의 숫자를 높이면 서비스 인스턴스가 늘어난다. RollingUpdate 를 하면 새 버전의 pod를 만들고 기존버전의 pod를 종료하는 식으로 업데이트가 되기 때문에 서비스가 정지되지 않고 업데이트 된다. 이 과정에서 minReadySeconds 만큼 기다리게 할 수 있다. 애플리케이션이 올라가는 시간만큼 기다리게 할 수 있다. 상세한 설정은 <a href=\"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/\">Kubernetes Deployment 문서</a>를 참조하기 바란다.\n\n개발자의 로컬 개발환경에서 테스트 완료된 코드는 소스 저장소로 커밋되고 다시 VSTS에서 빌드와 배포까지 자동화 할 수 있다. 이렇게 되면 개발자들은 코드에 집중 할 수 있게된다.",
                "html": "마이크로소프트 아키텍쳐로 만들어진 애플리케이션을 개발하거나 SaaS 애플리케이션을 개발한다면 DevOps는 어쩌면 필수다. 개발자가 최신 소스를 소스 저장소에 올리면 자동으로 빌드를 하고 Unit 테스트 등 기본 테스트를 자동으로 진행하는 CI(Continuous Integration), 빌드가 성공하면 테스트 환경에 자동으로 배포가 되는 CD(Continuous Deployment) 가 없으면 실수가 많아지고 개발자가 코드에 집중하지 못하는 등 어려움이 많아진다.\n<h4>Visual Studio Team Services</h4>\n<a href=\"https://www.visualstudio.com/\">Visual Studio</a> 패밀리 중에 <a href=\"https://www.visualstudio.com/team-services/\">Visual Studio Team Services (VSTS)</a>가 있다. 기존 TFS (Team Foundation Server)의 클라우드 버전이고 가입하면 바로 쓸 수 있는 SaaS 서비스이다. 처음 5명에 대해서는 무료 사용이 가능하다. 가입을 하면 사이트가 하나 생기기 프로젝트를 만들수 있다. 사실 VSTS에는 소프트웨어 라이프사이클 전체를 관리할 수 있는 모든 기능이 있지만 여기서는 Build와 Release에 집중하겠다.\n<h4>Build 설정</h4>\n빌드는 개발자가 Github 마스터 브랜치에 소스를 커밋하면 시작하도록 설정할 수 있다. 즉 트리거링을 소스코드 커밋으로 할 수 있다. 빌드가 시작되면 3가지 작업을 수행하도록 설정해 놨다.\n<ol>\n \t<li><strong>Maven pom.xml</strong> : 로컬 개발할 때와 마찬가지로 maven 으로 빌드를 실행하고 이미지를 만든다.</li>\n \t<li><strong>Push an image</strong>: Private registry에 만든 이미지를 push (업로드) 한다.</li>\n \t<li><strong>Publish Artifact</strong>: kubcofig : Kubernetes 배포에 사용하는 <a href=\"https://github.com/bang0124/view-demo/blob/master/view-demo.yml\">view-demo.yaml</a> 파일을 VSTS에 업로드 해둔다.</li>\n</ol>\nVSTS의 특징이라면 UI를 통해서 설정을 직관적으로 할 수 있는 것이다. 필요한 작업을 하나 끌어다 한 단계씩 설정을 해나가면 실제 빌드 될 때 그대로 실행된다.<p><a href=\"/content/images/2017/11/vsts-build.jpg\"><img class=\"size-full wp-image-5444 aligncenter\" src=\"/content/images/2017/11/vsts-build.jpg\" alt=\"\" width=\"2444\" height=\"1616\" /></a><p><a href=\"/content/images/2017/11/vsts-build-2.jpg\"><img class=\"alignnone size-full wp-image-5445\" src=\"/content/images/2017/11/vsts-build-2.jpg\" alt=\"\" width=\"2444\" height=\"1616\" /></a><p><a href=\"/content/images/2017/11/vsts-build-3.jpg\"><img class=\"alignnone size-full wp-image-5446\" src=\"/content/images/2017/11/vsts-build-3.jpg\" alt=\"\" width=\"2444\" height=\"1616\" /></a>\n<h4>빌드 실행</h4>\n소스코드를 commit 하면 시작되도록 trigger를 설정해 놓았다. VSTS에서는 로그를 보면서 실행되는 내용을 확인 할 수 있다. 빌드는 Hosted Agent라는 빌드 머신에서 수행이 되는데 Hosted Agent는 VSTS가 제공하는 클라우드에 있는 빌드 머신이다. 여기에는 기본적인 개발환경이 설치되어 있지만 그 외에는 빈통이다. 따라서 제일 처음에 소스 저장소에서 소스를 가져온 후에 우리가 만들어 놓은 빌드 태스크를 하나씩 실행한다.<p>빌드 결과 화면은 아래와 같다.<p><a href=\"/content/images/2017/11/vsts-build-result.jpg\"><img class=\"alignnone size-full wp-image-5447\" src=\"/content/images/2017/11/vsts-build-result.jpg\" alt=\"\" width=\"2444\" height=\"1616\" /></a>\n<h4>Release 설정</h4>\n빌드가 성공하면 개발/테스트 서버 환경에 배포를 자동으로 수행 할 수 있다. 릴리즈 작업은 하나만 설정해놨다. view-demo.yml 파일의 설정 그대로 Kubernetes 클러스터에 배포를 하는 작업이다.<p><a href=\"/content/images/2017/11/vsts-release.jpg\"><img class=\"size-full wp-image-5450 aligncenter\" src=\"/content/images/2017/11/vsts-release.jpg\" alt=\"\" width=\"2454\" height=\"1874\" /></a><p>릴리즈 실행 결과 로그파일을 볼 수 있다.<p><a href=\"/content/images/2017/11/vsts-release-result.jpg\"><img class=\"alignnone size-full wp-image-5451\" src=\"/content/images/2017/11/vsts-release-result.jpg\" alt=\"\" width=\"2812\" height=\"1850\" /></a>\n<h4><a href=\"https://github.com/bang0124/view-demo/blob/master/view-demo.yml\">view-demo.yml </a></h4>\n<pre class=\"prettyprint\">apiVersion: apps/v1beta1\nkind: Deployment\nmetadata:\n  name: view-demo\nspec:\n  replicas: 1\n  minReadySeconds: 30\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable:\n      maxSurge: 1\n  template:\n    metadata:\n      labels:\n        app: view-demo\n    spec:\n      #imagePullSecrets:\n      #  - name: \n      containers:\n      - name: view-demo\n        image: opencloudregistry.azurecr.io/clouddemo/view-demo:2\n        ports:\n        - containerPort: 8443\n        name : view-demo</pre>\nKubernetes 배포에 사용할 yaml 파일이다. replicas 의 숫자를 높이면 서비스 인스턴스가 늘어난다. RollingUpdate 를 하면 새 버전의 pod를 만들고 기존버전의 pod를 종료하는 식으로 업데이트가 되기 때문에 서비스가 정지되지 않고 업데이트 된다. 이 과정에서 minReadySeconds 만큼 기다리게 할 수 있다. 애플리케이션이 올라가는 시간만큼 기다리게 할 수 있다. 상세한 설정은 <a href=\"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/\">Kubernetes Deployment 문서</a>를 참조하기 바란다.<p>개발자의 로컬 개발환경에서 테스트 완료된 코드는 소스 저장소로 커밋되고 다시 VSTS에서 빌드와 배포까지 자동화 할 수 있다. 이렇게 되면 개발자들은 코드에 집중 할 수 있게된다.",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1511338684000,
                "created_by": 1,
                "updated_at": 1511338684000,
                "updated_by": 1,
                "published_at": 1511338684000,
                "published_by": 1
            },
            {
                "id": 5455,
                "title": "Open Cloud 2017 자료 공유",
                "slug": "open-cloud-2017",
                "markdown": "Microsoft Open Cloud 2017 행사에서 발표했던 내용 공유합니다.\n\n발표자: 마이크로소프트 오일석 부장, 에어큐브 방승호 선임\n\n발표자료 다운로드 : <a href=\"https://onedrive.live.com/view.aspx?cid=30a24ab895bc444f&amp;page=view&amp;resid=30A24AB895BC444F!2293&amp;parId=30A24AB895BC444F!127&amp;app=PowerPoint\">https://onedrive.live.com/view.aspx?cid=30a24ab895bc444f&amp;page=view&amp;resid=30A24AB895BC444F!2293&amp;parId=30A24AB895BC444F!127&amp;app=PowerPoint</a>\n\n발표에 사용된 상세 내용은 3개의 포스트로 정리했습니다. 도움이 되었으면 좋겠습니다.\n\n<a href=\"http://ilseokoh.com/2017/11/22/azure-container-service-kubernetes-devops-case-1/\">Azure Container Service (Kubernetes)와 DevOps 구현 사례 #1</a>\n\n<a href=\"http://ilseokoh.com/2017/11/22/azure-container-service-kubernetes-devops-case-1-local-dev-environment/\">Azure Container Service (Kubernetes)와 DevOps 구현 사례 #2 – 로컬 개발환경</a>\n\n<a href=\"http://ilseokoh.com/2017/11/22/azure-container-service-kubernetes-devops-case-3-devops/\">Azure Container Service (Kubernetes)와 DevOps 구현 사례 #3 – DevOps</a>\n\n<img class=\"alignnone size-large wp-image-5460\" src=\"/content/images/2017/11/088AB3A8-2D19-4496-93CB-6EB9CADD8CE6-1024x576.jpeg\" alt=\"\" width=\"640\" height=\"360\" />",
                "html": "Microsoft Open Cloud 2017 행사에서 발표했던 내용 공유합니다.<p>발표자: 마이크로소프트 오일석 부장, 에어큐브 방승호 선임<p>발표자료 다운로드 : <a href=\"https://onedrive.live.com/view.aspx?cid=30a24ab895bc444f&amp;page=view&amp;resid=30A24AB895BC444F!2293&amp;parId=30A24AB895BC444F!127&amp;app=PowerPoint\">https://onedrive.live.com/view.aspx?cid=30a24ab895bc444f&amp;page=view&amp;resid=30A24AB895BC444F!2293&amp;parId=30A24AB895BC444F!127&amp;app=PowerPoint</a><p>발표에 사용된 상세 내용은 3개의 포스트로 정리했습니다. 도움이 되었으면 좋겠습니다.<p><a href=\"http://ilseokoh.com/2017/11/22/azure-container-service-kubernetes-devops-case-1/\">Azure Container Service (Kubernetes)와 DevOps 구현 사례 #1</a><p><a href=\"http://ilseokoh.com/2017/11/22/azure-container-service-kubernetes-devops-case-1-local-dev-environment/\">Azure Container Service (Kubernetes)와 DevOps 구현 사례 #2 – 로컬 개발환경</a><p><a href=\"http://ilseokoh.com/2017/11/22/azure-container-service-kubernetes-devops-case-3-devops/\">Azure Container Service (Kubernetes)와 DevOps 구현 사례 #3 – DevOps</a><p><img class=\"alignnone size-large wp-image-5460\" src=\"/content/images/2017/11/088AB3A8-2D19-4496-93CB-6EB9CADD8CE6-1024x576.jpeg\" alt=\"\" width=\"640\" height=\"360\" />",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1511339576000,
                "created_by": 1,
                "updated_at": 1511339576000,
                "updated_by": 1,
                "published_at": 1511339576000,
                "published_by": 1
            },
            {
                "id": 5468,
                "title": "Azure CDN - DSA(Dynamic Site Acceleration) 동적 사이트 가속",
                "slug": "azure-cdn-dsadynamic-site-acceleration-dynamic-site-acceleration",
                "markdown": "CDN은 잘 변하지 않는 정적인(static) 컨텐츠를 사용자 가까운 캐싱서버에 캐싱해 놓고 사용자 요청이 있을 때 캐싱서버에서 컨텐츠를 가져가기 때문에 웹 사이트의 속도를 향상 시킬 수 있다. 정적인 컨텐츠는 이미지, 동영상, JavaScript, CSS 파일이다. 쇼핑카트 페이지 같은 동적인(Dynamic) 컨텐츠는 내용이 자꾸 변하기 때문에 전통적인 CDN의 도움을 받지 못한다. 하지만 지속적인 CDN의 기술 발전은 다양한 기술을 사용해서 동적인 컨텐츠도 빠르게 사용자에게 도달 하도록 돕고 있다. 그 중에 DSA(Dynamic Site Acceleration) 기능이 Azure CDN에 들어왔다.\n\nAzure CDN은 Akamai와 Verizon CDN을 선택할 수 있다. 자세한 내용은 \"<a href=\"http://ilseokoh.com/2016/11/23/azure-cdn-%ec%99%84%ec%a0%84%ec%a0%95%eb%b3%b5-1-%eb%a7%8c%eb%93%a4%ea%b8%b0/\">Azure CDN 완전정복</a>\" 시리즈를 참조바란다.\n\nDSA는 몇 가지 방법으로 동적 컨텐츠의 성능을 올려준다. <a href=\"https://docs.microsoft.com/ko-kr/azure/cdn/cdn-dynamic-site-acceleration\">상세 내용은 문서 참조</a>\n<ol>\n \t<li><strong>Route / network optimizations:</strong> 최적의 라우팅 경로를 BGP(경계 게이트웨이 프로토콜)를 통해서 찾아내서 가장 빠르고 안정적인 네트워크 경로(라우팅 경로)를 사용</li>\n \t<li><strong>TCP optimization:</strong> TCP의 기본 행동중에 Slow Start를 제거,  TCP Connection을 영구적인 커넥션(persistent connection)으로 유지, TCP packet parameters 튜닝(Akamai only) 기술을 사용하여 TCP 를 최적화\n\n<a href=\"/content/images/2017/11/tcp-slow.jpg\"><img class=\"wp-image-5473 size-full\" src=\"/content/images/2017/11/tcp-slow.jpg\" alt=\"\" width=\"1280\" height=\"720\" /></a> 그림은 TCP가 처음 3way 핸드쉐이크이크러러커넥션을을맺고고느린 시작으로로컨텐츠를 전송하는 방법에에대한 설명이다.</li>\n \t<li><strong>Resource prefetching (Akamai only):</strong> HTML 구문을 분석해서 이미지, CSS, Javascript 파일 같이 HTML에 포함된 리소스를 미리 캐싱해서 제공</li>\n \t<li><strong>Adaptive Image Compression (Akamai only):</strong> 모바일과 같이 네트워크가 느려지는 상황에서는 고해상도 JPEG 파일이 아닌 작은 이미지를 보내주는 기술</li>\n</ol>\n<h4><a href=\"https://azure.microsoft.com/ko-kr/pricing/details/cdn/\">DSA 가격 </a></h4>\nDSA의 가격이 정적인 컨텐츠에 대한 CDN 가격 보다 조금 비싸다.\n<h4>실제 적용 테스트</h4>\n테스트 해본 사이트는 Word Press 사이트인 본 블로그  사이트에 적용해봤다.\n\nAzure 포탈에서 CDN 끝점을 만들때 DSA를 적용하려면 아래 그림처럼 \"Optimized for\" 옵션을 \"Dynamic site acceleration\" 으로 설정한다. Route/ network optimization에서 Probe로 사용할 URL을 지정할 때 10KB 크기의 지워지지 않는 적당한 컨텐츠가 없어서 샘플파일을 다운받아 사이트에 업로드 후 적용했다.\n\n<a href=\"/content/images/2017/11/azure-cdn-dsa-create.jpg\"><img class=\"size-full wp-image-5474 aligncenter\" src=\"/content/images/2017/11/azure-cdn-dsa-create.jpg\" alt=\"\" width=\"2048\" height=\"1319\" /></a>\n\n사이트에 실제로 적용할 때는 Azure CDN에 <strong>두 개의 끝점(End Point)를 만들어서 정적인 컨텐츠와 동적인 컨텐츠에 대한 CDN 적용을 다르게 하는게 효율적이다</strong>.  아래 그림은 ilseokoh.azureedge.net은 DSA로 설정된 CDN 끝점이고, ilseokohstatic.azureedge.net은 일반 CDN 설정이다. 두 개 모두 DNS 관리 사이트에서 CNAME을 등록하고 Azure Portal에서 custom domain 설정을 했다.\n\n<a href=\"/content/images/2017/11/cdn-endpoint.jpg\"><img class=\"size-full wp-image-5471 aligncenter\" src=\"/content/images/2017/11/cdn-endpoint.jpg\" alt=\"\" width=\"2002\" height=\"1104\" /></a>\n\nWord Press에서 Static Contents에만 General web delivery 타입의 끝점을 적용하는 플러그인이 많다. 그 중에서 CDN Enabler 라는 플러그인을 적용해서 wp-content, wp-include 디렉토리에 들어있는 컨텐츠는 static.ilseokoh.com으로 요청하도록 설정했다.\n\n<a href=\"/content/images/2017/11/wordpress-cdn-enabler.jpg\"><img class=\"alignnone size-full wp-image-5472\" src=\"/content/images/2017/11/wordpress-cdn-enabler.jpg\" alt=\"\" width=\"1717\" height=\"1082\" /></a>\n\n적용 후 실제 http://dsa.ilseokoh.com/ 로 접속을 해서 테스트를 해보면 동적 컨텐츠인 홈페이지 등은 DSA가 적용된 dsa.ilseokoh.com 에서 컨텐츠를 가져오고 이미지 같은 정적인 컨텐츠는 static.ilseokoh.com 에서 가져온다.\n\n브라우저 캐싱을 꺼놓고 접속 해보니 체감 속도는 무척 빠르다. 실제 성능 측정을 객관적으로 할 자신은 없다.\n\n테스트를 마치고 설정을 모두 삭제했기 때문에 현재는 본 블로그에 CDN이 적용되지 않는다. CDN까지 적용할 만한 블로그는 아니다 ^^",
                "html": "CDN은 잘 변하지 않는 정적인(static) 컨텐츠를 사용자 가까운 캐싱서버에 캐싱해 놓고 사용자 요청이 있을 때 캐싱서버에서 컨텐츠를 가져가기 때문에 웹 사이트의 속도를 향상 시킬 수 있다. 정적인 컨텐츠는 이미지, 동영상, JavaScript, CSS 파일이다. 쇼핑카트 페이지 같은 동적인(Dynamic) 컨텐츠는 내용이 자꾸 변하기 때문에 전통적인 CDN의 도움을 받지 못한다. 하지만 지속적인 CDN의 기술 발전은 다양한 기술을 사용해서 동적인 컨텐츠도 빠르게 사용자에게 도달 하도록 돕고 있다. 그 중에 DSA(Dynamic Site Acceleration) 기능이 Azure CDN에 들어왔다.<p>Azure CDN은 Akamai와 Verizon CDN을 선택할 수 있다. 자세한 내용은 \"<a href=\"http://ilseokoh.com/2016/11/23/azure-cdn-%ec%99%84%ec%a0%84%ec%a0%95%eb%b3%b5-1-%eb%a7%8c%eb%93%a4%ea%b8%b0/\">Azure CDN 완전정복</a>\" 시리즈를 참조바란다.<p>DSA는 몇 가지 방법으로 동적 컨텐츠의 성능을 올려준다. <a href=\"https://docs.microsoft.com/ko-kr/azure/cdn/cdn-dynamic-site-acceleration\">상세 내용은 문서 참조</a>\n<ol>\n \t<li><strong>Route / network optimizations:</strong> 최적의 라우팅 경로를 BGP(경계 게이트웨이 프로토콜)를 통해서 찾아내서 가장 빠르고 안정적인 네트워크 경로(라우팅 경로)를 사용</li>\n \t<li><strong>TCP optimization:</strong> TCP의 기본 행동중에 Slow Start를 제거,  TCP Connection을 영구적인 커넥션(persistent connection)으로 유지, TCP packet parameters 튜닝(Akamai only) 기술을 사용하여 TCP 를 최적화<p><a href=\"/content/images/2017/11/tcp-slow.jpg\"><img class=\"wp-image-5473 size-full\" src=\"/content/images/2017/11/tcp-slow.jpg\" alt=\"\" width=\"1280\" height=\"720\" /></a> 그림은 TCP가 처음 3way 핸드쉐이크이크러러커넥션을을맺고고느린 시작으로로컨텐츠를 전송하는 방법에에대한 설명이다.</li>\n \t<li><strong>Resource prefetching (Akamai only):</strong> HTML 구문을 분석해서 이미지, CSS, Javascript 파일 같이 HTML에 포함된 리소스를 미리 캐싱해서 제공</li>\n \t<li><strong>Adaptive Image Compression (Akamai only):</strong> 모바일과 같이 네트워크가 느려지는 상황에서는 고해상도 JPEG 파일이 아닌 작은 이미지를 보내주는 기술</li>\n</ol>\n<h4><a href=\"https://azure.microsoft.com/ko-kr/pricing/details/cdn/\">DSA 가격 </a></h4>\nDSA의 가격이 정적인 컨텐츠에 대한 CDN 가격 보다 조금 비싸다.\n<h4>실제 적용 테스트</h4>\n테스트 해본 사이트는 Word Press 사이트인 본 블로그  사이트에 적용해봤다.<p>Azure 포탈에서 CDN 끝점을 만들때 DSA를 적용하려면 아래 그림처럼 \"Optimized for\" 옵션을 \"Dynamic site acceleration\" 으로 설정한다. Route/ network optimization에서 Probe로 사용할 URL을 지정할 때 10KB 크기의 지워지지 않는 적당한 컨텐츠가 없어서 샘플파일을 다운받아 사이트에 업로드 후 적용했다.<p><a href=\"/content/images/2017/11/azure-cdn-dsa-create.jpg\"><img class=\"size-full wp-image-5474 aligncenter\" src=\"/content/images/2017/11/azure-cdn-dsa-create.jpg\" alt=\"\" width=\"2048\" height=\"1319\" /></a><p>사이트에 실제로 적용할 때는 Azure CDN에 <strong>두 개의 끝점(End Point)를 만들어서 정적인 컨텐츠와 동적인 컨텐츠에 대한 CDN 적용을 다르게 하는게 효율적이다</strong>.  아래 그림은 ilseokoh.azureedge.net은 DSA로 설정된 CDN 끝점이고, ilseokohstatic.azureedge.net은 일반 CDN 설정이다. 두 개 모두 DNS 관리 사이트에서 CNAME을 등록하고 Azure Portal에서 custom domain 설정을 했다.<p><a href=\"/content/images/2017/11/cdn-endpoint.jpg\"><img class=\"size-full wp-image-5471 aligncenter\" src=\"/content/images/2017/11/cdn-endpoint.jpg\" alt=\"\" width=\"2002\" height=\"1104\" /></a><p>Word Press에서 Static Contents에만 General web delivery 타입의 끝점을 적용하는 플러그인이 많다. 그 중에서 CDN Enabler 라는 플러그인을 적용해서 wp-content, wp-include 디렉토리에 들어있는 컨텐츠는 static.ilseokoh.com으로 요청하도록 설정했다.<p><a href=\"/content/images/2017/11/wordpress-cdn-enabler.jpg\"><img class=\"alignnone size-full wp-image-5472\" src=\"/content/images/2017/11/wordpress-cdn-enabler.jpg\" alt=\"\" width=\"1717\" height=\"1082\" /></a><p>적용 후 실제 http://dsa.ilseokoh.com/ 로 접속을 해서 테스트를 해보면 동적 컨텐츠인 홈페이지 등은 DSA가 적용된 dsa.ilseokoh.com 에서 컨텐츠를 가져오고 이미지 같은 정적인 컨텐츠는 static.ilseokoh.com 에서 가져온다.<p>브라우저 캐싱을 꺼놓고 접속 해보니 체감 속도는 무척 빠르다. 실제 성능 측정을 객관적으로 할 자신은 없다.<p>테스트를 마치고 설정을 모두 삭제했기 때문에 현재는 본 블로그에 CDN이 적용되지 않는다. CDN까지 적용할 만한 블로그는 아니다 ^^",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1511512199000,
                "created_by": 1,
                "updated_at": 1511512199000,
                "updated_by": 1,
                "published_at": 1511512199000,
                "published_by": 1
            },
            {
                "id": 5488,
                "title": "Azure App Service - 문제진단 및 해결",
                "slug": "azure-app-service-diagonostic-trouble-shooting",
                "markdown": "\"[ALERT ACTIVATED] - Average Response Time GreaterThan 2 (Seconds) in the last 5 minutes\" 라는 제목의 이메일을 가끔 받는다. Azure가 보내준 이메일 이고 블로그를 운영하는 Azure Web App에 아래와 같은 알람 설정을 해놨기 때문에 받을 수 있다.\n\n<a href=\"/content/images/2017/11/azure-web-app-alert.jpg\"><img class=\"size-full wp-image-5490 aligncenter\" src=\"/content/images/2017/11/azure-web-app-alert.jpg\" alt=\"\" width=\"2126\" height=\"1222\" /></a>\n\n임계값 2초는 조금 짧은 감이 있지만 다른 문제는 없는지 살펴보고 싶다. 다행히 Azure Application Insight를 연결해놨기 때문에 여러가지 지표를 볼 수 있다. Azure Dash 보드에 필요한 내용들을 모아서 한눈에 볼 수 있도록 설정 해놨다. 별 문제는 없어보인다. 방문자도 별로 없고 ...\n\n<a href=\"/content/images/2017/11/azure-web-app-dashboard.jpg\"><img class=\"size-full wp-image-5491 aligncenter\" src=\"/content/images/2017/11/azure-web-app-dashboard.jpg\" alt=\"\" width=\"2560\" height=\"1380\" /></a>\n\n최근에 새로 업데이트 된 기능인 \"문제 진단 및 해결\" 메뉴에서 뭔가 문제를 발견할 수 있을까 살펴봤다. 처음 열어봤는데 채팅처럼 꾸며놨고 기본 헬스체크를 해줬다. Requests and Error / CPU / Memory / Performance 4가지 항목에 대한 내용을 볼 수 있다. 4XX 오류가 1건 보이지만 중요한 URL이 아니었다. 급히 살펴본 내용이고 크게 문제는 없어 보인다. 여기서는 문제점이 안보여서 해결 방안 추천 등을 볼 수 없었지만 <a href=\"https://channel9.msdn.com/Shows/Azure-Friday/Azure-App-Service-Diagnostic-and-Troubleshooting-Experience\">Azure Friday 동영상</a>에서는 문제가 있을 때의 데이터와 추천에 대한 내용을 볼 수 있다. Azure App Service는 내가 한 일이 적어도 많은 것을 되돌려준다.\n\n<a href=\"/content/images/2017/11/azure-web-app-diagonostics.jpg\"><img class=\"size-full wp-image-5492 aligncenter\" src=\"/content/images/2017/11/azure-web-app-diagonostics.jpg\" alt=\"\" width=\"2560\" height=\"1380\" /></a>\n\n&nbsp;",
                "html": "\"[ALERT ACTIVATED] - Average Response Time GreaterThan 2 (Seconds) in the last 5 minutes\" 라는 제목의 이메일을 가끔 받는다. Azure가 보내준 이메일 이고 블로그를 운영하는 Azure Web App에 아래와 같은 알람 설정을 해놨기 때문에 받을 수 있다.<p><a href=\"/content/images/2017/11/azure-web-app-alert.jpg\"><img class=\"size-full wp-image-5490 aligncenter\" src=\"/content/images/2017/11/azure-web-app-alert.jpg\" alt=\"\" width=\"2126\" height=\"1222\" /></a><p>임계값 2초는 조금 짧은 감이 있지만 다른 문제는 없는지 살펴보고 싶다. 다행히 Azure Application Insight를 연결해놨기 때문에 여러가지 지표를 볼 수 있다. Azure Dash 보드에 필요한 내용들을 모아서 한눈에 볼 수 있도록 설정 해놨다. 별 문제는 없어보인다. 방문자도 별로 없고 ...<p><a href=\"/content/images/2017/11/azure-web-app-dashboard.jpg\"><img class=\"size-full wp-image-5491 aligncenter\" src=\"/content/images/2017/11/azure-web-app-dashboard.jpg\" alt=\"\" width=\"2560\" height=\"1380\" /></a><p>최근에 새로 업데이트 된 기능인 \"문제 진단 및 해결\" 메뉴에서 뭔가 문제를 발견할 수 있을까 살펴봤다. 처음 열어봤는데 채팅처럼 꾸며놨고 기본 헬스체크를 해줬다. Requests and Error / CPU / Memory / Performance 4가지 항목에 대한 내용을 볼 수 있다. 4XX 오류가 1건 보이지만 중요한 URL이 아니었다. 급히 살펴본 내용이고 크게 문제는 없어 보인다. 여기서는 문제점이 안보여서 해결 방안 추천 등을 볼 수 없었지만 <a href=\"https://channel9.msdn.com/Shows/Azure-Friday/Azure-App-Service-Diagnostic-and-Troubleshooting-Experience\">Azure Friday 동영상</a>에서는 문제가 있을 때의 데이터와 추천에 대한 내용을 볼 수 있다. Azure App Service는 내가 한 일이 적어도 많은 것을 되돌려준다.<p><a href=\"/content/images/2017/11/azure-web-app-diagonostics.jpg\"><img class=\"size-full wp-image-5492 aligncenter\" src=\"/content/images/2017/11/azure-web-app-diagonostics.jpg\" alt=\"\" width=\"2560\" height=\"1380\" /></a><p>&nbsp;",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1511752712000,
                "created_by": 1,
                "updated_at": 1511752712000,
                "updated_by": 1,
                "published_at": 1511752712000,
                "published_by": 1
            },
            {
                "id": 5497,
                "title": "진에어 챗봇 서비스 - 제이드 출시",
                "slug": "jinair-chatbot-jaid",
                "markdown": "몇 달전에 진에어 팀과 함께 진행한 HackFest 가 있었다. 챗봇 개발을 위해 여러가지 적용해보는 내용이었고 3일 동안 할 수 있는 여러가지를 개발했었다. 관련된 내용은 <a href=\"https://microsoftapac.github.io/2017-05-26-jinair-kor.html\">\"진에어 고객지원 챗봇 서비스 구축\"</a> 에서 상세한 내용을 살펴볼 수 있다. 진에어 팀에서는 지속적으로 개발하고 개선해서 최근 진에어 챗봇 서비스 제이드를 출시했다. 항공사의 여러가지 업무중 챗봇으로 서비스 할 수 있는 내용을 잘 구현해 놓았다. 앞으로 계속 발전해서 사람이 되길 ...\n\n제이드가 해주는 기능은 크게 3가지\n<ul>\n \t<li>스케줄 조회, 출도착 조회</li>\n \t<li>예약 조회</li>\n \t<li>서비스 문의, Delight Message</li>\n</ul>\nFacebook 메신저와 Skype 채널에 배포되어 있다.\n\n<a href=\"/content/images/2017/11/jinair-jade-delight-message.png\"><img class=\"alignnone size-full wp-image-5498\" src=\"/content/images/2017/11/jinair-jade-delight-message.png\" alt=\"\" width=\"246\" height=\"437\" /></a> <a href=\"/content/images/2017/11/jinair-jade-faq.png\"><img class=\"alignnone size-full wp-image-5499\" src=\"/content/images/2017/11/jinair-jade-faq.png\" alt=\"\" width=\"246\" height=\"437\" /></a> <a href=\"/content/images/2017/11/jinair-jade-filght-info.png\"><img class=\"alignnone size-full wp-image-5500\" src=\"/content/images/2017/11/jinair-jade-filght-info.png\" alt=\"\" width=\"246\" height=\"437\" /></a>\n\n<a href=\"/content/images/2017/11/jinair-jade-reservation.png\"><img class=\"alignnone size-full wp-image-5501\" src=\"/content/images/2017/11/jinair-jade-reservation.png\" alt=\"\" width=\"245\" height=\"437\" /></a> <a href=\"/content/images/2017/11/jinair-jade-reservation-detail.png\"><img class=\"alignnone size-full wp-image-5502\" src=\"/content/images/2017/11/jinair-jade-reservation-detail.png\" alt=\"\" width=\"245\" height=\"437\" /></a> <a href=\"/content/images/2017/11/jinair-jade-schedule.png\"><img class=\"alignnone size-full wp-image-5503\" src=\"/content/images/2017/11/jinair-jade-schedule.png\" alt=\"\" width=\"246\" height=\"437\" /></a>",
                "html": "몇 달전에 진에어 팀과 함께 진행한 HackFest 가 있었다. 챗봇 개발을 위해 여러가지 적용해보는 내용이었고 3일 동안 할 수 있는 여러가지를 개발했었다. 관련된 내용은 <a href=\"https://microsoftapac.github.io/2017-05-26-jinair-kor.html\">\"진에어 고객지원 챗봇 서비스 구축\"</a> 에서 상세한 내용을 살펴볼 수 있다. 진에어 팀에서는 지속적으로 개발하고 개선해서 최근 진에어 챗봇 서비스 제이드를 출시했다. 항공사의 여러가지 업무중 챗봇으로 서비스 할 수 있는 내용을 잘 구현해 놓았다. 앞으로 계속 발전해서 사람이 되길 ...<p>제이드가 해주는 기능은 크게 3가지\n<ul>\n \t<li>스케줄 조회, 출도착 조회</li>\n \t<li>예약 조회</li>\n \t<li>서비스 문의, Delight Message</li>\n</ul>\nFacebook 메신저와 Skype 채널에 배포되어 있다.<p><a href=\"/content/images/2017/11/jinair-jade-delight-message.png\"><img class=\"alignnone size-full wp-image-5498\" src=\"/content/images/2017/11/jinair-jade-delight-message.png\" alt=\"\" width=\"246\" height=\"437\" /></a> <a href=\"/content/images/2017/11/jinair-jade-faq.png\"><img class=\"alignnone size-full wp-image-5499\" src=\"/content/images/2017/11/jinair-jade-faq.png\" alt=\"\" width=\"246\" height=\"437\" /></a> <a href=\"/content/images/2017/11/jinair-jade-filght-info.png\"><img class=\"alignnone size-full wp-image-5500\" src=\"/content/images/2017/11/jinair-jade-filght-info.png\" alt=\"\" width=\"246\" height=\"437\" /></a><p><a href=\"/content/images/2017/11/jinair-jade-reservation.png\"><img class=\"alignnone size-full wp-image-5501\" src=\"/content/images/2017/11/jinair-jade-reservation.png\" alt=\"\" width=\"245\" height=\"437\" /></a> <a href=\"/content/images/2017/11/jinair-jade-reservation-detail.png\"><img class=\"alignnone size-full wp-image-5502\" src=\"/content/images/2017/11/jinair-jade-reservation-detail.png\" alt=\"\" width=\"245\" height=\"437\" /></a> <a href=\"/content/images/2017/11/jinair-jade-schedule.png\"><img class=\"alignnone size-full wp-image-5503\" src=\"/content/images/2017/11/jinair-jade-schedule.png\" alt=\"\" width=\"246\" height=\"437\" /></a>",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1511843532000,
                "created_by": 1,
                "updated_at": 1511843532000,
                "updated_by": 1,
                "published_at": 1511843532000,
                "published_by": 1
            },
            {
                "id": 5508,
                "title": "Azure SQL Database 마이그레이션 툴 - Microsoft SQL Server Migration Assistant",
                "slug": "microsoft-sql-server-migration-assistant",
                "markdown": "요즘 On-prem 서버 또는 VM에 SQL Server를 설치해서 사용하시던 많은 분들이 Azure SQL Database로 이전하고 있다. 관리도 편하고 안정성과 속도도 좋기 때문에 클라우드로 이전할 때 가능하다면 Azure SQL Database를 검토한다. 이 때 <a href=\"https://www.microsoft.com/en-us/download/details.aspx?id=53595\">Microsoft SQL Server Migration Assistant</a> 툴을 사용하면 마이그레이션이 가능한지 확인을 하거나 (Assessment) 실제 스키마와 데이터를 마이그레이션(Migration) 할 수 있다.\n\nSQL Server와 Azure SQL Database는 대부분 호환되지만 클라우드와 On-Prem의 특성으로 인한 차이점이 존재한다. 예를들어 Azure SQL Database는 Windows Authentication을 지원하지 않는다. 마이그레이션도 MDF, LDF 파일을 사용할 수 없다. 따라서 이런 툴이 서비스를 지원하는 것이다. 앞으로 <a href=\"https://azure.microsoft.com/en-us/blog/put-your-databases-on-autopilot-with-a-lift-and-shift-to-azure-sql-database/\">Azure SQL Database Managed Instance</a>가 둘 사이의 차이점을 줄여줄 것이고,  <a href=\"https://azure.microsoft.com/ko-kr/services/database-migration/\">Azure SQL Migration Service</a> (Preview) 가 더 편리한 마이그레이션 환경을 제공할 것이다.\n\n툴은 총 6단계를 거치게 되는데 내부적으로는 아래 다이어그램처럼 작동한다.\n\n<a href=\"/content/images/2017/12/dma-process.jpg\"><img class=\"alignnone size-full wp-image-5510\" src=\"/content/images/2017/12/dma-process.jpg\" alt=\"\" width=\"1408\" height=\"942\" /></a>\n<h4>1.소스 데이터베이스 (Select Source)</h4>\n로컬에 있는 소스 데이터베이스의 AAKorea3 라는 데이터베이스를 선택.\n\n<a href=\"/content/images/2017/12/sql-database-migration-source.jpg\"><img class=\"size-full wp-image-5519 aligncenter\" src=\"/content/images/2017/12/sql-database-migration-source.jpg\" alt=\"\" width=\"1713\" height=\"979\" /></a>\n<h4>2. 타겟 데이터베이스 (Select Target)</h4>\n<a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-get-started-portal\">Azure 포탈을 통해서 미리 많들어 놓은 Azure SQL Database</a>를 선택. 여기서 SQL Database 의 방화벽에 작업하는 머신의 IP를 넣어야 접속 가능하다.\n\n<a href=\"/content/images/2017/12/sql-database-migration-target.jpg\"><img class=\"size-full wp-image-5520 aligncenter\" src=\"/content/images/2017/12/sql-database-migration-target.jpg\" alt=\"\" width=\"1713\" height=\"979\" /></a>\n<h4>3. 오브젝트 선택 (Select Object)</h4>\n이 단계에서 마이그레이션 오류나 경고를 볼 수 있다. 지금 테스트로 마이그레이션 하는 데이터베이스는 스키마가 단순하기도 하고 SQL Database의 여러가지 기능을 사용하지 않아서 오류가 보이지 않고 일반적인 경고만 몇 개 보이지만 상황에 따라서 오류가 있을 수 있고 적절한 조치를 해줘야 한다.\n\n여기서 발생한 경고는 \"중요! ntext, 텍스트, 및 이미지 데이터 형식은 나중 버전의 SQL Server에서 제거 됩니다. 향후 개발 작업에서는 이 데이터 형식을 사용하지 않도록 하고 현재 이 데이터 형식을 사용하는 응용 프로그램은 수정하세요. 대신 nvarchar(max), varchar(max)및 varbinary(max) 를 사용합니다.\" 이런 내용인데 이번에는 수정하지 않고 넘어가기로 한다.\n\n<a href=\"/content/images/2017/12/sql-database-migration-select-object.jpg\"><img class=\"size-full wp-image-5517 aligncenter\" src=\"/content/images/2017/12/sql-database-migration-select-object.jpg\" alt=\"\" width=\"1713\" height=\"979\" /></a>\n<h4>4. 스크립트 생성 (Script &amp; Deploy schema)</h4>\n마이그레이션을 위한 스크립트 생성\n\n<a href=\"/content/images/2017/12/sql-database-migration-redeploy.jpg\"><img class=\"alignnone size-full wp-image-5515\" src=\"/content/images/2017/12/sql-database-migration-redeploy.jpg\" alt=\"\" width=\"1713\" height=\"979\" /></a>\n<h4>5. 테이블 선택 (Select Table)</h4>\n마이그레이션 할 테이블 선택.\n\n<a href=\"/content/images/2017/12/sql-database-migration-select-tables.jpg\"><img class=\"size-full wp-image-5518 aligncenter\" src=\"/content/images/2017/12/sql-database-migration-select-tables.jpg\" alt=\"\" width=\"1713\" height=\"979\" /></a>\n\n6. 데이터 마이그레이션 (Migrate Data)\n\n데이터 이전을 해서 최종 마이그레이션 완료.\n\n<a href=\"/content/images/2017/12/sql-database-migration-migrate-data.jpg\"><img class=\"alignnone size-full wp-image-5514\" src=\"/content/images/2017/12/sql-database-migration-migrate-data.jpg\" alt=\"\" width=\"1713\" height=\"979\" /></a>\n\n여기까지 SQL Database (2012버전)에서 Azure SQL로 마이그레이션을 <a href=\"https://www.microsoft.com/en-us/download/details.aspx?id=53595\">Microsoft SQL Server Migration Assistant</a> 툴을 이용해서 해봤다. 스키마가 다르고 사용하는 기능이나 Query가 다르니 상황마다 오류나 가이드가 다를 것이고 실제 Application 을 붙여서 테스트 해야 될 것이다.\n\n다른 종류의 DBMS에서도도 Azure SQL Database로 마이그레이션 할 경우가 있는데 Migration Assistant 는 여러가지 버전이 있다.\n<ul>\n \t<li><a href=\"https://www.microsoft.com/en-us/download/details.aspx?id=54255\">SQL Server Migration Assistant for Access</a></li>\n \t<li><a href=\"https://www.microsoft.com/en-us/download/details.aspx?id=54254\">SQL Server Migration Assistant for DB2</a></li>\n \t<li><a href=\"https://www.microsoft.com/en-us/download/details.aspx?id=54257\">SQL Server Migration Assistant for MySQL</a></li>\n \t<li><a href=\"https://www.microsoft.com/en-us/download/details.aspx?id=54258\">SQL Server Migration Assistant for Oracle</a></li>\n \t<li><a href=\"https://www.microsoft.com/en-us/download/details.aspx?id=54256\">SQL Server Migration Assistant for SAP ASE</a></li>\n</ul>\n다음 포스트에서는 이중에서 MySQL에 대해서 테스트 해보자.",
                "html": "요즘 On-prem 서버 또는 VM에 SQL Server를 설치해서 사용하시던 많은 분들이 Azure SQL Database로 이전하고 있다. 관리도 편하고 안정성과 속도도 좋기 때문에 클라우드로 이전할 때 가능하다면 Azure SQL Database를 검토한다. 이 때 <a href=\"https://www.microsoft.com/en-us/download/details.aspx?id=53595\">Microsoft SQL Server Migration Assistant</a> 툴을 사용하면 마이그레이션이 가능한지 확인을 하거나 (Assessment) 실제 스키마와 데이터를 마이그레이션(Migration) 할 수 있다.<p>SQL Server와 Azure SQL Database는 대부분 호환되지만 클라우드와 On-Prem의 특성으로 인한 차이점이 존재한다. 예를들어 Azure SQL Database는 Windows Authentication을 지원하지 않는다. 마이그레이션도 MDF, LDF 파일을 사용할 수 없다. 따라서 이런 툴이 서비스를 지원하는 것이다. 앞으로 <a href=\"https://azure.microsoft.com/en-us/blog/put-your-databases-on-autopilot-with-a-lift-and-shift-to-azure-sql-database/\">Azure SQL Database Managed Instance</a>가 둘 사이의 차이점을 줄여줄 것이고,  <a href=\"https://azure.microsoft.com/ko-kr/services/database-migration/\">Azure SQL Migration Service</a> (Preview) 가 더 편리한 마이그레이션 환경을 제공할 것이다.<p>툴은 총 6단계를 거치게 되는데 내부적으로는 아래 다이어그램처럼 작동한다.<p><a href=\"/content/images/2017/12/dma-process.jpg\"><img class=\"alignnone size-full wp-image-5510\" src=\"/content/images/2017/12/dma-process.jpg\" alt=\"\" width=\"1408\" height=\"942\" /></a>\n<h4>1.소스 데이터베이스 (Select Source)</h4>\n로컬에 있는 소스 데이터베이스의 AAKorea3 라는 데이터베이스를 선택.<p><a href=\"/content/images/2017/12/sql-database-migration-source.jpg\"><img class=\"size-full wp-image-5519 aligncenter\" src=\"/content/images/2017/12/sql-database-migration-source.jpg\" alt=\"\" width=\"1713\" height=\"979\" /></a>\n<h4>2. 타겟 데이터베이스 (Select Target)</h4>\n<a href=\"https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-get-started-portal\">Azure 포탈을 통해서 미리 많들어 놓은 Azure SQL Database</a>를 선택. 여기서 SQL Database 의 방화벽에 작업하는 머신의 IP를 넣어야 접속 가능하다.<p><a href=\"/content/images/2017/12/sql-database-migration-target.jpg\"><img class=\"size-full wp-image-5520 aligncenter\" src=\"/content/images/2017/12/sql-database-migration-target.jpg\" alt=\"\" width=\"1713\" height=\"979\" /></a>\n<h4>3. 오브젝트 선택 (Select Object)</h4>\n이 단계에서 마이그레이션 오류나 경고를 볼 수 있다. 지금 테스트로 마이그레이션 하는 데이터베이스는 스키마가 단순하기도 하고 SQL Database의 여러가지 기능을 사용하지 않아서 오류가 보이지 않고 일반적인 경고만 몇 개 보이지만 상황에 따라서 오류가 있을 수 있고 적절한 조치를 해줘야 한다.<p>여기서 발생한 경고는 \"중요! ntext, 텍스트, 및 이미지 데이터 형식은 나중 버전의 SQL Server에서 제거 됩니다. 향후 개발 작업에서는 이 데이터 형식을 사용하지 않도록 하고 현재 이 데이터 형식을 사용하는 응용 프로그램은 수정하세요. 대신 nvarchar(max), varchar(max)및 varbinary(max) 를 사용합니다.\" 이런 내용인데 이번에는 수정하지 않고 넘어가기로 한다.<p><a href=\"/content/images/2017/12/sql-database-migration-select-object.jpg\"><img class=\"size-full wp-image-5517 aligncenter\" src=\"/content/images/2017/12/sql-database-migration-select-object.jpg\" alt=\"\" width=\"1713\" height=\"979\" /></a>\n<h4>4. 스크립트 생성 (Script &amp; Deploy schema)</h4>\n마이그레이션을 위한 스크립트 생성<p><a href=\"/content/images/2017/12/sql-database-migration-redeploy.jpg\"><img class=\"alignnone size-full wp-image-5515\" src=\"/content/images/2017/12/sql-database-migration-redeploy.jpg\" alt=\"\" width=\"1713\" height=\"979\" /></a>\n<h4>5. 테이블 선택 (Select Table)</h4>\n마이그레이션 할 테이블 선택.<p><a href=\"/content/images/2017/12/sql-database-migration-select-tables.jpg\"><img class=\"size-full wp-image-5518 aligncenter\" src=\"/content/images/2017/12/sql-database-migration-select-tables.jpg\" alt=\"\" width=\"1713\" height=\"979\" /></a><p>6. 데이터 마이그레이션 (Migrate Data)<p>데이터 이전을 해서 최종 마이그레이션 완료.<p><a href=\"/content/images/2017/12/sql-database-migration-migrate-data.jpg\"><img class=\"alignnone size-full wp-image-5514\" src=\"/content/images/2017/12/sql-database-migration-migrate-data.jpg\" alt=\"\" width=\"1713\" height=\"979\" /></a><p>여기까지 SQL Database (2012버전)에서 Azure SQL로 마이그레이션을 <a href=\"https://www.microsoft.com/en-us/download/details.aspx?id=53595\">Microsoft SQL Server Migration Assistant</a> 툴을 이용해서 해봤다. 스키마가 다르고 사용하는 기능이나 Query가 다르니 상황마다 오류나 가이드가 다를 것이고 실제 Application 을 붙여서 테스트 해야 될 것이다.<p>다른 종류의 DBMS에서도도 Azure SQL Database로 마이그레이션 할 경우가 있는데 Migration Assistant 는 여러가지 버전이 있다.\n<ul>\n \t<li><a href=\"https://www.microsoft.com/en-us/download/details.aspx?id=54255\">SQL Server Migration Assistant for Access</a></li>\n \t<li><a href=\"https://www.microsoft.com/en-us/download/details.aspx?id=54254\">SQL Server Migration Assistant for DB2</a></li>\n \t<li><a href=\"https://www.microsoft.com/en-us/download/details.aspx?id=54257\">SQL Server Migration Assistant for MySQL</a></li>\n \t<li><a href=\"https://www.microsoft.com/en-us/download/details.aspx?id=54258\">SQL Server Migration Assistant for Oracle</a></li>\n \t<li><a href=\"https://www.microsoft.com/en-us/download/details.aspx?id=54256\">SQL Server Migration Assistant for SAP ASE</a></li>\n</ul>\n다음 포스트에서는 이중에서 MySQL에 대해서 테스트 해보자.",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1512114351000,
                "created_by": 1,
                "updated_at": 1512114351000,
                "updated_by": 1,
                "published_at": 1512114351000,
                "published_by": 1
            },
            {
                "id": 5533,
                "title": "Azure Virtual Machine Scale Set #1 - 개요",
                "slug": "azure-virtual-machine-scale-set-1-introduction",
                "markdown": "같은 역할을 하는 VM이 수십, 수백대가 필요한 상황이 있을 수 있다. 규모가 큰 서비스 인프라를 운영하거나 또는 평소에는 2-3개의 VM으로 운영되다가 필요할 때 수십대의 VM으로 확장해서 사용해야하는 애플리케이션도 있다. 이렇게 VM의 개수가 많아지면 관리의 문제가 생긴다. 한꺼번에 만드는 건 Azure Poweshell이나 CLI를 통해서 한다고 하지만 VM 업데이트, 자동 확장(Auto Scale) 등 관리요소가 많아지고 스크립트도 많아진다. 이런 상황에 도움을 주기 위해 Azure Virtual Machine Scale Set(이하 VMSS)이 있다.\n\n어떤 때에  Scale In/Out이 쉬운 수십대의 VM을 사용하게 될까? Azure 의 어떤 서비스는 VMSS를 사용해서 만들어진다. PaaS 서비스를 구축하는데 VMSS 가 사용되는 경우도 있다. 여기에 몇 가지 예가 있다.\n<ul>\n \t<li>Azure Service Fabric 은 VMSS로 VM을 생성하여 클러스터를 만든다.</li>\n \t<li>Azure Batch 는 계산노드(Compute Node)를 VMSS 로 만든다.</li>\n \t<li><a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machines/linux/cloudfoundry-get-started\">Azure의 Pivotal Cloud Foundary</a>는 인프라를 생성할 때 VMSS를 사용한다.</li>\n \t<li>MRI 에서 나온 이미지를 VMSS를 사용하여 VM들을 Scale out 해서 처리하고 다시 자동으로 Scale In 하는 사례</li>\n \t<li>대용량의 데이터 분석을 위해 분석 VM 노드를 VMSS로 Scale Out/In을 처리</li>\n \t<li>게임서버를 테스트 하기 위한 클라이언트를 VMSS를 이용하여 VM 400대에서 수행</li>\n</ul>\n<h4>VMSS의 특징</h4>\n<ul>\n \t<li>최대 1000개의 VM 생성</li>\n \t<li>Custom VM을 이용하여 생성 가능 (Custom VM이미지의 경우 300대가 최대)</li>\n \t<li>서비스 중지 없이 업데이트 가능(Rolling Update)</li>\n \t<li>동적으로 VM 인스턴스 갯수를 관리하여 비용 절감</li>\n \t<li>Auto Scale: 특정 조건에서 VM 개수를 자동으로 증가/감소</li>\n \t<li>Azure Load Balancer와 통합 (100대 이하)</li>\n \t<li>VMSS 전체 VM을 대상으로 Auto Scale, 업데이트가 가능하다. 개별 VM을 새로운 이미지로 업데이트하거나 자동 크기조정을 할 수는 없다.</li>\n \t<li>Managed Disk를 사용하는 것이 유리하다.</li>\n</ul>\n<h4>Azure Portal에서 VMSS 생성</h4>\n<a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-portal-create\">Azure Portal에서 VMSS를 생성</a>할 수 있다. OS, 인스턴스 갯수(VM 갯수), 위치, ID/Pwd, 인스턴스 크기 등을 정해주면 만들 수 있다. 하지만 Portal UI에서는 Custom VM 이미지를 사용할 수 가 없고 세밀한 설정이 어렵다. <a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-create\">Powershell 또는 CLI로 스크립트를 이용하거나</a> <a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-deploy-scaling-app-template\">ARM Template</a>을 이용하는 것이 바람직하다.\n\n<a href=\"/content/images/2017/12/azure-vmss-portal.jpg\"><img class=\"alignnone size-full wp-image-5538\" src=\"/content/images/2017/12/azure-vmss-portal.jpg\" alt=\"\" width=\"1919\" height=\"1380\" /></a>\n<h4>100개 인스턴스가 넘는 크기 조정 사용</h4>\n<a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-placement-groups\">대규모 Virtual Machine Scale Sets와 작동</a> 문서에 잘 설명이 되어 있다. 100개 이하와 이상의 VMSS는 차이가 있다.\n\n100개 이하에서는 Load Balancer를 붙일 수 있고 Load Balancer를 설정하여 부하를 분산하고 Probe 설정을 통해 문제가 있는 VM에 로드를 주지 않을 수 있다. 100개 이하의 VM은 하나의 Placement Group 안에 배치되고 각각 5개의 Fault Domain / Update Domain 에 VM들이 배치된다.  LB는 표준크기를 사용할 수 있는데 표준 크기의 LB의 Back end pool 의 최대 크기가 100개라는 제약이 적용되기 때문이기도 하다.  Load Blancer가 붙어있고 Probe 설정이 되어 있어야 자동 Rolling Update가 가능하다.\n\n<img class=\"size-full wp-image-5540 aligncenter\" src=\"/content/images/2017/12/azure-vmss-placement-group.jpg\" alt=\"\" width=\"1275\" height=\"233\" />\n\n하지만 100대가 넘어가면 Placement Group이 여러개가 되고 Load Balancer를 붙일 수 없다. 최대 1000대의 VM이 생성되지만 내가 만든 Custom 이미지를 사용하는 경우 최대 300대까지 배포가 가능하다. 위 그림은 97대의 VM을 Load Balancer 없이 100대 이상 사용 옵션으로 만든 후의 배포 모습이다. 초록색 점이 VM 한대 인데 3개의 Placement Group이 만들어지고 VM이 적절히 분산되어 있다.\n\n100대 이상과 이하를 구분하여 생성할 때 스크립트에서 쓰는 스위치는 <em>singlePlacementGroup</em>  이다. True로 설정하면 100대 이하 False로 설정하면 100대 이상이고 False일 때 LB를 만들지 않아야 오류가 나지 않는다.\n\nVM의 생성은 병렬로 만들어 지기 때문에 빠르게 수백대의 VM을 생성할 수 있다.\n<h4>오버프로비전(OverProvisioning)</h4>\nVM을 만들어 내는 걸 Provisioning 한다고 한다. SSD 를 가진 하나의 VM은 99.5% 임을 알고 있을 것이다. 이걸 10대 생성한다면 (99.5%)^10 = 95%, 100대 생성한다면 (99.5%)^100 = 60% 로 SLA가 떨어진다. 계산이 그렇다는 것이다. VM 생성이 실패할 확률이 높아 진다는 얘기고 실제로 큰 문제가 발생하지는 않는다. 하지만 이를 보완할 필요가 있기 때문에 OverProvisioning을 한다. 만약 100대를 만든다면 경우에 따라 다르지만 120대를 생성요청하고 먼저 성공한 100대의 VM만 남기는 식이다. 이렇게 Provisioning의 실패율을 현저히 낮출 수 있다.  여기서 추가로 만들기 요청된 20 대에 대해서는 비용이 청구되지는 않는다. OverProvisioning은 기본값이 True로 되어 있고 끌 수도 있다. 아래 그림은 100대를 만들어야 하지만 OverProvisioning으로 110대가 만들어졌다.\n\nOverProvisioning 를 Off 로 설정해서 사용하지 않아야 하는 때는 어떤 상황일까? 구독의 Core 제약이 걸려서 추가로 VM이 설정되지 않거나 가상네트워크의 서브넷 개수가 적어서 추가 VM을 넣을 수 없는 경우 등이 그렇다.\n\n<img class=\"size-full wp-image-5541 aligncenter\" src=\"/content/images/2017/12/azure-vmss-overprovisioning.jpg\" alt=\"\" width=\"665\" height=\"246\" />\n<h4>Managed Disk 사용</h4>\nVMSS에서 Managed Disk를 사용하는 것이 유리하다. 100대 이상의 인스턴스를 만들 때는 반드시 Managed Disk를 사용해야 한다. Unmanaged Disk는 Storage Account를 만들어야하고 Storage Account는 자신의 네트워크 제약 때문에 최대 20대 이하의 VM 디스크를 넣어야 한다. Unmanaged Disk를 사용해도 VMSS가 알아서 Storage Account를 관리해주기는 하지만 굳이 Unmanaged Disk를 사용할 이유는 찾지 못하겠다.\n<h4>Custom VM의 생성</h4>\n여러대의 VM을 생성해서 내 인프라를 꾸미는데 아무것도 설치되지 않은 Windows Server 2016을 사용하고 100대를 하나씩 RDP로 들어가서 관리를 할 수 는 없다. 거의 불가능한 작업이고 실수를 할 위험이 있다. 따라서 자동으로 이 설정을 해줘야 한다. 두가지 방법이 있다. Custom Script Extension을 사용하는 방법이 있고 VM 이미지를 사용하는 방법이 있다.\n<h5>Custom Script Extension</h5>\nVM의 확장(Extension)이고 VM이 Provision 되면 설정된 스크립트를 다운받아서 실행한다. <a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machines/windows/extensions-customscript\">Windows VM이라면 PowerShell</a>, <a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machines/linux/extensions-customscript\">Linux</a>라면 Bash 스크립트를 실행하는 식이고 이 스크립트에서 해당 VM에 필요한 모든 미들웨어와 데이터, 내 Application을 설치하고 설정까지 자동으로 실행하는 것이다. 스크립트를 만드는데 노력이 들어가는 일이지만 VMSS의 최대값이 1000대까지 VM을 만들 수 있고 코드이기 때문에 업데이트와 관리가 쉽다.\n<h5>VM 이미지 사용</h5>\nVM을 하나 만들어서 필요한 모든 미들웨어와 Application을 설치한 후에 VM을 이미지로 만들고 VMSS 가 VM을 생성할 때 이 이미지를 사용하는 방법이다. 스크립트보다는 빠르게 적용할 수 있다. 다만 Applicsation의 업데이트가 있을 때 이미지를 다시 생성해야 한다. 이 부분을 어느정도 스크립트로 작성해 놓으면 좋다. 단점은 최대 300대까지만 생성이 가능하다.\n<h4>Azure 가상 네트워크</h4>\nVMSS가 VM을 생성하지만 그 VM들은 Azure의 가상네트워크의 하나의 Subnet 안에 모두 만들어진다. 여기서 주의할 것은 Subnet의 IP 갯수다. 300대를 만들어야 하는데 Subnet의 설정이 10.0.0.0/24 (256개 영역. 실제로는 251개 사용 가능)로 되어 있다면 오류가 발생한다. 따라서 가상네트워크를 미리 만들면서 네트워크 주소 범위와 서브넷을 잘 설정해놓고 VMSS를 만들 때 그 서브넷을 지정해서 만드는 게 실수를 줄여준다. Subnet의 IP 개수는 필요한 것 보다 약 20% 정도 더 여유를 둬야 하는데 이는 OverProvisioning을 생각해야 하기 때문이다.\n<h4>구독(Subscription)의 Core 수 제약</h4>\n구독은 기본값으로 20개의 Core 수 제약이 있다. 이는 어떤 실수로 인해 비용이 과다 청구되는 것을 막기 위한 제약이다. 하지만 VMSS를 쓰기로 했다면 20개의 Core 보다 더 많이 사용할 가능성이 있다. 따라서 코어 제약을 원하는 개수로 늘려놔야 한다.  <a href=\"http://ilseokoh.com/2017/12/10/azure-core-limit/\">Azure 구독의 코어수 제약 늘리기</a>를 참조해서 변경할 수 있다.",
                "html": "같은 역할을 하는 VM이 수십, 수백대가 필요한 상황이 있을 수 있다. 규모가 큰 서비스 인프라를 운영하거나 또는 평소에는 2-3개의 VM으로 운영되다가 필요할 때 수십대의 VM으로 확장해서 사용해야하는 애플리케이션도 있다. 이렇게 VM의 개수가 많아지면 관리의 문제가 생긴다. 한꺼번에 만드는 건 Azure Poweshell이나 CLI를 통해서 한다고 하지만 VM 업데이트, 자동 확장(Auto Scale) 등 관리요소가 많아지고 스크립트도 많아진다. 이런 상황에 도움을 주기 위해 Azure Virtual Machine Scale Set(이하 VMSS)이 있다.<p>어떤 때에  Scale In/Out이 쉬운 수십대의 VM을 사용하게 될까? Azure 의 어떤 서비스는 VMSS를 사용해서 만들어진다. PaaS 서비스를 구축하는데 VMSS 가 사용되는 경우도 있다. 여기에 몇 가지 예가 있다.\n<ul>\n \t<li>Azure Service Fabric 은 VMSS로 VM을 생성하여 클러스터를 만든다.</li>\n \t<li>Azure Batch 는 계산노드(Compute Node)를 VMSS 로 만든다.</li>\n \t<li><a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machines/linux/cloudfoundry-get-started\">Azure의 Pivotal Cloud Foundary</a>는 인프라를 생성할 때 VMSS를 사용한다.</li>\n \t<li>MRI 에서 나온 이미지를 VMSS를 사용하여 VM들을 Scale out 해서 처리하고 다시 자동으로 Scale In 하는 사례</li>\n \t<li>대용량의 데이터 분석을 위해 분석 VM 노드를 VMSS로 Scale Out/In을 처리</li>\n \t<li>게임서버를 테스트 하기 위한 클라이언트를 VMSS를 이용하여 VM 400대에서 수행</li>\n</ul>\n<h4>VMSS의 특징</h4>\n<ul>\n \t<li>최대 1000개의 VM 생성</li>\n \t<li>Custom VM을 이용하여 생성 가능 (Custom VM이미지의 경우 300대가 최대)</li>\n \t<li>서비스 중지 없이 업데이트 가능(Rolling Update)</li>\n \t<li>동적으로 VM 인스턴스 갯수를 관리하여 비용 절감</li>\n \t<li>Auto Scale: 특정 조건에서 VM 개수를 자동으로 증가/감소</li>\n \t<li>Azure Load Balancer와 통합 (100대 이하)</li>\n \t<li>VMSS 전체 VM을 대상으로 Auto Scale, 업데이트가 가능하다. 개별 VM을 새로운 이미지로 업데이트하거나 자동 크기조정을 할 수는 없다.</li>\n \t<li>Managed Disk를 사용하는 것이 유리하다.</li>\n</ul>\n<h4>Azure Portal에서 VMSS 생성</h4>\n<a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-portal-create\">Azure Portal에서 VMSS를 생성</a>할 수 있다. OS, 인스턴스 갯수(VM 갯수), 위치, ID/Pwd, 인스턴스 크기 등을 정해주면 만들 수 있다. 하지만 Portal UI에서는 Custom VM 이미지를 사용할 수 가 없고 세밀한 설정이 어렵다. <a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-create\">Powershell 또는 CLI로 스크립트를 이용하거나</a> <a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-deploy-scaling-app-template\">ARM Template</a>을 이용하는 것이 바람직하다.<p><a href=\"/content/images/2017/12/azure-vmss-portal.jpg\"><img class=\"alignnone size-full wp-image-5538\" src=\"/content/images/2017/12/azure-vmss-portal.jpg\" alt=\"\" width=\"1919\" height=\"1380\" /></a>\n<h4>100개 인스턴스가 넘는 크기 조정 사용</h4>\n<a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-placement-groups\">대규모 Virtual Machine Scale Sets와 작동</a> 문서에 잘 설명이 되어 있다. 100개 이하와 이상의 VMSS는 차이가 있다.<p>100개 이하에서는 Load Balancer를 붙일 수 있고 Load Balancer를 설정하여 부하를 분산하고 Probe 설정을 통해 문제가 있는 VM에 로드를 주지 않을 수 있다. 100개 이하의 VM은 하나의 Placement Group 안에 배치되고 각각 5개의 Fault Domain / Update Domain 에 VM들이 배치된다.  LB는 표준크기를 사용할 수 있는데 표준 크기의 LB의 Back end pool 의 최대 크기가 100개라는 제약이 적용되기 때문이기도 하다.  Load Blancer가 붙어있고 Probe 설정이 되어 있어야 자동 Rolling Update가 가능하다.<p><img class=\"size-full wp-image-5540 aligncenter\" src=\"/content/images/2017/12/azure-vmss-placement-group.jpg\" alt=\"\" width=\"1275\" height=\"233\" /><p>하지만 100대가 넘어가면 Placement Group이 여러개가 되고 Load Balancer를 붙일 수 없다. 최대 1000대의 VM이 생성되지만 내가 만든 Custom 이미지를 사용하는 경우 최대 300대까지 배포가 가능하다. 위 그림은 97대의 VM을 Load Balancer 없이 100대 이상 사용 옵션으로 만든 후의 배포 모습이다. 초록색 점이 VM 한대 인데 3개의 Placement Group이 만들어지고 VM이 적절히 분산되어 있다.<p>100대 이상과 이하를 구분하여 생성할 때 스크립트에서 쓰는 스위치는 <em>singlePlacementGroup</em>  이다. True로 설정하면 100대 이하 False로 설정하면 100대 이상이고 False일 때 LB를 만들지 않아야 오류가 나지 않는다.<p>VM의 생성은 병렬로 만들어 지기 때문에 빠르게 수백대의 VM을 생성할 수 있다.\n<h4>오버프로비전(OverProvisioning)</h4>\nVM을 만들어 내는 걸 Provisioning 한다고 한다. SSD 를 가진 하나의 VM은 99.5% 임을 알고 있을 것이다. 이걸 10대 생성한다면 (99.5%)^10 = 95%, 100대 생성한다면 (99.5%)^100 = 60% 로 SLA가 떨어진다. 계산이 그렇다는 것이다. VM 생성이 실패할 확률이 높아 진다는 얘기고 실제로 큰 문제가 발생하지는 않는다. 하지만 이를 보완할 필요가 있기 때문에 OverProvisioning을 한다. 만약 100대를 만든다면 경우에 따라 다르지만 120대를 생성요청하고 먼저 성공한 100대의 VM만 남기는 식이다. 이렇게 Provisioning의 실패율을 현저히 낮출 수 있다.  여기서 추가로 만들기 요청된 20 대에 대해서는 비용이 청구되지는 않는다. OverProvisioning은 기본값이 True로 되어 있고 끌 수도 있다. 아래 그림은 100대를 만들어야 하지만 OverProvisioning으로 110대가 만들어졌다.<p>OverProvisioning 를 Off 로 설정해서 사용하지 않아야 하는 때는 어떤 상황일까? 구독의 Core 제약이 걸려서 추가로 VM이 설정되지 않거나 가상네트워크의 서브넷 개수가 적어서 추가 VM을 넣을 수 없는 경우 등이 그렇다.<p><img class=\"size-full wp-image-5541 aligncenter\" src=\"/content/images/2017/12/azure-vmss-overprovisioning.jpg\" alt=\"\" width=\"665\" height=\"246\" />\n<h4>Managed Disk 사용</h4>\nVMSS에서 Managed Disk를 사용하는 것이 유리하다. 100대 이상의 인스턴스를 만들 때는 반드시 Managed Disk를 사용해야 한다. Unmanaged Disk는 Storage Account를 만들어야하고 Storage Account는 자신의 네트워크 제약 때문에 최대 20대 이하의 VM 디스크를 넣어야 한다. Unmanaged Disk를 사용해도 VMSS가 알아서 Storage Account를 관리해주기는 하지만 굳이 Unmanaged Disk를 사용할 이유는 찾지 못하겠다.\n<h4>Custom VM의 생성</h4>\n여러대의 VM을 생성해서 내 인프라를 꾸미는데 아무것도 설치되지 않은 Windows Server 2016을 사용하고 100대를 하나씩 RDP로 들어가서 관리를 할 수 는 없다. 거의 불가능한 작업이고 실수를 할 위험이 있다. 따라서 자동으로 이 설정을 해줘야 한다. 두가지 방법이 있다. Custom Script Extension을 사용하는 방법이 있고 VM 이미지를 사용하는 방법이 있다.\n<h5>Custom Script Extension</h5>\nVM의 확장(Extension)이고 VM이 Provision 되면 설정된 스크립트를 다운받아서 실행한다. <a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machines/windows/extensions-customscript\">Windows VM이라면 PowerShell</a>, <a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machines/linux/extensions-customscript\">Linux</a>라면 Bash 스크립트를 실행하는 식이고 이 스크립트에서 해당 VM에 필요한 모든 미들웨어와 데이터, 내 Application을 설치하고 설정까지 자동으로 실행하는 것이다. 스크립트를 만드는데 노력이 들어가는 일이지만 VMSS의 최대값이 1000대까지 VM을 만들 수 있고 코드이기 때문에 업데이트와 관리가 쉽다.\n<h5>VM 이미지 사용</h5>\nVM을 하나 만들어서 필요한 모든 미들웨어와 Application을 설치한 후에 VM을 이미지로 만들고 VMSS 가 VM을 생성할 때 이 이미지를 사용하는 방법이다. 스크립트보다는 빠르게 적용할 수 있다. 다만 Applicsation의 업데이트가 있을 때 이미지를 다시 생성해야 한다. 이 부분을 어느정도 스크립트로 작성해 놓으면 좋다. 단점은 최대 300대까지만 생성이 가능하다.\n<h4>Azure 가상 네트워크</h4>\nVMSS가 VM을 생성하지만 그 VM들은 Azure의 가상네트워크의 하나의 Subnet 안에 모두 만들어진다. 여기서 주의할 것은 Subnet의 IP 갯수다. 300대를 만들어야 하는데 Subnet의 설정이 10.0.0.0/24 (256개 영역. 실제로는 251개 사용 가능)로 되어 있다면 오류가 발생한다. 따라서 가상네트워크를 미리 만들면서 네트워크 주소 범위와 서브넷을 잘 설정해놓고 VMSS를 만들 때 그 서브넷을 지정해서 만드는 게 실수를 줄여준다. Subnet의 IP 개수는 필요한 것 보다 약 20% 정도 더 여유를 둬야 하는데 이는 OverProvisioning을 생각해야 하기 때문이다.\n<h4>구독(Subscription)의 Core 수 제약</h4>\n구독은 기본값으로 20개의 Core 수 제약이 있다. 이는 어떤 실수로 인해 비용이 과다 청구되는 것을 막기 위한 제약이다. 하지만 VMSS를 쓰기로 했다면 20개의 Core 보다 더 많이 사용할 가능성이 있다. 따라서 코어 제약을 원하는 개수로 늘려놔야 한다.  <a href=\"http://ilseokoh.com/2017/12/10/azure-core-limit/\">Azure 구독의 코어수 제약 늘리기</a>를 참조해서 변경할 수 있다.",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1512961347000,
                "created_by": 1,
                "updated_at": 1512961347000,
                "updated_by": 1,
                "published_at": 1512961347000,
                "published_by": 1
            },
            {
                "id": 5545,
                "title": "Azure 구독의 Core 수 제약 늘리기",
                "slug": "azure-core-limit",
                "markdown": "Azure 구독당 기본값으로 20개의 Core 수 제약이 있다. 이는 어떤 실수로 인해 과다한 사용량 청구를 막기위한 제약이다. 내 구독의 현재 상태를 보려면 구독 메뉴에서 사용량 및 할당량 메뉴에 들어가면 볼 수 있다.\n\n<img class=\"size-full wp-image-5546 aligncenter\" src=\"/content/images/2017/12/azure-quoat.jpg\" alt=\"\" width=\"2536\" height=\"1249\" />\n\n&nbsp;\n\n이 제약을 넘어서는 Core를 사용하려고 하면 이런 오류메시지를 만나게 된다.\n<blockquote>Operation results in exceeding quota limits of Core</blockquote>\n이 오류를 해결하기 위해서는 서비스 요청을 해서 제약을 풀어야 한다.\n<h5>1. 위 그림에서 \"증가요청\" 버튼을 누르거나 \"도움말 + 지원\" 메뉴에서 \"새 지원 요청\"을 누른다. 기본사항에 할당량 문제 유형, 구독, 코어, 지원 플랜을 선택한다.</h5>\n<img class=\"size-full wp-image-5547 aligncenter\" src=\"/content/images/2017/12/azure-core-support.jpg\" alt=\"\" width=\"1323\" height=\"908\" />\n<h5>2. 리소스 관리자 배포모델, 위치, 필요한 VM 시리즈를 선택</h5>\n<img class=\"size-full wp-image-5548 aligncenter\" src=\"/content/images/2017/12/azure-core-support2.jpg\" alt=\"\" width=\"1323\" height=\"908\" />\n<h5>3. 연락처 정보를 입력한다. 잠시후에 아래와 같은 이메일을 받을 수 있다.</h5>\n<img class=\"size-full wp-image-5550 aligncenter\" src=\"/content/images/2017/12/azure-core-support-email.jpg\" alt=\"\" width=\"1497\" height=\"1069\" />\n\n이제 마이크로소프트 기술지원 부서에서 할당량 요청에 대한 처리를 해주거나 연락을 취할 것이다.",
                "html": "Azure 구독당 기본값으로 20개의 Core 수 제약이 있다. 이는 어떤 실수로 인해 과다한 사용량 청구를 막기위한 제약이다. 내 구독의 현재 상태를 보려면 구독 메뉴에서 사용량 및 할당량 메뉴에 들어가면 볼 수 있다.<p><img class=\"size-full wp-image-5546 aligncenter\" src=\"/content/images/2017/12/azure-quoat.jpg\" alt=\"\" width=\"2536\" height=\"1249\" /><p>&nbsp;<p>이 제약을 넘어서는 Core를 사용하려고 하면 이런 오류메시지를 만나게 된다.\n<blockquote>Operation results in exceeding quota limits of Core</blockquote>\n이 오류를 해결하기 위해서는 서비스 요청을 해서 제약을 풀어야 한다.\n<h5>1. 위 그림에서 \"증가요청\" 버튼을 누르거나 \"도움말 + 지원\" 메뉴에서 \"새 지원 요청\"을 누른다. 기본사항에 할당량 문제 유형, 구독, 코어, 지원 플랜을 선택한다.</h5>\n<img class=\"size-full wp-image-5547 aligncenter\" src=\"/content/images/2017/12/azure-core-support.jpg\" alt=\"\" width=\"1323\" height=\"908\" />\n<h5>2. 리소스 관리자 배포모델, 위치, 필요한 VM 시리즈를 선택</h5>\n<img class=\"size-full wp-image-5548 aligncenter\" src=\"/content/images/2017/12/azure-core-support2.jpg\" alt=\"\" width=\"1323\" height=\"908\" />\n<h5>3. 연락처 정보를 입력한다. 잠시후에 아래와 같은 이메일을 받을 수 있다.</h5>\n<img class=\"size-full wp-image-5550 aligncenter\" src=\"/content/images/2017/12/azure-core-support-email.jpg\" alt=\"\" width=\"1497\" height=\"1069\" /><p>이제 마이크로소프트 기술지원 부서에서 할당량 요청에 대한 처리를 해주거나 연락을 취할 것이다.",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1512880606000,
                "created_by": 1,
                "updated_at": 1512880606000,
                "updated_by": 1,
                "published_at": 1512880606000,
                "published_by": 1
            },
            {
                "id": 5558,
                "title": "Azure Virtual Machine Scale Set #2 – Custom 이미지로 120대 만들기",
                "slug": "azure-virtual-machine-scale-set-2-120-instances",
                "markdown": "<a href=\"http://ilseokoh.com/2017/12/11/azure-virtual-machine-scale-set-1-introduction/\">Virtual Machine Scale Set(이하 VMSS)의 개요</a>에 대해서는 지난 포스트에 설명이 되어 있다. 여기서는 Azure CLI를 이용해서 실제로 VMSS를 만드는 방법에 대한 내용이다. Custom VM 이미지를 이용해서 VMSS의 VM들을 생성하기 위해서 이미지용 VM을 만들고 스크립트를 통해서 이미지를 만든다.\n\n전체 다이어그램은 아래 그림과 같다.\n\n<img class=\"size-full wp-image-5561 aligncenter\" src=\"/content/images/2017/12/vmss-architecture.jpg\" alt=\"\" width=\"1280\" height=\"720\" />\n<h4>1. VM 이미지 만들기</h4>\n<h5><a href=\"https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest\">1) Azure CLI 2.0 설치</a> 하고  <a href=\"https://docs.microsoft.com/ko-kr/cli/azure/authenticate-azure-cli?view=azure-cli-latest\">Azure 로그인</a>을 먼저한다.</h5>\n<pre class=\"prettyprint\">$ az login\nTo sign in, use a web browser to open the page https://aka.ms/devicelogin and enter the code G8R712ZTN6 to authenticate.</pre>\n<h5>2) 리소스 그룹을 2개 만든다.</h5>\n<pre class=\"prettyprint\">$ az group create --name VMSSImageGroup --location koreacentral\n\n$ az group create --name VMSSGroup --location koreacentral</pre>\n<h5>3) Portal 에서 이미지 생성용 VM을 생성하고 필요한 미들웨어나 Application을 설치 후 잘 작동하는지 확인한다.</h5>\n<h5>4) <a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machines/windows/classic/capture-image\">Windows의 경우 RDP 접속해서 sysprep 한다</a>. <a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machines/linux/capture-image\">리눅스의 경우 SSH로 접속해서 waagent 명령을 실행</a>한다.</h5>\n<h5>5) 이미지 생성용 VM을 Deallocate / Generalize 시키고 이미지를 생성한다.</h5>\n<pre class=\"prettyprint\">$ az vm deallocate -g VMSSImageGroup -n VMSSImageVM1\n\n$ az vm generalize -g VMSSImageGroup -n VMSSImageVM1\n\n$ az image create --name VMSSImage01 --resource-group VMSSImageGroup --source VMSSImageVM1</pre>\n<h5>6) 이미지 생성용 VM을 지운다.</h5>\n<pre class=\"prettyprint\">az vm delete -n VMSSImageVM1 -g VMSSImageGroup</pre>\n&nbsp;\n<h4>2. VMSS 생성</h4>\nVM들이 들어갈 가상네트워크를 먼저 만들고 방금 만든 이미지로 120개의 VM을 VMSS로 생성한다. 100개 이상의 VM은 Load Balancer를 붙이지 못하고 single-placement-group을 false로 설정하여 생성한다. 가상네트워크의 서브넷 IP 범위를 120개 보다 크게 넉넉히 잡아줘야 한다.\n<pre class=\"prettyprint\">$ az network vnet create --name VMSSVNet --resource-group VMSSGroup --location koreacentral --address-prefix 10.1.0.0/16 --subnet-name VMSSSubnet --subnet-prefix 10.1.0.0/22\n\n$ az vmss create --image /subscriptions/e4723bbb-cd59-41dc-86b7-2e239d536c04/resourceGroups/VMSSImageGroup/providers/Microsoft.Compute/images/VMSSImage0  \\\n                 --name TestVMSS --resource-group VMSSGroup --authentication-type password \\\n                 --admin-username kevinoh --admin-password '&lt;pasword&gt;' --single-placement-group false \\\n                 --load-balancer \"\" --vm-sku Standard_D1_v2 --instance-count 120 --vnet-name VMSSVNet \\\n                 --subnet VMSSSubnet --disable-overprovision</pre>\n명령에서 사용한 파라미터를 몇 가지 살펴보자.\n<ul>\n \t<li>image: 1에서 생성한 이미지를 포탈에서 보면 Resource ID가 있다. 리소스그룹이 같으면 이미지 이름을 써도 되지만 리소스그룹이 다르기 때문에 ID를 사용한다. Managed Image는 리소스 아이디, Unmanaged image는 Storage Account URL를 사용한다.</li>\n \t<li>name: VMSS이름</li>\n \t<li>resource-group: VMSS가 생성될 리소스그룹</li>\n \t<li>authntication-type: password 로 지정하여 ID/pwd를 입력한다.</li>\n \t<li>admin-username: admin id</li>\n \t<li>admin-password: admin pwd</li>\n \t<li>single-placement-group: 100개 이상을 만들기 위해서 false로 설정한다. 상세 설명은 <a href=\"http://ilseokoh.com/2017/12/11/azure-virtual-machine-scale-set-1-introduction/\">개요</a> 참조</li>\n \t<li>load-balancer: single-placement-group false이고 100개 이상을 만드려면 Load Balancer를 만들지 않아야 한다. \"\"로 명시하지 않으면 오류 발생</li>\n \t<li>vm-sku: VM 사이즈. 사이즈 선택을 위한 문자열은 <a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machines/windows/sizes-general\">가상 컴퓨터 크기 페이지</a> 참조</li>\n \t<li>instance-count: 생성할 VM 수</li>\n \t<li>vnet-name: 가상네트워크 이름</li>\n \t<li>subnet-name: 서브넷 이름</li>\n \t<li>disable-overprovision: 현재 사용중인 구독의 core limit이 100개로 설정되어 있어서 껐다.</li>\n</ul>\n그 외 상세한 파라미터는<a href=\"https://docs.microsoft.com/en-us/cli/azure/vmss?view=azure-cli-latest#az_vmss_scale\"> az vmss 커멘드 설명</a>을 참조\n\nAzure Portal에서 인스턴스를 확인하면 120개의 인스턴스가 생성된 것을 확인 할 수 있다.\n\n<a href=\"/content/images/2017/12/azure-vmss-after-update2.jpg\"><img class=\"size-full wp-image-5564 aligncenter\" src=\"/content/images/2017/12/azure-vmss-after-update2.jpg\" alt=\"\" width=\"1323\" height=\"908\" /></a>\n<h4>3. 인스턴스 갯수 늘리기/줄이기</h4>\n<pre class=\"prettyprint\"># 줄이기\naz vmss scale --resource-group VMSSGroup --name TestVMSS --new-capacity 3\n# 늘이기\naz vmss scale --resource-group VMSSGroup --name TestVMSS --new-capacity 120</pre>\n인스턴스 갯수를 늘리고 줄이는 명령이다.\n<h4>4. VM 업데이트</h4>\n운영을 하다보면 업데이트가 필요하다. VMSS 를 업데이트 하려면 먼저 VM이미지에서 다시 VM을 생성해서 업데이트를 하고 새로운 VM이미지를 만들어야 한다. VM 생성은 Portal에서 할 수 있고 아래 명령으로 VM을 다시 생성할 수 있다. 그리고 다시 1번을 수행해서 이미지를 생성한다.\n<pre class=\"prettyprint\">$ az vm create -n VMSSImageVM3 -g VMSSImageGroup --image VMSSImage01 --vnet-name VMSSI\nmageGroup-vnet --subnet default --authentication-type password --admin-username kevinoh --admin-password 'Kevin!3245678' --size Standard_DS1_v2</pre>\n새로 생성된 이미지 이름이 VMSSImage02라면 아래 명령으로 VMSS 의 이미지를 업데이트 할 수 있다. 그리고 전체 이미지를 즉시 업데이트 할 수 있다. instance-ids \"*\" 는 전체 업데이트고 인스턴스 아이디를 여러개씩 지정해서 업데이트 할 수도 있다. 100개 이상의 VM을 가지고 있고 Load Blancer가 없는 VMSS 구성은 Rolling Update가 지원되지 않는다. 반대의 경우라면 az vmss rolling-upgrade 명령을 살펴보기 바란다.\n<pre class=\"prettyprint\">$ az vmss update --resource-group VMSSTestGroup --name VMSSTest --set virtualMachineProfile.storageProfile.imageReference.id=/subscriptions/e47f23bb-cd59-41dc-86b7-2e239d536c04/resourceGroups/VMImageGroup/providers/Microsoft.Compute/images/VMSSImage02\n\n$ az vmss update-instances --resource-group VMSSGroup --name TestVMSS --instance-ids \"*\"</pre>\n이미지를 변경 후에 Azure Portal에서 인스턴스를 확인해보면 최신모델이 아니오로 표시된다. 업데이트에 성공하면 다시 예로 변경된다.\n<a href=\"/content/images/2017/12/azure-vmss-update.jpg\">\n<img class=\"size-full wp-image-5565 aligncenter\" src=\"/content/images/2017/12/azure-vmss-update.jpg\" alt=\"\" width=\"1329\" height=\"879\" /></a>\n<h4>5. VMSS Dashboard tool 을 사용하여 수동 Rolling Update</h4>\npython으로 만들어진 <a href=\"https://github.com/MurthyCloudConfigurations/vmssdashboard\">VMSS Dashboard tool</a> 이 있다. Github에서 소스를 다운로드 받아서 python vmsseditor.py 를 실행하면 툴이 실행된다. 이 툴을 이용하면 Fault Domain 별로 VM 업데이트를 수동으로 실행 할 수 있다. 만약 VM 이미지를 변경하고 서비스의 중단없이 업데이트를 하려면 Fault Domain 별로 업데이트를 수행하면 된다.\n\n<a href=\"/content/images/2017/12/azure-vmss-after-update3.jpg\"><img class=\"size-full wp-image-5567 aligncenter\" src=\"/content/images/2017/12/azure-vmss-after-update3.jpg\" alt=\"\" width=\"1302\" height=\"982\" /></a>\n\n&nbsp;",
                "html": "<a href=\"http://ilseokoh.com/2017/12/11/azure-virtual-machine-scale-set-1-introduction/\">Virtual Machine Scale Set(이하 VMSS)의 개요</a>에 대해서는 지난 포스트에 설명이 되어 있다. 여기서는 Azure CLI를 이용해서 실제로 VMSS를 만드는 방법에 대한 내용이다. Custom VM 이미지를 이용해서 VMSS의 VM들을 생성하기 위해서 이미지용 VM을 만들고 스크립트를 통해서 이미지를 만든다.<p>전체 다이어그램은 아래 그림과 같다.<p><img class=\"size-full wp-image-5561 aligncenter\" src=\"/content/images/2017/12/vmss-architecture.jpg\" alt=\"\" width=\"1280\" height=\"720\" />\n<h4>1. VM 이미지 만들기</h4>\n<h5><a href=\"https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest\">1) Azure CLI 2.0 설치</a> 하고  <a href=\"https://docs.microsoft.com/ko-kr/cli/azure/authenticate-azure-cli?view=azure-cli-latest\">Azure 로그인</a>을 먼저한다.</h5>\n<pre class=\"prettyprint\">$ az login\nTo sign in, use a web browser to open the page https://aka.ms/devicelogin and enter the code G8R712ZTN6 to authenticate.</pre>\n<h5>2) 리소스 그룹을 2개 만든다.</h5>\n<pre class=\"prettyprint\">$ az group create --name VMSSImageGroup --location koreacentral<p>$ az group create --name VMSSGroup --location koreacentral</pre>\n<h5>3) Portal 에서 이미지 생성용 VM을 생성하고 필요한 미들웨어나 Application을 설치 후 잘 작동하는지 확인한다.</h5>\n<h5>4) <a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machines/windows/classic/capture-image\">Windows의 경우 RDP 접속해서 sysprep 한다</a>. <a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machines/linux/capture-image\">리눅스의 경우 SSH로 접속해서 waagent 명령을 실행</a>한다.</h5>\n<h5>5) 이미지 생성용 VM을 Deallocate / Generalize 시키고 이미지를 생성한다.</h5>\n<pre class=\"prettyprint\">$ az vm deallocate -g VMSSImageGroup -n VMSSImageVM1<p>$ az vm generalize -g VMSSImageGroup -n VMSSImageVM1<p>$ az image create --name VMSSImage01 --resource-group VMSSImageGroup --source VMSSImageVM1</pre>\n<h5>6) 이미지 생성용 VM을 지운다.</h5>\n<pre class=\"prettyprint\">az vm delete -n VMSSImageVM1 -g VMSSImageGroup</pre>\n&nbsp;\n<h4>2. VMSS 생성</h4>\nVM들이 들어갈 가상네트워크를 먼저 만들고 방금 만든 이미지로 120개의 VM을 VMSS로 생성한다. 100개 이상의 VM은 Load Balancer를 붙이지 못하고 single-placement-group을 false로 설정하여 생성한다. 가상네트워크의 서브넷 IP 범위를 120개 보다 크게 넉넉히 잡아줘야 한다.\n<pre class=\"prettyprint\">$ az network vnet create --name VMSSVNet --resource-group VMSSGroup --location koreacentral --address-prefix 10.1.0.0/16 --subnet-name VMSSSubnet --subnet-prefix 10.1.0.0/22<p>$ az vmss create --image /subscriptions/e4723bbb-cd59-41dc-86b7-2e239d536c04/resourceGroups/VMSSImageGroup/providers/Microsoft.Compute/images/VMSSImage0  \\\n                 --name TestVMSS --resource-group VMSSGroup --authentication-type password \\\n                 --admin-username kevinoh --admin-password '&lt;pasword&gt;' --single-placement-group false \\\n                 --load-balancer \"\" --vm-sku Standard_D1_v2 --instance-count 120 --vnet-name VMSSVNet \\\n                 --subnet VMSSSubnet --disable-overprovision</pre>\n명령에서 사용한 파라미터를 몇 가지 살펴보자.\n<ul>\n \t<li>image: 1에서 생성한 이미지를 포탈에서 보면 Resource ID가 있다. 리소스그룹이 같으면 이미지 이름을 써도 되지만 리소스그룹이 다르기 때문에 ID를 사용한다. Managed Image는 리소스 아이디, Unmanaged image는 Storage Account URL를 사용한다.</li>\n \t<li>name: VMSS이름</li>\n \t<li>resource-group: VMSS가 생성될 리소스그룹</li>\n \t<li>authntication-type: password 로 지정하여 ID/pwd를 입력한다.</li>\n \t<li>admin-username: admin id</li>\n \t<li>admin-password: admin pwd</li>\n \t<li>single-placement-group: 100개 이상을 만들기 위해서 false로 설정한다. 상세 설명은 <a href=\"http://ilseokoh.com/2017/12/11/azure-virtual-machine-scale-set-1-introduction/\">개요</a> 참조</li>\n \t<li>load-balancer: single-placement-group false이고 100개 이상을 만드려면 Load Balancer를 만들지 않아야 한다. \"\"로 명시하지 않으면 오류 발생</li>\n \t<li>vm-sku: VM 사이즈. 사이즈 선택을 위한 문자열은 <a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machines/windows/sizes-general\">가상 컴퓨터 크기 페이지</a> 참조</li>\n \t<li>instance-count: 생성할 VM 수</li>\n \t<li>vnet-name: 가상네트워크 이름</li>\n \t<li>subnet-name: 서브넷 이름</li>\n \t<li>disable-overprovision: 현재 사용중인 구독의 core limit이 100개로 설정되어 있어서 껐다.</li>\n</ul>\n그 외 상세한 파라미터는<a href=\"https://docs.microsoft.com/en-us/cli/azure/vmss?view=azure-cli-latest#az_vmss_scale\"> az vmss 커멘드 설명</a>을 참조<p>Azure Portal에서 인스턴스를 확인하면 120개의 인스턴스가 생성된 것을 확인 할 수 있다.<p><a href=\"/content/images/2017/12/azure-vmss-after-update2.jpg\"><img class=\"size-full wp-image-5564 aligncenter\" src=\"/content/images/2017/12/azure-vmss-after-update2.jpg\" alt=\"\" width=\"1323\" height=\"908\" /></a>\n<h4>3. 인스턴스 갯수 늘리기/줄이기</h4>\n<pre class=\"prettyprint\"># 줄이기\naz vmss scale --resource-group VMSSGroup --name TestVMSS --new-capacity 3\n# 늘이기\naz vmss scale --resource-group VMSSGroup --name TestVMSS --new-capacity 120</pre>\n인스턴스 갯수를 늘리고 줄이는 명령이다.\n<h4>4. VM 업데이트</h4>\n운영을 하다보면 업데이트가 필요하다. VMSS 를 업데이트 하려면 먼저 VM이미지에서 다시 VM을 생성해서 업데이트를 하고 새로운 VM이미지를 만들어야 한다. VM 생성은 Portal에서 할 수 있고 아래 명령으로 VM을 다시 생성할 수 있다. 그리고 다시 1번을 수행해서 이미지를 생성한다.\n<pre class=\"prettyprint\">$ az vm create -n VMSSImageVM3 -g VMSSImageGroup --image VMSSImage01 --vnet-name VMSSI\nmageGroup-vnet --subnet default --authentication-type password --admin-username kevinoh --admin-password 'Kevin!3245678' --size Standard_DS1_v2</pre>\n새로 생성된 이미지 이름이 VMSSImage02라면 아래 명령으로 VMSS 의 이미지를 업데이트 할 수 있다. 그리고 전체 이미지를 즉시 업데이트 할 수 있다. instance-ids \"*\" 는 전체 업데이트고 인스턴스 아이디를 여러개씩 지정해서 업데이트 할 수도 있다. 100개 이상의 VM을 가지고 있고 Load Blancer가 없는 VMSS 구성은 Rolling Update가 지원되지 않는다. 반대의 경우라면 az vmss rolling-upgrade 명령을 살펴보기 바란다.\n<pre class=\"prettyprint\">$ az vmss update --resource-group VMSSTestGroup --name VMSSTest --set virtualMachineProfile.storageProfile.imageReference.id=/subscriptions/e47f23bb-cd59-41dc-86b7-2e239d536c04/resourceGroups/VMImageGroup/providers/Microsoft.Compute/images/VMSSImage02<p>$ az vmss update-instances --resource-group VMSSGroup --name TestVMSS --instance-ids \"*\"</pre>\n이미지를 변경 후에 Azure Portal에서 인스턴스를 확인해보면 최신모델이 아니오로 표시된다. 업데이트에 성공하면 다시 예로 변경된다.\n<a href=\"/content/images/2017/12/azure-vmss-update.jpg\">\n<img class=\"size-full wp-image-5565 aligncenter\" src=\"/content/images/2017/12/azure-vmss-update.jpg\" alt=\"\" width=\"1329\" height=\"879\" /></a>\n<h4>5. VMSS Dashboard tool 을 사용하여 수동 Rolling Update</h4>\npython으로 만들어진 <a href=\"https://github.com/MurthyCloudConfigurations/vmssdashboard\">VMSS Dashboard tool</a> 이 있다. Github에서 소스를 다운로드 받아서 python vmsseditor.py 를 실행하면 툴이 실행된다. 이 툴을 이용하면 Fault Domain 별로 VM 업데이트를 수동으로 실행 할 수 있다. 만약 VM 이미지를 변경하고 서비스의 중단없이 업데이트를 하려면 Fault Domain 별로 업데이트를 수행하면 된다.<p><a href=\"/content/images/2017/12/azure-vmss-after-update3.jpg\"><img class=\"size-full wp-image-5567 aligncenter\" src=\"/content/images/2017/12/azure-vmss-after-update3.jpg\" alt=\"\" width=\"1302\" height=\"982\" /></a><p>&nbsp;",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1512975694000,
                "created_by": 1,
                "updated_at": 1512975694000,
                "updated_by": 1,
                "published_at": 1512975694000,
                "published_by": 1
            },
            {
                "id": 5593,
                "title": "Azure Planned Maintenance 리부팅 동반",
                "slug": "azure-planned-maintenance",
                "markdown": "&nbsp;\n\nAzure Planned Maintenance(계획된 유지 관리)가 계획되어 있습니다. VM을 사용해서 서비스하고 있는 팀은 살펴볼 필요가 있습니다. 아래 날짜들은 변경될 가능성이 있습니다.\n<h4>Planned Maintenance(계획된 유지 관리)에 대하여</h4>\nAzure에서 사용하는 VM은 가상환경으로 Host 인프라 위에서 만들어지고 관리됩니다. Host 인프라의 안정성, 보안을 향상시키기 위해서 주기적으로 업데이트를 합니다. Host OS에 보안 업데이트나 기능 업그레이드, 펌웨어 업데이트 등의 업데이트가 있습니다. 이런 Planned Maintenance는 두가지 종류가 있습니다.\n<ul>\n \t<li><strong>리부팅 없는 Planned Maintenance:</strong> VM을 리부팅 하지 않아도 되는 업데이트입니다. 업데이트가 실행되면 몇 초 동안 VM이 멈추고(Freezing) 호스트 업데이트가 끝나면 바로 작동합니다. 최대 시간은 30초라고 되어 있는데 보통 5-15초 정도의 임팩트가 있습니다. 따라서 정말 중요한 워크로드(Mission Critical Workload)가 아니면 신경쓰지 않아도 자연스럽게 지나갈 수 있습니다. 여기서 그냥 지나가려면 리트라이(Retry) 로직이 중요할 수 있습니다. 예를들어 15초 멈춘다 해도 설정에 따라 Database 커넥션이 끊어지거나 TCP 커넥션이 끊어질 수 있습니다. 이때 애플리케이션의 Retry 로직이 작동하여 문제없이 다시 커넥션할 수 있어야 합니다.</li>\n \t<li><strong>리부팅을 동반하는 Planned Maintenance</strong>: VM 리부팅을 동반하는 업데이트 입니다. 신경써서 관리해야합니다. 이런 Planned Maintenance 는 공지도 나오고 알림도 받을 수 있습니다.</li>\n</ul>\n이번 Planned Maintenance 는 리부팅을 동반하는 업데이트 입니다. 지난 2016년 봄에 한번 있었고 이번에 또 계획되어 있습니다. Azure 팀은 일년에 한번 이하로 발생하도록 목표를 잡고 있습니다. 이번 Planned Maintenance 의 상세 내용에 설명 합니다.\n<h4>이번 Planned Maintenance 는</h4>\n<ul>\n \t<li><strong>리부팅 됩니다</strong>. (정확히는 Redeploy )</li>\n \t<li><strong>몇 분</strong> 걸릴 수도 있습니다.</li>\n \t<li>Host OS를 Windows Server 2016으로 업데이트 합니다. 여기서 Host OS와 내 VM의 OS가 헷갈리면 안됩니다. 내 VM의 OS는 그대로 유지 됩니다.</li>\n \t<li>그 동안 쌓여 있던 펌웨어 업데이트를 이번에 한꺼번에 합니다.</li>\n \t<li><strong>VM의 Temp Disk 는 지워집니다.</strong> (윈도우 서버의 경우 대걔 D: 드라이브, Linux의 경우 /dev/sdb1) OS 디스크나 Data Disk는 유지됩니다. 혹시 Temp Disk에 지워지면 안되는 내용을 쓰도록 설정되어 있다면 이번에 수정을 하는게 좋겠습니다.</li>\n \t<li>모든 VM이 대상이 되는 건 아닙니다. 최근 4-5개월 전에 만든 VM은 이미 업데이트된 Host에 만들어졌을 가능성이 있습니다. (확인은 일정이 시작된 후 아래 방법으로 가능)</li>\n \t<li>모든 지역이 한꺼번에 실행되는게 아니고 계획에 따라 몇 단계로 실행됩니다. 특히 데이터센터의 페어는 동시에 하지 않습니다. 예를들어 Korea Central 지역과 Korea South가 동시에 진행되지 않습니다.</li>\n</ul>\n<h4>이번 Planned Maintenance의 일정과 프로세스</h4>\n아래 날짜들은 변경될 가능성이 있습니다.\n<h5><strong>Step 1. 2018년 1월 2일에 시작 - 관리자에게 이메일이 발송될 예정</strong></h5>\nAzure 구독의 관리자(Admin)와 협력 관리자(Co-admin)에게 이메일이 발송됩니다. 현재 설정되어 있는 Admin 을 확인하거나 추가하려면 <a href=\"https://docs.microsoft.com/ko-kr/azure/billing/billing-add-change-azure-subscription-administrator#add-an-rbac-owner-admin-for-a-subscription-in-azure-portal\">Azure Portal에서 구독에 대한 RBAC 소유자 관리자 추가 문서</a>를 참조하시고 이메일을 받을 수 있는 상태인지 미리 살펴보는게 좋겠습니다. 앞으로 계속 주요 알림이 구독 관리자 이메일 주소로 전송됩니다.\n\n이메일 말고 Webhooks 나 SMS 도 지원하는데 한국 휴대폰 번호는 안됩니다. 혹시 Azure Logic App 을 사용하고 계신다면 <a href=\"https://docs.microsoft.com/ko-kr/azure/connectors/connectors-native-webhook\">Webhook 커넥터</a>를 이용해서 <a href=\"https://docs.microsoft.com/ko-kr/azure/connectors/connectors-create-api-slack\">슬랙 커넥터</a>로 연결시켜 슬랙에 꽂을 수도 있겠죠. Webhook 설정은 <a href=\"http://Windows 가상 컴퓨터에 대한 계획된 유지 관리 알림 처리\">Windows 가상컴퓨터에 대한 계획된 유지 관리 알림 처리 문서</a>를 참조 바랍니다.\n<h5>포털에서 확인하는 3가지 방법</h5>\n<strong>1. Azure 포탈의 \"도움말 + 지원 &gt; 계획된 유지 관리\" 메뉴에서 확인 할 수 있습니다. </strong>\n\n<a href=\"/content/images/2017/12/azure-planned-maintenance-menu.jpg\"><img class=\"size-full wp-image-5572 aligncenter\" src=\"/content/images/2017/12/azure-planned-maintenance-menu.jpg\" alt=\"\" width=\"1042\" height=\"691\" /></a>\n\n&nbsp;\n\n지금은 기간이 아니라서 내용이 없고 저도 한번도 본적이 없어서 동영상에서 캡쳐 했습니다. 이런식으로 계획된 VM들의 리스트를 볼 수 있습니다.\n\n<a href=\"/content/images/2017/12/portal-planned-maintenace.jpg\"><img class=\"size-full wp-image-5573 aligncenter\" src=\"/content/images/2017/12/portal-planned-maintenace.jpg\" alt=\"\" width=\"1910\" height=\"1004\" /></a>\n\n<strong>2. 포탈의 가상 컴퓨터 메뉴에서 확인 가능합니다. </strong>\n\n<a href=\"/content/images/2017/12/planned-maintenance-vm.png\"><img class=\"size-full wp-image-5618 aligncenter\" src=\"/content/images/2017/12/planned-maintenance-vm.png\" alt=\"\" width=\"1833\" height=\"1185\" /></a>\n\n<strong>3. Azure 포탈 가상컴퓨터에 들어가면 볼 수 있습니다. 특히 Step 2에서 설명할 직접 실행하기 버튼이 여기에 있습니다. </strong>\n\n<a href=\"/content/images/2017/12/planned-maintenance-vm-start.png\"><img class=\"size-full wp-image-5619 aligncenter\" src=\"/content/images/2017/12/planned-maintenance-vm-start.png\" alt=\"\" width=\"1832\" height=\"1185\" /></a>\n\n물론 <a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machines/linux/maintenance-notifications\">Azure CLI</a>, <a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machines/windows/maintenance-notifications#check-maintenance-status-using-powershell\">PowerShell</a> 을 사용해서 확인 할 수도 있습니다.\n<h5><strong>Step 2. 내가 직접 실행하는 기간(Proactive Window) 2018년 1월 2일부터 1월 9일까지 </strong></h5>\n내가 사용하는 VM들이 HA 구성이 잘 되어 있다면 직접 실행하지 않아도 Step 3에서 자연스럽게 되도록 그냥 둬도 됩니다. 사실 이렇게 되야죠. 가용성 집합(Availability Set)으로 묶여 있는 VM들의 경우 가능한 얘기 입니다. 하지만 여러가지 이유에서 HA 구성이 안되어 있거나 완벽하지 않을 수 있습니다. 예를들어 MySQL을 VM 1대(SSD 사용하면 SLA 99.5%)에 구성해서 사용하고 있는 경우가 그렇습니다.  여기에 그 외의 이유들이 몇 가지 있습니다.\n<ul>\n \t<li>리부팅이 되면 서비스를 수동으로 올려줘야 하는 경우. 또는 서비스들의 실행 순서가 있어서 사람이 확인하면서 해야 하는 경우</li>\n \t<li>서비스를 사용하는 고객에게 정확히  날짜와 시간을 공지하고 하고 싶은 경우</li>\n \t<li>미뤄놨던 윈도우 업데이트나 미들웨어 등의 같이 업데이트 하고 싶은 경우</li>\n \t<li>리부팅 후에 서비스가 올라와서 스스로 준비되는데 30분이 넘게 걸리는 경우 (아래 Step 3에서 자동으로 업데이트 될 때 가용성 집합이 Update Domain 하나가 끝나면 30분 기다려 주는 이유)</li>\n \t<li>그냥 내가 통제하는 상황에서 리부팅 하고 싶은 경우</li>\n</ul>\n굳이 신경쓰지 않아도 되는 경우도 있습니다.\n<ul>\n \t<li>개발용 QA 용이라서 리부팅되도 상관없는 경우</li>\n \t<li>자주 리부팅 하는 경우</li>\n \t<li>잠깐 쓰는 용도의 VM</li>\n</ul>\n<strong>기간중에 직접 실행하려면 위의 스크린 샷에서 보이는 \"<span style=\"color: #800000;\">Initiate Maintenance now</span>\" 버튼을 눌러서 실행합니다.</strong>\n\nCloud Service와 <a href=\"http://ilseokoh.com/2017/12/11/azure-virtual-machine-scale-set-1-introduction/\">VMSS(Virtual Machine Scale Set)</a>은 지원하지 않습니다.\n<h5><strong>Step 3. 직접 실행하지 않은 VM에 대한 실행 (Scheduled Maintenance) - 기간이 아직 정해지지 않음. </strong></h5>\nStep 2에서 직접 실행하지 않아서 남아있는 VM들은 이 기간 동안 자동으로 리부팅 되면서 업데이트 됩니다.  몇 분이 걸릴 수 있습니다. 역시 Temp Disk는 지워집니다. 가용성 집합을 사용한 경우 Update Domain 단위로 업데이트 됩니다. Update Domain 사이에는 30분의 시간을 기다려 줍니다.\n\n<a href=\"https://docs.microsoft.com/ko-kr/azure/best-practices-availability-paired-regions#what-are-paired-regions\">Region Pair</a> 는 동시에 업데이트 되지 않습니다.\n\n<a href=\"https://docs.microsoft.com/ko-kr/azure/best-practices-availability-paired-regions\">BCDR(Business continuity and disaster recovery)</a> 이 적용되어 있다면 더 안전하겠지만 몇 분안에 끝나는 업데이트에서 BCDR이 작동하는 것이 좋은지는 관리자의 판단이 필요할 것 같습니다.\n\n<strong>Scheduled Event(예정된 이벤트) 를 사용하여 대응하기 (현재 미리보기)</strong>\n\nScheduled Event를 걸어놓으면 실제 리부팅 되기 15분 전에 알림을 받을 수 있습니다. Scheduled Event를 이용해서 리부팅 전에 해야하는 작업 예를들어 Load Balancer의 백엔트 풀에서 제거, 백업 포인트, 커넥션 정리, Failover 실행 등의 작업을 미리 실행해 놓고 리부팅을 할 수 있습니다. 좀 더 고급스러운 접근 같습니다. 저도 적용해 보지는 않았지만 가용성 집합 내의 VM 하나가 폴링을 해서 이벤트를 캐치해야 하고 그 후 정리할 걸 정리하는 등 코드를 좀 짜줘야 할 것 같습니다. 자세한 내용은 문서와 <a href=\"https://channel9.msdn.com/Shows/Azure-Friday/Using-Azure-Scheduled-Events-to-Prepare-for-VM-Maintenance\">동영상</a> (데모 포함)참조 바랍니다.\n<h4>질문들</h4>\nStep 3에서 리부팅 시간을 미리 몇 일 또는 몇 시간 전에 알 수 있나요? 아니요 Scheduled Event를 이용해서 15분전에 알 수 있습니다.\n\nVM 말고 Azure Web App 같은 PaaS 서비스도 이번에 적용되나요? 아니요. PaaS 서비스는 별도 스케줄로 업데이트가 되고 대걔 임팩트가 없는 방향으로 진행됩니다. PaaS의 장점이라고 할 수 있습니다.\n\n&nbsp;\n\n아 왜 업데이트가 있어서 귀찮게 ... 생각할 수 도 있지만 보안이나 가용성이 더 좋아질다고 하니 기꺼이 또는 강제로 업데이트를 해야하겠습니다. 더 상세한 내용을 알고 싶으시면 아래 링크 확인 바랍니다.\n<ul>\n \t<li><a href=\"https://azure.microsoft.com/en-us/resources/videos/azure-friday-virtual-machine-planned-maintenance-rafalovich/\">Azure Friday 동영상</a></li>\n \t<li><a href=\"https://azure.microsoft.com/en-us/blog/a-new-planned-maintenance-experience-for-your-virtual-machines/?cdn=disable\">공식 블로그 포스트(영문)</a></li>\n \t<li><a href=\"https://myignite.microsoft.com/videos/57085\">이그나이트 동영상 (영문)</a></li>\n \t<li><a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machines/windows/maintenance-and-updates\">문서</a></li>\n</ul>",
                "html": "&nbsp;<p>Azure Planned Maintenance(계획된 유지 관리)가 계획되어 있습니다. VM을 사용해서 서비스하고 있는 팀은 살펴볼 필요가 있습니다. 아래 날짜들은 변경될 가능성이 있습니다.\n<h4>Planned Maintenance(계획된 유지 관리)에 대하여</h4>\nAzure에서 사용하는 VM은 가상환경으로 Host 인프라 위에서 만들어지고 관리됩니다. Host 인프라의 안정성, 보안을 향상시키기 위해서 주기적으로 업데이트를 합니다. Host OS에 보안 업데이트나 기능 업그레이드, 펌웨어 업데이트 등의 업데이트가 있습니다. 이런 Planned Maintenance는 두가지 종류가 있습니다.\n<ul>\n \t<li><strong>리부팅 없는 Planned Maintenance:</strong> VM을 리부팅 하지 않아도 되는 업데이트입니다. 업데이트가 실행되면 몇 초 동안 VM이 멈추고(Freezing) 호스트 업데이트가 끝나면 바로 작동합니다. 최대 시간은 30초라고 되어 있는데 보통 5-15초 정도의 임팩트가 있습니다. 따라서 정말 중요한 워크로드(Mission Critical Workload)가 아니면 신경쓰지 않아도 자연스럽게 지나갈 수 있습니다. 여기서 그냥 지나가려면 리트라이(Retry) 로직이 중요할 수 있습니다. 예를들어 15초 멈춘다 해도 설정에 따라 Database 커넥션이 끊어지거나 TCP 커넥션이 끊어질 수 있습니다. 이때 애플리케이션의 Retry 로직이 작동하여 문제없이 다시 커넥션할 수 있어야 합니다.</li>\n \t<li><strong>리부팅을 동반하는 Planned Maintenance</strong>: VM 리부팅을 동반하는 업데이트 입니다. 신경써서 관리해야합니다. 이런 Planned Maintenance 는 공지도 나오고 알림도 받을 수 있습니다.</li>\n</ul>\n이번 Planned Maintenance 는 리부팅을 동반하는 업데이트 입니다. 지난 2016년 봄에 한번 있었고 이번에 또 계획되어 있습니다. Azure 팀은 일년에 한번 이하로 발생하도록 목표를 잡고 있습니다. 이번 Planned Maintenance 의 상세 내용에 설명 합니다.\n<h4>이번 Planned Maintenance 는</h4>\n<ul>\n \t<li><strong>리부팅 됩니다</strong>. (정확히는 Redeploy )</li>\n \t<li><strong>몇 분</strong> 걸릴 수도 있습니다.</li>\n \t<li>Host OS를 Windows Server 2016으로 업데이트 합니다. 여기서 Host OS와 내 VM의 OS가 헷갈리면 안됩니다. 내 VM의 OS는 그대로 유지 됩니다.</li>\n \t<li>그 동안 쌓여 있던 펌웨어 업데이트를 이번에 한꺼번에 합니다.</li>\n \t<li><strong>VM의 Temp Disk 는 지워집니다.</strong> (윈도우 서버의 경우 대걔 D: 드라이브, Linux의 경우 /dev/sdb1) OS 디스크나 Data Disk는 유지됩니다. 혹시 Temp Disk에 지워지면 안되는 내용을 쓰도록 설정되어 있다면 이번에 수정을 하는게 좋겠습니다.</li>\n \t<li>모든 VM이 대상이 되는 건 아닙니다. 최근 4-5개월 전에 만든 VM은 이미 업데이트된 Host에 만들어졌을 가능성이 있습니다. (확인은 일정이 시작된 후 아래 방법으로 가능)</li>\n \t<li>모든 지역이 한꺼번에 실행되는게 아니고 계획에 따라 몇 단계로 실행됩니다. 특히 데이터센터의 페어는 동시에 하지 않습니다. 예를들어 Korea Central 지역과 Korea South가 동시에 진행되지 않습니다.</li>\n</ul>\n<h4>이번 Planned Maintenance의 일정과 프로세스</h4>\n아래 날짜들은 변경될 가능성이 있습니다.\n<h5><strong>Step 1. 2018년 1월 2일에 시작 - 관리자에게 이메일이 발송될 예정</strong></h5>\nAzure 구독의 관리자(Admin)와 협력 관리자(Co-admin)에게 이메일이 발송됩니다. 현재 설정되어 있는 Admin 을 확인하거나 추가하려면 <a href=\"https://docs.microsoft.com/ko-kr/azure/billing/billing-add-change-azure-subscription-administrator#add-an-rbac-owner-admin-for-a-subscription-in-azure-portal\">Azure Portal에서 구독에 대한 RBAC 소유자 관리자 추가 문서</a>를 참조하시고 이메일을 받을 수 있는 상태인지 미리 살펴보는게 좋겠습니다. 앞으로 계속 주요 알림이 구독 관리자 이메일 주소로 전송됩니다.<p>이메일 말고 Webhooks 나 SMS 도 지원하는데 한국 휴대폰 번호는 안됩니다. 혹시 Azure Logic App 을 사용하고 계신다면 <a href=\"https://docs.microsoft.com/ko-kr/azure/connectors/connectors-native-webhook\">Webhook 커넥터</a>를 이용해서 <a href=\"https://docs.microsoft.com/ko-kr/azure/connectors/connectors-create-api-slack\">슬랙 커넥터</a>로 연결시켜 슬랙에 꽂을 수도 있겠죠. Webhook 설정은 <a href=\"http://Windows 가상 컴퓨터에 대한 계획된 유지 관리 알림 처리\">Windows 가상컴퓨터에 대한 계획된 유지 관리 알림 처리 문서</a>를 참조 바랍니다.\n<h5>포털에서 확인하는 3가지 방법</h5>\n<strong>1. Azure 포탈의 \"도움말 + 지원 &gt; 계획된 유지 관리\" 메뉴에서 확인 할 수 있습니다. </strong><p><a href=\"/content/images/2017/12/azure-planned-maintenance-menu.jpg\"><img class=\"size-full wp-image-5572 aligncenter\" src=\"/content/images/2017/12/azure-planned-maintenance-menu.jpg\" alt=\"\" width=\"1042\" height=\"691\" /></a><p>&nbsp;<p>지금은 기간이 아니라서 내용이 없고 저도 한번도 본적이 없어서 동영상에서 캡쳐 했습니다. 이런식으로 계획된 VM들의 리스트를 볼 수 있습니다.<p><a href=\"/content/images/2017/12/portal-planned-maintenace.jpg\"><img class=\"size-full wp-image-5573 aligncenter\" src=\"/content/images/2017/12/portal-planned-maintenace.jpg\" alt=\"\" width=\"1910\" height=\"1004\" /></a><p><strong>2. 포탈의 가상 컴퓨터 메뉴에서 확인 가능합니다. </strong><p><a href=\"/content/images/2017/12/planned-maintenance-vm.png\"><img class=\"size-full wp-image-5618 aligncenter\" src=\"/content/images/2017/12/planned-maintenance-vm.png\" alt=\"\" width=\"1833\" height=\"1185\" /></a><p><strong>3. Azure 포탈 가상컴퓨터에 들어가면 볼 수 있습니다. 특히 Step 2에서 설명할 직접 실행하기 버튼이 여기에 있습니다. </strong><p><a href=\"/content/images/2017/12/planned-maintenance-vm-start.png\"><img class=\"size-full wp-image-5619 aligncenter\" src=\"/content/images/2017/12/planned-maintenance-vm-start.png\" alt=\"\" width=\"1832\" height=\"1185\" /></a><p>물론 <a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machines/linux/maintenance-notifications\">Azure CLI</a>, <a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machines/windows/maintenance-notifications#check-maintenance-status-using-powershell\">PowerShell</a> 을 사용해서 확인 할 수도 있습니다.\n<h5><strong>Step 2. 내가 직접 실행하는 기간(Proactive Window) 2018년 1월 2일부터 1월 9일까지 </strong></h5>\n내가 사용하는 VM들이 HA 구성이 잘 되어 있다면 직접 실행하지 않아도 Step 3에서 자연스럽게 되도록 그냥 둬도 됩니다. 사실 이렇게 되야죠. 가용성 집합(Availability Set)으로 묶여 있는 VM들의 경우 가능한 얘기 입니다. 하지만 여러가지 이유에서 HA 구성이 안되어 있거나 완벽하지 않을 수 있습니다. 예를들어 MySQL을 VM 1대(SSD 사용하면 SLA 99.5%)에 구성해서 사용하고 있는 경우가 그렇습니다.  여기에 그 외의 이유들이 몇 가지 있습니다.\n<ul>\n \t<li>리부팅이 되면 서비스를 수동으로 올려줘야 하는 경우. 또는 서비스들의 실행 순서가 있어서 사람이 확인하면서 해야 하는 경우</li>\n \t<li>서비스를 사용하는 고객에게 정확히  날짜와 시간을 공지하고 하고 싶은 경우</li>\n \t<li>미뤄놨던 윈도우 업데이트나 미들웨어 등의 같이 업데이트 하고 싶은 경우</li>\n \t<li>리부팅 후에 서비스가 올라와서 스스로 준비되는데 30분이 넘게 걸리는 경우 (아래 Step 3에서 자동으로 업데이트 될 때 가용성 집합이 Update Domain 하나가 끝나면 30분 기다려 주는 이유)</li>\n \t<li>그냥 내가 통제하는 상황에서 리부팅 하고 싶은 경우</li>\n</ul>\n굳이 신경쓰지 않아도 되는 경우도 있습니다.\n<ul>\n \t<li>개발용 QA 용이라서 리부팅되도 상관없는 경우</li>\n \t<li>자주 리부팅 하는 경우</li>\n \t<li>잠깐 쓰는 용도의 VM</li>\n</ul>\n<strong>기간중에 직접 실행하려면 위의 스크린 샷에서 보이는 \"<span style=\"color: #800000;\">Initiate Maintenance now</span>\" 버튼을 눌러서 실행합니다.</strong><p>Cloud Service와 <a href=\"http://ilseokoh.com/2017/12/11/azure-virtual-machine-scale-set-1-introduction/\">VMSS(Virtual Machine Scale Set)</a>은 지원하지 않습니다.\n<h5><strong>Step 3. 직접 실행하지 않은 VM에 대한 실행 (Scheduled Maintenance) - 기간이 아직 정해지지 않음. </strong></h5>\nStep 2에서 직접 실행하지 않아서 남아있는 VM들은 이 기간 동안 자동으로 리부팅 되면서 업데이트 됩니다.  몇 분이 걸릴 수 있습니다. 역시 Temp Disk는 지워집니다. 가용성 집합을 사용한 경우 Update Domain 단위로 업데이트 됩니다. Update Domain 사이에는 30분의 시간을 기다려 줍니다.<p><a href=\"https://docs.microsoft.com/ko-kr/azure/best-practices-availability-paired-regions#what-are-paired-regions\">Region Pair</a> 는 동시에 업데이트 되지 않습니다.<p><a href=\"https://docs.microsoft.com/ko-kr/azure/best-practices-availability-paired-regions\">BCDR(Business continuity and disaster recovery)</a> 이 적용되어 있다면 더 안전하겠지만 몇 분안에 끝나는 업데이트에서 BCDR이 작동하는 것이 좋은지는 관리자의 판단이 필요할 것 같습니다.<p><strong>Scheduled Event(예정된 이벤트) 를 사용하여 대응하기 (현재 미리보기)</strong><p>Scheduled Event를 걸어놓으면 실제 리부팅 되기 15분 전에 알림을 받을 수 있습니다. Scheduled Event를 이용해서 리부팅 전에 해야하는 작업 예를들어 Load Balancer의 백엔트 풀에서 제거, 백업 포인트, 커넥션 정리, Failover 실행 등의 작업을 미리 실행해 놓고 리부팅을 할 수 있습니다. 좀 더 고급스러운 접근 같습니다. 저도 적용해 보지는 않았지만 가용성 집합 내의 VM 하나가 폴링을 해서 이벤트를 캐치해야 하고 그 후 정리할 걸 정리하는 등 코드를 좀 짜줘야 할 것 같습니다. 자세한 내용은 문서와 <a href=\"https://channel9.msdn.com/Shows/Azure-Friday/Using-Azure-Scheduled-Events-to-Prepare-for-VM-Maintenance\">동영상</a> (데모 포함)참조 바랍니다.\n<h4>질문들</h4>\nStep 3에서 리부팅 시간을 미리 몇 일 또는 몇 시간 전에 알 수 있나요? 아니요 Scheduled Event를 이용해서 15분전에 알 수 있습니다.<p>VM 말고 Azure Web App 같은 PaaS 서비스도 이번에 적용되나요? 아니요. PaaS 서비스는 별도 스케줄로 업데이트가 되고 대걔 임팩트가 없는 방향으로 진행됩니다. PaaS의 장점이라고 할 수 있습니다.<p>&nbsp;<p>아 왜 업데이트가 있어서 귀찮게 ... 생각할 수 도 있지만 보안이나 가용성이 더 좋아질다고 하니 기꺼이 또는 강제로 업데이트를 해야하겠습니다. 더 상세한 내용을 알고 싶으시면 아래 링크 확인 바랍니다.\n<ul>\n \t<li><a href=\"https://azure.microsoft.com/en-us/resources/videos/azure-friday-virtual-machine-planned-maintenance-rafalovich/\">Azure Friday 동영상</a></li>\n \t<li><a href=\"https://azure.microsoft.com/en-us/blog/a-new-planned-maintenance-experience-for-your-virtual-machines/?cdn=disable\">공식 블로그 포스트(영문)</a></li>\n \t<li><a href=\"https://myignite.microsoft.com/videos/57085\">이그나이트 동영상 (영문)</a></li>\n \t<li><a href=\"https://docs.microsoft.com/ko-kr/azure/virtual-machines/windows/maintenance-and-updates\">문서</a></li>\n</ul>",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1513329757000,
                "created_by": 1,
                "updated_at": 1513329757000,
                "updated_by": 1,
                "published_at": 1513329757000,
                "published_by": 1
            },
            {
                "id": 5607,
                "title": "Azure CLI로 Azure 리소스를 태그로 검색해서 NSG 룰 추가",
                "slug": "azure-cli-find-nsg-add-rule",
                "markdown": "Azure 에서 사용하는 모든 리소스에 태그를 걸어 둘 수 있다. Key=value 쌍의 태그를 걸어놓고 사용할 수 있는데 Azure Portal에서는 태그 메뉴에서 추가할 수 있다.\n\n<a href=\"/content/images/2017/12/azure-portal-tag.jpg\"><img class=\"size-full wp-image-5608 aligncenter\" src=\"/content/images/2017/12/azure-portal-tag.jpg\" alt=\"\" width=\"1198\" height=\"701\" /></a>\n\n이 태그를 잘 정의해 놓으면 스크립트에서 태그로 검색해서 관련된 리소스만 가져와서 특정 작업을 할 수 있다. 여기에 소개된스크립트에서는 ServerType=GameServer 태그가 들어 있는 Network Security Group을 찾아서 방화벽 룰을 추가한다. Azure CLI 로 작성되었다.\n<pre class=\"prettyprint\">#!/bin/bash\n\n# tag query \ntagQuery=ServerType=GameServer\n\n# new rule\nruleName=http\ndescription=http-inbound\naccess=Allow\nprotocol=Tcp\ndirection=Inbound\npriority=102\nsourceAddressPrefix=*\nsourcePortRange=*\ndestinationAddressPrefix=*\ndestinationPortRange=443\n\naz resource list --tag $tagQuery --query \"[].{Name: name,Group: resourceGroup}\" -o tsv | \nwhile read -r name resourceGroup; do\n    printf \"Add new rule\"\n    az network nsg rule create -g $resourceGroup --nsg-name $name \\\n    --name $ruleName \\\n    --description $description \\\n    --access $access \\\n    --protocol $protocol  \\\n    --direction $direction \\\n    --priority $priority \\\n    --source-address-prefix \"$sourceAddressPrefix\" \\\n    --source-port-range \"$sourcePortRange\" \\\n    --destination-port-range \"$destinationPortRange\" \\\n    --destination-address-prefix \"$destinationAddressPrefix\"\n    \n\n    printf \"NSG: $name, ResourceGroup: $resourceGroup\"\n    az network nsg show -g $resourceGroup -n $name --query 'securityRules[].{Name:name,Desc:description,Access:access,Direction:direction,DestPortRange:destinationPortRange,DestAddrPrefix:destinationAddressPrefix,SrcPortRange:sourcePortRange,SrcAddrPrefix:sourceAddressPrefix}' -o table\ndone</pre>\n실행결과\n<pre class=\"prettyprint\">$ ./add-nsg-rule.sh\n{\n  \"access\": \"Allow\",\n  \"description\": \"http-inbound\",\n  \"destinationAddressPrefix\": \"*\",\n  \"destinationAddressPrefixes\": [],\n  \"destinationApplicationSecurityGroups\": null,\n  \"destinationPortRange\": \"443\",\n  \"destinationPortRanges\": [],\n  \"direction\": \"Inbound\",\n  \"etag\": \"W/\\\"123427a1-855a-441b-8a79-4950326c043c\\\"\",\n  \"id\": \"/subscriptions/12345bbb-cd59-41dc-86b7-2e239d536c04/resourceGroups/KaliGroup/providers/Microsoft.Network/networkSecurityGroups/KaliVM-nsg/securityRules/http\",\n  \"name\": \"http\",\n  \"priority\": 102,\n  \"protocol\": \"Tcp\",\n  \"provisioningState\": \"Succeeded\",\n  \"resourceGroup\": \"KaliGroup\",\n  \"sourceAddressPrefix\": \"*\",\n  \"sourceAddressPrefixes\": [],\n  \"sourceApplicationSecurityGroups\": null,\n  \"sourcePortRange\": \"*\",\n  \"sourcePortRanges\": []\n}\nNSG: KaliVM-nsg, ResourceGroup: Kali\nGroupName               Access    Direction      DestPortRange  DestAddrPrefix    SrcPortRange    SrcAddrPrefix    Desc\n-----------------  --------  -----------  ---------------  ----------------  --------------  ---------------  ------------\ndefault-allow-ssh  Allow     Inbound                   22  *                 *               *\nPort_3389          Allow     Inbound                 3389  *                 *               *\nhttp               Allow     Inbound                  443  *                 *               *                http-inbound\n</pre>",
                "html": "Azure 에서 사용하는 모든 리소스에 태그를 걸어 둘 수 있다. Key=value 쌍의 태그를 걸어놓고 사용할 수 있는데 Azure Portal에서는 태그 메뉴에서 추가할 수 있다.<p><a href=\"/content/images/2017/12/azure-portal-tag.jpg\"><img class=\"size-full wp-image-5608 aligncenter\" src=\"/content/images/2017/12/azure-portal-tag.jpg\" alt=\"\" width=\"1198\" height=\"701\" /></a><p>이 태그를 잘 정의해 놓으면 스크립트에서 태그로 검색해서 관련된 리소스만 가져와서 특정 작업을 할 수 있다. 여기에 소개된스크립트에서는 ServerType=GameServer 태그가 들어 있는 Network Security Group을 찾아서 방화벽 룰을 추가한다. Azure CLI 로 작성되었다.\n<pre class=\"prettyprint\">#!/bin/bash<p># tag query \ntagQuery=ServerType=GameServer<p># new rule\nruleName=http\ndescription=http-inbound\naccess=Allow\nprotocol=Tcp\ndirection=Inbound\npriority=102\nsourceAddressPrefix=*\nsourcePortRange=*\ndestinationAddressPrefix=*\ndestinationPortRange=443<p>az resource list --tag $tagQuery --query \"[].{Name: name,Group: resourceGroup}\" -o tsv | \nwhile read -r name resourceGroup; do\n    printf \"Add new rule\"\n    az network nsg rule create -g $resourceGroup --nsg-name $name \\\n    --name $ruleName \\\n    --description $description \\\n    --access $access \\\n    --protocol $protocol  \\\n    --direction $direction \\\n    --priority $priority \\\n    --source-address-prefix \"$sourceAddressPrefix\" \\\n    --source-port-range \"$sourcePortRange\" \\\n    --destination-port-range \"$destinationPortRange\" \\\n    --destination-address-prefix \"$destinationAddressPrefix\"\n    <p>    printf \"NSG: $name, ResourceGroup: $resourceGroup\"\n    az network nsg show -g $resourceGroup -n $name --query 'securityRules[].{Name:name,Desc:description,Access:access,Direction:direction,DestPortRange:destinationPortRange,DestAddrPrefix:destinationAddressPrefix,SrcPortRange:sourcePortRange,SrcAddrPrefix:sourceAddressPrefix}' -o table\ndone</pre>\n실행결과\n<pre class=\"prettyprint\">$ ./add-nsg-rule.sh\n{\n  \"access\": \"Allow\",\n  \"description\": \"http-inbound\",\n  \"destinationAddressPrefix\": \"*\",\n  \"destinationAddressPrefixes\": [],\n  \"destinationApplicationSecurityGroups\": null,\n  \"destinationPortRange\": \"443\",\n  \"destinationPortRanges\": [],\n  \"direction\": \"Inbound\",\n  \"etag\": \"W/\\\"123427a1-855a-441b-8a79-4950326c043c\\\"\",\n  \"id\": \"/subscriptions/12345bbb-cd59-41dc-86b7-2e239d536c04/resourceGroups/KaliGroup/providers/Microsoft.Network/networkSecurityGroups/KaliVM-nsg/securityRules/http\",\n  \"name\": \"http\",\n  \"priority\": 102,\n  \"protocol\": \"Tcp\",\n  \"provisioningState\": \"Succeeded\",\n  \"resourceGroup\": \"KaliGroup\",\n  \"sourceAddressPrefix\": \"*\",\n  \"sourceAddressPrefixes\": [],\n  \"sourceApplicationSecurityGroups\": null,\n  \"sourcePortRange\": \"*\",\n  \"sourcePortRanges\": []\n}\nNSG: KaliVM-nsg, ResourceGroup: Kali\nGroupName               Access    Direction      DestPortRange  DestAddrPrefix    SrcPortRange    SrcAddrPrefix    Desc\n-----------------  --------  -----------  ---------------  ----------------  --------------  ---------------  ------------\ndefault-allow-ssh  Allow     Inbound                   22  *                 *               *\nPort_3389          Allow     Inbound                 3389  *                 *               *\nhttp               Allow     Inbound                  443  *                 *               *                http-inbound\n</pre>",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1513657466000,
                "created_by": 1,
                "updated_at": 1513657466000,
                "updated_by": 1,
                "published_at": 1513657466000,
                "published_by": 1
            },
            {
                "id": 5614,
                "title": "Azure Linux VM 계정 추가",
                "slug": "azure-linux-vm-add-user",
                "markdown": "<h4>Azure Linux VM 계정 추가</h4>\nAzure Linux VM 생성할 때 계정하나를 만들면서 VM을 생성합니다. 이 계정으로 SSH 접속할 수 있고 sudo 로 루트가 필요한 명령을 수행할 수 있습니다.  마치 사용자를 추가할 수 없을 것 같은 생각이 들 수도 있지만 여기에 여러 사람이 동시 작업을 해야할 필요가 있을 때 계정를 추가할 수 있습니다. 특별한건 아니고 리눅스의 adduser 명령입니다.\n<pre class=\"prettyprint\"># 계정생성.\n$ sudo adduser ilseokoh\n\n# sudo 사용 가능하도록 sudo 그룹에 추가\n$ sudo adduser ilseokoh sudo\n\n# 비밀번호 생성 \n$ sudo passwd ilseokoh</pre>\n<h4>root 계정은 어디있나?</h4>\nAzure 에서 생성되는 Linux VM에는 root 계정이 비활성화 되어 있습니다. sudo 를 사용하면 되는데 추천하지 않지만 굳이 root를 살려야 하면 이렇게 하면 됩니다. 그러면 su 가 됩니다.\n<pre class=\"prettyprint\">$ sudo passwd -u root\n$ sudo passwd root \n$ su\n</pre>",
                "html": "<h4>Azure Linux VM 계정 추가</h4>\nAzure Linux VM 생성할 때 계정하나를 만들면서 VM을 생성합니다. 이 계정으로 SSH 접속할 수 있고 sudo 로 루트가 필요한 명령을 수행할 수 있습니다.  마치 사용자를 추가할 수 없을 것 같은 생각이 들 수도 있지만 여기에 여러 사람이 동시 작업을 해야할 필요가 있을 때 계정를 추가할 수 있습니다. 특별한건 아니고 리눅스의 adduser 명령입니다.\n<pre class=\"prettyprint\"># 계정생성.\n$ sudo adduser ilseokoh<p># sudo 사용 가능하도록 sudo 그룹에 추가\n$ sudo adduser ilseokoh sudo<p># 비밀번호 생성 \n$ sudo passwd ilseokoh</pre>\n<h4>root 계정은 어디있나?</h4>\nAzure 에서 생성되는 Linux VM에는 root 계정이 비활성화 되어 있습니다. sudo 를 사용하면 되는데 추천하지 않지만 굳이 root를 살려야 하면 이렇게 하면 됩니다. 그러면 su 가 됩니다.\n<pre class=\"prettyprint\">$ sudo passwd -u root\n$ sudo passwd root \n$ su\n</pre>",
                "image": null,
                "featured": false,
                "page": 0,
                "status": "published",
                "language": "en_US",
                "meta_title": null,
                "meta_description": null,
                "created_at": 1513845829000,
                "created_by": 1,
                "updated_at": 1513845829000,
                "updated_by": 1,
                "published_at": 1513845829000,
                "published_by": 1
            }
        ],
        "tags": [],
        "posts_tags": [
            {
                "post_id": 61
            },
            {
                "post_id": 61
            },
            {
                "post_id": 61
            },
            {
                "post_id": 61
            },
            {
                "post_id": 61
            },
            {
                "post_id": 61
            },
            {
                "post_id": 61
            },
            {
                "post_id": 61
            },
            {
                "post_id": 61
            },
            {
                "post_id": 61
            },
            {
                "post_id": 61
            },
            {
                "post_id": 61
            },
            {
                "post_id": 2091
            },
            {
                "post_id": 2091
            },
            {
                "post_id": 2091
            },
            {
                "post_id": 2091
            },
            {
                "post_id": 2091
            },
            {
                "post_id": 2091
            },
            {
                "post_id": 2091
            },
            {
                "post_id": 2091
            },
            {
                "post_id": 2091
            },
            {
                "post_id": 2091
            },
            {
                "post_id": 2091
            },
            {
                "post_id": 2091
            },
            {
                "post_id": 2251
            },
            {
                "post_id": 2251
            },
            {
                "post_id": 2251
            },
            {
                "post_id": 2251
            },
            {
                "post_id": 2251
            },
            {
                "post_id": 2251
            },
            {
                "post_id": 2251
            },
            {
                "post_id": 2251
            },
            {
                "post_id": 2251
            },
            {
                "post_id": 2251
            },
            {
                "post_id": 2251
            },
            {
                "post_id": 2251
            },
            {
                "post_id": 2291
            },
            {
                "post_id": 2291
            },
            {
                "post_id": 2291
            },
            {
                "post_id": 2291
            },
            {
                "post_id": 2291
            },
            {
                "post_id": 2291
            },
            {
                "post_id": 2291
            },
            {
                "post_id": 2291
            },
            {
                "post_id": 2291
            },
            {
                "post_id": 2291
            },
            {
                "post_id": 2291
            },
            {
                "post_id": 2421
            },
            {
                "post_id": 2421
            },
            {
                "post_id": 2421
            },
            {
                "post_id": 2421
            },
            {
                "post_id": 2421
            },
            {
                "post_id": 2421
            },
            {
                "post_id": 2421
            },
            {
                "post_id": 2561
            },
            {
                "post_id": 2561
            },
            {
                "post_id": 2561
            },
            {
                "post_id": 2561
            },
            {
                "post_id": 2561
            },
            {
                "post_id": 2561
            },
            {
                "post_id": 2561
            },
            {
                "post_id": 2561
            },
            {
                "post_id": 2561
            },
            {
                "post_id": 2561
            },
            {
                "post_id": 2591
            },
            {
                "post_id": 2591
            },
            {
                "post_id": 2591
            },
            {
                "post_id": 2591
            },
            {
                "post_id": 2591
            },
            {
                "post_id": 2591
            },
            {
                "post_id": 2591
            },
            {
                "post_id": 2591
            },
            {
                "post_id": 2591
            },
            {
                "post_id": 3011
            },
            {
                "post_id": 3011
            },
            {
                "post_id": 3171
            },
            {
                "post_id": 3171
            },
            {
                "post_id": 3171
            },
            {
                "post_id": 3171
            },
            {
                "post_id": 3171
            },
            {
                "post_id": 3171
            },
            {
                "post_id": 3251
            },
            {
                "post_id": 3251
            },
            {
                "post_id": 3251
            },
            {
                "post_id": 3251
            },
            {
                "post_id": 3251
            },
            {
                "post_id": 3251
            },
            {
                "post_id": 3251
            },
            {
                "post_id": 3421
            },
            {
                "post_id": 3421
            },
            {
                "post_id": 3421
            },
            {
                "post_id": 3421
            },
            {
                "post_id": 3421
            },
            {
                "post_id": 3421
            },
            {
                "post_id": 3511
            },
            {
                "post_id": 3511
            },
            {
                "post_id": 3511
            },
            {
                "post_id": 3511
            },
            {
                "post_id": 3511
            },
            {
                "post_id": 3511
            },
            {
                "post_id": 3511
            },
            {
                "post_id": 3511
            },
            {
                "post_id": 3511
            },
            {
                "post_id": 3571
            },
            {
                "post_id": 3571
            },
            {
                "post_id": 3571
            },
            {
                "post_id": 3571
            },
            {
                "post_id": 3571
            },
            {
                "post_id": 3651
            },
            {
                "post_id": 3651
            },
            {
                "post_id": 3731
            },
            {
                "post_id": 3731
            },
            {
                "post_id": 3801
            },
            {
                "post_id": 3801
            },
            {
                "post_id": 3801
            },
            {
                "post_id": 3831
            },
            {
                "post_id": 3831
            },
            {
                "post_id": 3831
            },
            {
                "post_id": 3831
            },
            {
                "post_id": 3911
            },
            {
                "post_id": 3911
            },
            {
                "post_id": 3911
            },
            {
                "post_id": 3911
            },
            {
                "post_id": 3911
            },
            {
                "post_id": 3911
            },
            {
                "post_id": 3911
            },
            {
                "post_id": 4281
            },
            {
                "post_id": 4281
            },
            {
                "post_id": 4281
            },
            {
                "post_id": 4281
            },
            {
                "post_id": 4281
            },
            {
                "post_id": 4281
            },
            {
                "post_id": 4431
            },
            {
                "post_id": 4431
            },
            {
                "post_id": 4431
            },
            {
                "post_id": 4431
            },
            {
                "post_id": 4431
            },
            {
                "post_id": 4471
            },
            {
                "post_id": 4471
            },
            {
                "post_id": 4471
            },
            {
                "post_id": 4471
            },
            {
                "post_id": 4471
            },
            {
                "post_id": 4471
            },
            {
                "post_id": 4471
            },
            {
                "post_id": 4471
            },
            {
                "post_id": 4471
            },
            {
                "post_id": 4611
            },
            {
                "post_id": 4611
            },
            {
                "post_id": 4611
            },
            {
                "post_id": 4611
            },
            {
                "post_id": 4611
            },
            {
                "post_id": 4791
            },
            {
                "post_id": 4791
            },
            {
                "post_id": 4791
            },
            {
                "post_id": 4791
            },
            {
                "post_id": 4791
            },
            {
                "post_id": 4791
            },
            {
                "post_id": 4791
            },
            {
                "post_id": 4791
            },
            {
                "post_id": 4791
            },
            {
                "post_id": 4951
            },
            {
                "post_id": 4951
            },
            {
                "post_id": 4951
            },
            {
                "post_id": 4951
            },
            {
                "post_id": 4951
            },
            {
                "post_id": 4951
            },
            {
                "post_id": 4951
            },
            {
                "post_id": 4951
            },
            {
                "post_id": 4951
            },
            {
                "post_id": 4951
            },
            {
                "post_id": 4951
            },
            {
                "post_id": 4951
            },
            {
                "post_id": 5104
            },
            {
                "post_id": 5104
            },
            {
                "post_id": 5104
            },
            {
                "post_id": 5104
            },
            {
                "post_id": 5104
            },
            {
                "post_id": 5104
            },
            {
                "post_id": 5104
            },
            {
                "post_id": 5118
            },
            {
                "post_id": 5118
            },
            {
                "post_id": 5118
            },
            {
                "post_id": 5118
            },
            {
                "post_id": 5118
            },
            {
                "post_id": 5118
            },
            {
                "post_id": 5118
            },
            {
                "post_id": 5118
            },
            {
                "post_id": 5118
            },
            {
                "post_id": 5134
            },
            {
                "post_id": 5134
            },
            {
                "post_id": 5134
            },
            {
                "post_id": 5134
            },
            {
                "post_id": 5138
            },
            {
                "post_id": 5138
            },
            {
                "post_id": 5138
            },
            {
                "post_id": 5156
            },
            {
                "post_id": 5156
            },
            {
                "post_id": 5156
            },
            {
                "post_id": 5156
            },
            {
                "post_id": 5156
            },
            {
                "post_id": 5164
            },
            {
                "post_id": 5164
            },
            {
                "post_id": 5164
            },
            {
                "post_id": 5164
            },
            {
                "post_id": 5164
            },
            {
                "post_id": 5186
            },
            {
                "post_id": 5186
            },
            {
                "post_id": 5186
            },
            {
                "post_id": 5186
            },
            {
                "post_id": 5186
            },
            {
                "post_id": 5186
            },
            {
                "post_id": 5186
            },
            {
                "post_id": 5186
            },
            {
                "post_id": 5186
            },
            {
                "post_id": 5186
            },
            {
                "post_id": 5229
            },
            {
                "post_id": 5229
            },
            {
                "post_id": 5229
            },
            {
                "post_id": 5229
            },
            {
                "post_id": 5229
            },
            {
                "post_id": 5229
            },
            {
                "post_id": 5229
            },
            {
                "post_id": 5229
            },
            {
                "post_id": 5229
            },
            {
                "post_id": 5229
            },
            {
                "post_id": 5229
            },
            {
                "post_id": 5258
            },
            {
                "post_id": 5258
            },
            {
                "post_id": 5292
            },
            {
                "post_id": 5292
            },
            {
                "post_id": 5292
            },
            {
                "post_id": 5292
            },
            {
                "post_id": 5292
            },
            {
                "post_id": 5292
            },
            {
                "post_id": 5292
            },
            {
                "post_id": 5292
            },
            {
                "post_id": 5301
            },
            {
                "post_id": 5301
            },
            {
                "post_id": 5301
            },
            {
                "post_id": 5301
            },
            {
                "post_id": 5301
            },
            {
                "post_id": 5301
            },
            {
                "post_id": 5305
            },
            {
                "post_id": 5305
            },
            {
                "post_id": 5305
            },
            {
                "post_id": 5305
            },
            {
                "post_id": 5305
            },
            {
                "post_id": 5320
            },
            {
                "post_id": 5320
            },
            {
                "post_id": 5320
            },
            {
                "post_id": 5320
            },
            {
                "post_id": 5326
            },
            {
                "post_id": 5326
            },
            {
                "post_id": 5326
            },
            {
                "post_id": 5326
            },
            {
                "post_id": 5330
            },
            {
                "post_id": 5330
            },
            {
                "post_id": 5330
            },
            {
                "post_id": 5330
            },
            {
                "post_id": 5330
            },
            {
                "post_id": 5340
            },
            {
                "post_id": 5340
            },
            {
                "post_id": 5340
            },
            {
                "post_id": 5340
            },
            {
                "post_id": 5340
            },
            {
                "post_id": 5340
            },
            {
                "post_id": 5340
            },
            {
                "post_id": 5340
            },
            {
                "post_id": 5339
            },
            {
                "post_id": 5339
            },
            {
                "post_id": 5339
            },
            {
                "post_id": 5339
            },
            {
                "post_id": 5352
            },
            {
                "post_id": 5352
            },
            {
                "post_id": 5352
            },
            {
                "post_id": 5352
            },
            {
                "post_id": 5352
            },
            {
                "post_id": 5352
            },
            {
                "post_id": 5352
            },
            {
                "post_id": 5352
            },
            {
                "post_id": 5363
            },
            {
                "post_id": 5363
            },
            {
                "post_id": 5363
            },
            {
                "post_id": 5363
            },
            {
                "post_id": 5363
            },
            {
                "post_id": 5363
            },
            {
                "post_id": 5363
            },
            {
                "post_id": 5380
            },
            {
                "post_id": 5380
            },
            {
                "post_id": 5380
            },
            {
                "post_id": 5380
            },
            {
                "post_id": 5380
            },
            {
                "post_id": 5380
            },
            {
                "post_id": 5380
            },
            {
                "post_id": 5400
            },
            {
                "post_id": 5400
            },
            {
                "post_id": 5400
            },
            {
                "post_id": 5400
            },
            {
                "post_id": 5400
            },
            {
                "post_id": 5400
            },
            {
                "post_id": 5400
            },
            {
                "post_id": 5400
            },
            {
                "post_id": 5400
            },
            {
                "post_id": 5400
            },
            {
                "post_id": 5400
            },
            {
                "post_id": 5422
            },
            {
                "post_id": 5422
            },
            {
                "post_id": 5422
            },
            {
                "post_id": 5422
            },
            {
                "post_id": 5422
            },
            {
                "post_id": 5422
            },
            {
                "post_id": 5422
            },
            {
                "post_id": 5422
            },
            {
                "post_id": 5422
            },
            {
                "post_id": 5422
            },
            {
                "post_id": 5422
            },
            {
                "post_id": 5422
            },
            {
                "post_id": 5422
            },
            {
                "post_id": 5441
            },
            {
                "post_id": 5441
            },
            {
                "post_id": 5441
            },
            {
                "post_id": 5441
            },
            {
                "post_id": 5441
            },
            {
                "post_id": 5441
            },
            {
                "post_id": 5441
            },
            {
                "post_id": 5441
            },
            {
                "post_id": 5441
            },
            {
                "post_id": 5441
            },
            {
                "post_id": 5441
            },
            {
                "post_id": 5441
            },
            {
                "post_id": 5441
            },
            {
                "post_id": 5455
            },
            {
                "post_id": 5455
            },
            {
                "post_id": 5455
            },
            {
                "post_id": 5455
            },
            {
                "post_id": 5455
            },
            {
                "post_id": 5468
            },
            {
                "post_id": 5468
            },
            {
                "post_id": 5468
            },
            {
                "post_id": 5468
            },
            {
                "post_id": 5468
            },
            {
                "post_id": 5468
            },
            {
                "post_id": 5468
            },
            {
                "post_id": 5468
            },
            {
                "post_id": 5488
            },
            {
                "post_id": 5488
            },
            {
                "post_id": 5488
            },
            {
                "post_id": 5488
            },
            {
                "post_id": 5488
            },
            {
                "post_id": 5488
            },
            {
                "post_id": 5488
            },
            {
                "post_id": 5488
            },
            {
                "post_id": 5497
            },
            {
                "post_id": 5497
            },
            {
                "post_id": 5497
            },
            {
                "post_id": 5497
            },
            {
                "post_id": 5497
            },
            {
                "post_id": 5497
            },
            {
                "post_id": 5497
            },
            {
                "post_id": 5497
            },
            {
                "post_id": 5508
            },
            {
                "post_id": 5508
            },
            {
                "post_id": 5508
            },
            {
                "post_id": 5508
            },
            {
                "post_id": 5508
            },
            {
                "post_id": 5508
            },
            {
                "post_id": 5508
            },
            {
                "post_id": 5508
            },
            {
                "post_id": 5533
            },
            {
                "post_id": 5533
            },
            {
                "post_id": 5533
            },
            {
                "post_id": 5533
            },
            {
                "post_id": 5533
            },
            {
                "post_id": 5533
            },
            {
                "post_id": 5533
            },
            {
                "post_id": 5533
            },
            {
                "post_id": 5545
            },
            {
                "post_id": 5545
            },
            {
                "post_id": 5545
            },
            {
                "post_id": 5545
            },
            {
                "post_id": 5545
            },
            {
                "post_id": 5545
            },
            {
                "post_id": 5545
            },
            {
                "post_id": 5545
            },
            {
                "post_id": 5545
            },
            {
                "post_id": 5545
            },
            {
                "post_id": 5558
            },
            {
                "post_id": 5558
            },
            {
                "post_id": 5558
            },
            {
                "post_id": 5558
            },
            {
                "post_id": 5558
            },
            {
                "post_id": 5558
            },
            {
                "post_id": 5558
            },
            {
                "post_id": 5593
            },
            {
                "post_id": 5593
            },
            {
                "post_id": 5593
            },
            {
                "post_id": 5593
            },
            {
                "post_id": 5593
            },
            {
                "post_id": 5607
            },
            {
                "post_id": 5607
            },
            {
                "post_id": 5607
            },
            {
                "post_id": 5607
            },
            {
                "post_id": 5607
            },
            {
                "post_id": 5607
            },
            {
                "post_id": 5607
            },
            {
                "post_id": 5607
            },
            {
                "post_id": 5607
            },
            {
                "post_id": 5614
            },
            {
                "post_id": 5614
            },
            {
                "post_id": 5614
            },
            {
                "post_id": 5614
            },
            {
                "post_id": 5614
            },
            {
                "post_id": 5614
            },
            {
                "post_id": 5614
            },
            {
                "post_id": 5614
            },
            {
                "post_id": 5614
            },
            {
                "post_id": 5614
            },
            {
                "post_id": 5614
            }
        ]
    }
}